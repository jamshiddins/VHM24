{
  "create-telegram-user.js": "#!/usr/bin/env node\r\n\r\nconst { getAuthClient } = require('./packages/database');\r\nconst bcrypt = require('bcrypt');\r\n\r\nasync function createTelegramUser() {\r\n  const prisma = getAuthClient();\r\n  \r\n  try {\r\n    console.log('🔧 Creating Telegram user for VHM24 Bot...');\r\n    \r\n    // Ваш Telegram ID из .env\r\n    const telegramId = process.env.ADMIN_IDS || '42283329';\r\n    const email = 'admin@vhm24.ru';\r\n    const name = 'VHM24 Admin';\r\n    const password = 'admin123';\r\n    \r\n    // Проверяем, существует ли пользователь\r\n    const existingUser = await prisma.user.findFirst({\r\n      where: {\r\n        OR: [\r\n          { telegramId },\r\n          { email }\r\n        ]\r\n      }\r\n    });\r\n    \r\n    if (existingUser) {\r\n      if (!existingUser.telegramId) {\r\n        // Обновляем существующего пользователя, добавляем Telegram ID\r\n        await prisma.user.update({\r\n          where: { id: existingUser.id },\r\n          data: { telegramId }\r\n        });\r\n        console.log('✅ Updated existing user with Telegram ID');\r\n      } else {\r\n        console.log('✅ User with Telegram ID already exists');\r\n      }\r\n    } else {\r\n      // Создаем нового пользователя\r\n      const passwordHash = await bcrypt.hash(password, 10);\r\n      \r\n      const user = await prisma.user.create({\r\n        data: {\r\n          email,\r\n          name,\r\n          passwordHash,\r\n          telegramId,\r\n          roles: ['ADMIN', 'MANAGER', 'OPERATOR'],\r\n          isActive: true\r\n        }\r\n      });\r\n      \r\n      console.log('✅ Created new user with Telegram ID');\r\n      console.log(`📧 Email: ${email}`);\r\n      console.log(`🔑 Password: ${password}`);\r\n      console.log(`📱 Telegram ID: ${telegramId}`);\r\n    }\r\n    \r\n    // Проверяем результат\r\n    const user = await prisma.user.findFirst({\r\n      where: { telegramId },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        telegramId: true,\r\n        roles: true,\r\n        isActive: true\r\n      }\r\n    });\r\n    \r\n    console.log('\\n📊 User details:');\r\n    console.log(JSON.stringify(user, null, 2));\r\n    \r\n    console.log('\\n🎉 Telegram user ready for VHM24 Bot!');\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Error creating Telegram user:', error);\r\n  } finally {\r\n    await prisma.$disconnect();\r\n  }\r\n}\r\n\r\ncreateTelegramUser();\r\n",
  "packages/shared/middleware/security.js": "/**\r\n * VHM24 Security Middleware\r\n * Критически важные middleware для безопасности всех сервисов\r\n */\r\n\r\nconst { PrismaClient } = require('@prisma/client');\r\nconst rateLimit = require('@fastify/rate-limit');\r\nconst helmet = require('@fastify/helmet');\r\nconst cors = require('@fastify/cors');\r\nconst jwt = require('@fastify/jwt');\r\nconst { \r\n  sanitizeInput, \r\n  isAllowedOrigin, \r\n  getRateLimitKey,\r\n  maskSensitiveData \r\n} = require('../../shared-types/src/security');\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n/**\r\n * Безопасный обработчик ошибок\r\n * Заменяет все reply.send(err) на безопасные responses\r\n */\r\nconst securityErrorHandler = (error, request, reply) => {\r\n  const isDev = process.env.NODE_ENV === 'development';\r\n  \r\n  // Логируем полную ошибку для разработки\r\n  if (isDev) {\r\n    console.error('Security Error:', {\r\n      error: error.message,\r\n      stack: error.stack,\r\n      url: request.url,\r\n      method: request.method,\r\n      headers: request.headers,\r\n      body: request.body\r\n    });\r\n  } else {\r\n    // В production логируем только основную информацию\r\n    console.error('Security Error:', {\r\n      error: error.name || 'Internal Server Error',\r\n      url: request.url,\r\n      method: request.method,\r\n      statusCode: error.statusCode || 500,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  }\r\n\r\n  // Определяем тип ошибки и соответствующий response\r\n  let statusCode = error.statusCode || 500;\r\n  let errorName = error.name || 'Internal Server Error';\r\n  let message = 'An error occurred';\r\n\r\n  // Специальная обработка для разных типов ошибок\r\n  switch (error.name) {\r\n    case 'ValidationError':\r\n      statusCode = 400;\r\n      message = isDev ? error.message : 'Invalid input data';\r\n      break;\r\n    case 'UnauthorizedError':\r\n    case 'JsonWebTokenError':\r\n    case 'TokenExpiredError':\r\n      statusCode = 401;\r\n      errorName = 'Unauthorized';\r\n      message = 'Authentication required';\r\n      break;\r\n    case 'ForbiddenError':\r\n      statusCode = 403;\r\n      errorName = 'Forbidden';\r\n      message = 'Access denied';\r\n      break;\r\n    case 'NotFoundError':\r\n      statusCode = 404;\r\n      errorName = 'Not Found';\r\n      message = 'Resource not found';\r\n      break;\r\n    case 'ConflictError':\r\n      statusCode = 409;\r\n      errorName = 'Conflict';\r\n      message = 'Resource conflict';\r\n      break;\r\n    case 'TooManyRequestsError':\r\n      statusCode = 429;\r\n      errorName = 'Too Many Requests';\r\n      message = 'Rate limit exceeded';\r\n      break;\r\n    case 'PrismaClientKnownRequestError':\r\n      statusCode = 400;\r\n      errorName = 'Database Error';\r\n      message = isDev ? error.message : 'Database operation failed';\r\n      break;\r\n    default:\r\n      if (isDev) {\r\n        message = error.message;\r\n      }\r\n  }\r\n\r\n  // Безопасный response без раскрытия внутренней информации\r\n  reply.code(statusCode).send({\r\n    error: errorName,\r\n    message: message,\r\n    statusCode: statusCode,\r\n    timestamp: new Date().toISOString(),\r\n    path: request.url\r\n  });\r\n};\r\n\r\n/**\r\n * Middleware аутентификации с проверкой активности пользователя\r\n */\r\nconst authenticate = async (request, reply) => {\r\n  try {\r\n    // Проверяем JWT токен\r\n    await request.jwtVerify();\r\n    \r\n    // Проверяем существование и активность пользователя\r\n    const user = await prisma.user.findUnique({\r\n      where: { \r\n        id: request.user.id,\r\n        isActive: true \r\n      },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        role: true,\r\n        isActive: true,\r\n        lastLoginAt: true,\r\n        createdAt: true\r\n      }\r\n    });\r\n\r\n    if (!user) {\r\n      throw new Error('User not found or inactive');\r\n    }\r\n\r\n    // Обновляем время последней активности\r\n    await prisma.user.update({\r\n      where: { id: user.id },\r\n      data: { lastLoginAt: new Date() }\r\n    });\r\n\r\n    // Добавляем пользователя в request\r\n    request.user = user;\r\n    \r\n  } catch (err) {\r\n    reply.code(401).send({\r\n      error: 'Unauthorized',\r\n      message: 'Authentication required',\r\n      statusCode: 401,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Middleware авторизации по ролям\r\n */\r\nconst authorize = (allowedRoles = []) => {\r\n  return async (request, reply) => {\r\n    if (!request.user) {\r\n      return reply.code(401).send({\r\n        error: 'Unauthorized',\r\n        message: 'Authentication required',\r\n        statusCode: 401\r\n      });\r\n    }\r\n\r\n    if (allowedRoles.length > 0 && !allowedRoles.includes(request.user.role)) {\r\n      return reply.code(403).send({\r\n        error: 'Forbidden',\r\n        message: 'Insufficient permissions',\r\n        statusCode: 403\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Middleware санитизации входных данных\r\n */\r\nconst sanitizeInputs = async (request, reply) => {\r\n  // Санитизация query параметров\r\n  if (request.query) {\r\n    for (const [key, value] of Object.entries(request.query)) {\r\n      if (typeof value === 'string') {\r\n        request.query[key] = sanitizeInput(value);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Санитизация body данных\r\n  if (request.body && typeof request.body === 'object') {\r\n    const visited = new WeakSet(); // Защита от циклических ссылок\r\n    \r\n    const sanitizeObject = (obj, depth = 0) => {\r\n      // Защита от слишком глубокой вложенности\r\n      if (depth > 10) {\r\n        return;\r\n      }\r\n      \r\n      // Защита от циклических ссылок\r\n      if (visited.has(obj)) {\r\n        return;\r\n      }\r\n      visited.add(obj);\r\n      \r\n      for (const [key, value] of Object.entries(obj)) {\r\n        if (typeof value === 'string') {\r\n          obj[key] = sanitizeInput(value);\r\n        } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\r\n          sanitizeObject(value, depth + 1);\r\n        } else if (Array.isArray(value)) {\r\n          // Обрабатываем массивы отдельно\r\n          value.forEach((item, index) => {\r\n            if (typeof item === 'string') {\r\n              value[index] = sanitizeInput(item);\r\n            } else if (typeof item === 'object' && item !== null) {\r\n              sanitizeObject(item, depth + 1);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    };\r\n    \r\n    sanitizeObject(request.body);\r\n  }\r\n};\r\n\r\n/**\r\n * Настройка CORS с безопасными origins\r\n */\r\nconst setupCORS = (fastify, options = {}) => {\r\n  const allowedOrigins = process.env.ALLOWED_ORIGINS \r\n    ? process.env.ALLOWED_ORIGINS.split(',')\r\n    : ['http://localhost:3000', 'http://localhost:3001'];\r\n\r\n  return fastify.register(cors, {\r\n    origin: (origin, callback) => {\r\n      // Разрешаем запросы без origin (например, мобильные приложения)\r\n      if (!origin) return callback(null, true);\r\n      \r\n      if (isAllowedOrigin(origin, allowedOrigins)) {\r\n        callback(null, true);\r\n      } else {\r\n        callback(new Error('Not allowed by CORS'), false);\r\n      }\r\n    },\r\n    credentials: true,\r\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],\r\n    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],\r\n    ...options\r\n  });\r\n};\r\n\r\n/**\r\n * Настройка Helmet для защиты заголовков\r\n */\r\nconst setupHelmet = (fastify, options = {}) => {\r\n  return fastify.register(helmet, {\r\n    contentSecurityPolicy: {\r\n      directives: {\r\n        defaultSrc: [\"'self'\"],\r\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\r\n        scriptSrc: [\"'self'\"],\r\n        imgSrc: [\"'self'\", \"data:\", \"https:\"],\r\n        connectSrc: [\"'self'\"],\r\n        fontSrc: [\"'self'\"],\r\n        objectSrc: [\"'none'\"],\r\n        mediaSrc: [\"'self'\"],\r\n        frameSrc: [\"'none'\"],\r\n      },\r\n    },\r\n    crossOriginEmbedderPolicy: false,\r\n    ...options\r\n  });\r\n};\r\n\r\n/**\r\n * Настройка Rate Limiting\r\n */\r\nconst setupRateLimit = (fastify, options = {}) => {\r\n  return fastify.register(rateLimit, {\r\n    max: options.max || 100, // максимум запросов\r\n    timeWindow: options.timeWindow || '1 minute', // временное окно\r\n    skipOnError: true, // пропускать при ошибках Redis\r\n    keyGenerator: (request) => {\r\n      // Используем IP + User ID для аутентифицированных пользователей\r\n      const ip = request.ip;\r\n      const userId = request.user?.id;\r\n      return userId ? `${ip}:${userId}` : ip;\r\n    },\r\n    errorResponseBuilder: (request, context) => {\r\n      return {\r\n        error: 'Too Many Requests',\r\n        message: `Rate limit exceeded. Try again in ${Math.round(context.ttl / 1000)} seconds.`,\r\n        statusCode: 429,\r\n        retryAfter: Math.round(context.ttl / 1000)\r\n      };\r\n    },\r\n    ...options\r\n  });\r\n};\r\n\r\n/**\r\n * Настройка JWT\r\n */\r\nconst setupJWT = (fastify, options = {}) => {\r\n  const jwtSecret = process.env.JWT_SECRET;\r\n  \r\n  if (!jwtSecret || jwtSecret.length < 32) {\r\n    throw new Error('JWT_SECRET must be at least 32 characters long');\r\n  }\r\n\r\n  return fastify.register(jwt, {\r\n    secret: jwtSecret,\r\n    sign: {\r\n      expiresIn: process.env.JWT_EXPIRES_IN || '7d'\r\n    },\r\n    verify: {\r\n      maxAge: process.env.JWT_EXPIRES_IN || '7d'\r\n    },\r\n    ...options\r\n  });\r\n};\r\n\r\n/**\r\n * Middleware логирования безопасных событий\r\n */\r\nconst securityLogger = async (request, reply) => {\r\n  const startTime = Date.now();\r\n  \r\n  // Логируем запрос (без чувствительных данных)\r\n  const logData = {\r\n    method: request.method,\r\n    url: request.url,\r\n    ip: request.ip,\r\n    userAgent: request.headers['user-agent'],\r\n    userId: request.user?.id,\r\n    timestamp: new Date().toISOString()\r\n  };\r\n\r\n  // Маскируем чувствительные данные в query и body\r\n  if (request.query) {\r\n    logData.query = { ...request.query };\r\n    if (logData.query.password) logData.query.password = '***';\r\n    if (logData.query.token) logData.query.token = '***';\r\n  }\r\n\r\n  console.log('Security Request:', logData);\r\n\r\n  // В Fastify 5.x используем reply.hijack() для логирования response\r\n  const originalSend = reply.send;\r\n  reply.send = function(payload) {\r\n    const duration = Date.now() - startTime;\r\n    console.log('Security Response:', {\r\n      method: request.method,\r\n      url: request.url,\r\n      statusCode: reply.statusCode,\r\n      duration: `${duration}ms`,\r\n      userId: request.user?.id,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n    return originalSend.call(this, payload);\r\n  };\r\n};\r\n\r\n/**\r\n * Проверка здоровья сервиса\r\n */\r\nconst healthCheck = async (request, reply) => {\r\n  try {\r\n    // Проверяем подключение к базе данных\r\n    await prisma.$queryRaw`SELECT 1`;\r\n    \r\n    reply.send({\r\n      status: 'healthy',\r\n      timestamp: new Date().toISOString(),\r\n      service: process.env.SERVICE_NAME || 'unknown',\r\n      version: process.env.SERVICE_VERSION || '1.0.0',\r\n      uptime: process.uptime()\r\n    });\r\n  } catch (error) {\r\n    reply.code(503).send({\r\n      status: 'unhealthy',\r\n      error: 'Database connection failed',\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  securityErrorHandler,\r\n  authenticate,\r\n  authorize,\r\n  sanitizeInputs,\r\n  setupCORS,\r\n  setupHelmet,\r\n  setupRateLimit,\r\n  setupJWT,\r\n  securityLogger,\r\n  healthCheck\r\n};\r\n",
  "scripts/auto-fixer.js": "const fs = require('fs');\r\nconst path = require('path');\r\nconst { execSync } = require('child_process');\r\n\r\nclass AutoFixer {\r\n  constructor(analysisReport) {\r\n    this.report = analysisReport;\r\n    this.fixed = [];\r\n    this.failed = [];\r\n    this.backups = new Map();\r\n  }\r\n\r\n  async fixAllIssues() {\r\n    console.log('🔧 Starting Auto-Fix Process...\\n');\r\n    \r\n    // Создаем резервные копии\r\n    await this.createBackups();\r\n    \r\n    try {\r\n      // 1. Исправляем критические проблемы безопасности\r\n      await this.fixSecurityIssues();\r\n      \r\n      // 2. Исправляем проблемы с зависимостями\r\n      await this.fixDependencyIssues();\r\n      \r\n      // 3. Исправляем проблемы кода\r\n      await this.fixCodeIssues();\r\n      \r\n      // 4. Добавляем отсутствующие компоненты\r\n      await this.addMissingComponents();\r\n      \r\n      // 5. Оптимизируем производительность\r\n      await this.fixPerformanceIssues();\r\n      \r\n      // 6. Генерируем отчет\r\n      this.generateFixReport();\r\n      \r\n    } catch (error) {\r\n      console.error('❌ Error during fix process:', error);\r\n      await this.rollbackAll();\r\n    }\r\n  }\r\n\r\n  async createBackups() {\r\n    console.log('📦 Creating backups...');\r\n    \r\n    const filesToBackup = new Set();\r\n    \r\n    // Собираем все файлы из отчета\r\n    Object.values(this.report.issues).flat().forEach(issue => {\r\n      if (issue.file) filesToBackup.add(issue.file);\r\n    });\r\n    \r\n    filesToBackup.forEach(file => {\r\n      const content = fs.readFileSync(file, 'utf8');\r\n      this.backups.set(file, content);\r\n    });\r\n    \r\n    // Сохраняем бекап на диск\r\n    fs.writeFileSync('backup.json', JSON.stringify(Object.fromEntries(this.backups), null, 2));\r\n    console.log(`✅ Created backups for ${this.backups.size} files`);\r\n  }\r\n\r\n  async fixSecurityIssues() {\r\n    console.log('\\n🔒 Fixing security issues...');\r\n    \r\n    const securityFixes = {\r\n      // Исправление утечки ошибок\r\n      'reply.send(err)': {\r\n        pattern: /reply\\.(send|code\\(\\d+\\)\\.send)\\s*\\(\\s*err\\s*\\)/g,\r\n        replacement: `reply.code(err.statusCode || 500).send({\r\n          error: err.name || 'Internal Server Error',\r\n          message: process.env.NODE_ENV === 'development' ? err.message : 'An error occurred'\r\n        })`\r\n      },\r\n      \r\n      // Добавление валидации\r\n      'missing-validation': {\r\n        detect: (content) => content.includes('async (request, reply)') && \r\n                             content.includes('request.body') && \r\n                             !content.includes('schema:'),\r\n        fix: (content, filePath) => {\r\n          // Находим все routes и добавляем схемы\r\n          return this.addValidationSchemas(content, filePath);\r\n        }\r\n      },\r\n      \r\n      // Замена hardcoded credentials\r\n      'hardcoded-secrets': {\r\n        patterns: [\r\n          { match: /JWT_SECRET\\s*=\\s*[\"'][^\"']+[\"']/g, replace: 'JWT_SECRET = process.env.JWT_SECRET' },\r\n          { match: /password:\\s*[\"'][^\"']+[\"']/g, replace: 'password: process.env.DB_PASSWORD' }\r\n        ]\r\n      }\r\n    };\r\n    \r\n    this.report.issues.critical.forEach(issue => {\r\n      if (issue.file && issue.issue.includes('Утечка информации')) {\r\n        this.fixInFile(issue.file, securityFixes['reply.send(err)']);\r\n      }\r\n    });\r\n  }\r\n\r\n  async fixDependencyIssues() {\r\n    console.log('\\n📦 Fixing dependency issues...');\r\n    \r\n    // Автоматическое исправление уязвимостей\r\n    try {\r\n      console.log('Running npm audit fix...');\r\n      execSync('npm audit fix', { stdio: 'inherit' });\r\n      this.fixed.push('Fixed npm vulnerabilities');\r\n    } catch (e) {\r\n      this.failed.push('npm audit fix failed');\r\n    }\r\n    \r\n    // Установка отсутствующих зависимостей\r\n    const missingDeps = new Map();\r\n    \r\n    this.report.issues.high.forEach(issue => {\r\n      if (issue.issue.includes('Отсутствует зависимость')) {\r\n        const match = issue.issue.match(/Отсутствует зависимость: (.+)/);\r\n        if (match) {\r\n          const dep = match[1];\r\n          const service = issue.file.split('/')[1];\r\n          \r\n          if (!missingDeps.has(service)) {\r\n            missingDeps.set(service, []);\r\n          }\r\n          missingDeps.get(service).push(dep);\r\n        }\r\n      }\r\n    });\r\n    \r\n    missingDeps.forEach((deps, service) => {\r\n      const servicePath = path.join('services', service);\r\n      console.log(`Installing dependencies for ${service}: ${deps.join(', ')}`);\r\n      \r\n      try {\r\n        execSync(`cd ${servicePath} && npm install ${deps.join(' ')}`, { stdio: 'inherit' });\r\n        this.fixed.push(`Installed dependencies for ${service}`);\r\n      } catch (e) {\r\n        this.failed.push(`Failed to install dependencies for ${service}`);\r\n      }\r\n    });\r\n  }\r\n\r\n  async fixCodeIssues() {\r\n    console.log('\\n📝 Fixing code issues...');\r\n    \r\n    // Конвертация ES6 в CommonJS\r\n    this.report.issues.high.forEach(issue => {\r\n      if (issue.issue.includes('Смешивание ES6 и CommonJS')) {\r\n        this.convertToCommonJS(issue.file);\r\n      }\r\n    });\r\n    \r\n    // Добавление try-catch\r\n    this.report.issues.medium.forEach(issue => {\r\n      if (issue.issue.includes('Async функции без обработки ошибок')) {\r\n        this.addTryCatch(issue.file);\r\n      }\r\n    });\r\n    \r\n    // Замена console.log на logger\r\n    this.report.issues.low.forEach(issue => {\r\n      if (issue.issue.includes('console.log')) {\r\n        this.replaceConsoleLog(issue.file);\r\n      }\r\n    });\r\n  }\r\n\r\n  async addMissingComponents() {\r\n    console.log('\\n➕ Adding missing components...');\r\n    \r\n    // Создание отсутствующих Dockerfile\r\n    const services = fs.readdirSync('services');\r\n    services.forEach(service => {\r\n      const dockerfilePath = path.join('services', service, 'Dockerfile');\r\n      if (!fs.existsSync(dockerfilePath)) {\r\n        this.createDockerfile(service, dockerfilePath);\r\n      }\r\n    });\r\n    \r\n    // Создание CI/CD pipeline\r\n    if (!fs.existsSync('.github/workflows')) {\r\n      this.createGitHubActions();\r\n    }\r\n    \r\n    // Добавление health checks\r\n    services.forEach(service => {\r\n      const indexPath = path.join('services', service, 'src', 'index.js');\r\n      if (fs.existsSync(indexPath)) {\r\n        this.addHealthCheck(indexPath);\r\n      }\r\n    });\r\n    \r\n    // Создание тестов\r\n    services.forEach(service => {\r\n      this.createTestsForService(service);\r\n    });\r\n  }\r\n\r\n  async fixPerformanceIssues() {\r\n    console.log('\\n⚡ Fixing performance issues...');\r\n    \r\n    // Добавление пагинации\r\n    this.report.issues.high.forEach(issue => {\r\n      if (issue.issue.includes('findMany без пагинации')) {\r\n        this.addPagination(issue.file);\r\n      }\r\n    });\r\n    \r\n    // Замена синхронных операций\r\n    this.report.issues.medium.forEach(issue => {\r\n      if (issue.issue.includes('Синхронные операции')) {\r\n        this.makeAsync(issue.file);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Вспомогательные методы для исправлений\r\n  fixInFile(filePath, fix) {\r\n    try {\r\n      let content = fs.readFileSync(filePath, 'utf8');\r\n      const originalContent = content;\r\n      \r\n      if (fix.pattern && fix.replacement) {\r\n        content = content.replace(fix.pattern, fix.replacement);\r\n      } else if (fix.fix) {\r\n        content = fix.fix(content, filePath);\r\n      }\r\n      \r\n      if (content !== originalContent) {\r\n        fs.writeFileSync(filePath, content);\r\n        this.fixed.push(`Fixed: ${filePath} - ${fix.pattern || 'custom fix'}`);\r\n      }\r\n    } catch (error) {\r\n      this.failed.push(`Failed to fix ${filePath}: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  convertToCommonJS(filePath) {\r\n    try {\r\n      let content = fs.readFileSync(filePath, 'utf8');\r\n      \r\n      // Конвертируем import в require\r\n      content = content.replace(/import\\s+(\\w+)\\s+from\\s+['\"]([^'\"]+)['\"]/g, \r\n        \"const $1 = require('$2')\");\r\n      \r\n      content = content.replace(/import\\s+\\*\\s+as\\s+(\\w+)\\s+from\\s+['\"]([^'\"]+)['\"]/g,\r\n        \"const $1 = require('$2')\");\r\n      \r\n      content = content.replace(/import\\s+\\{([^}]+)\\}\\s+from\\s+['\"]([^'\"]+)['\"]/g,\r\n        \"const {$1} = require('$2')\");\r\n      \r\n      // Конвертируем export в module.exports\r\n      content = content.replace(/export\\s+default\\s+/g, 'module.exports = ');\r\n      content = content.replace(/export\\s+\\{([^}]+)\\}/g, 'module.exports = {$1}');\r\n      content = content.replace(/export\\s+(const|let|var)\\s+/g, '$1 ');\r\n      \r\n      // Добавляем exports в конец если нужно\r\n      if (!content.includes('module.exports')) {\r\n        const exports = content.match(/(?:const|let|var)\\s+(\\w+)\\s*=/g) || [];\r\n        if (exports.length > 0) {\r\n          const exportNames = exports.map(e => e.match(/(\\w+)\\s*=/)[1]);\r\n          content += `\\n\\nmodule.exports = { ${exportNames.join(', ')} };`;\r\n        }\r\n      }\r\n      \r\n      fs.writeFileSync(filePath, content);\r\n      this.fixed.push(`Converted to CommonJS: ${filePath}`);\r\n    } catch (error) {\r\n      this.failed.push(`Failed to convert ${filePath}: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  addValidationSchemas(content, filePath) {\r\n    // Создаем базовые схемы для common endpoints\r\n    const schemas = `\r\nconst schemas = {\r\n  createSchema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['name'],\r\n      properties: {\r\n        name: { type: 'string', minLength: 1, maxLength: 255 },\r\n        description: { type: 'string', maxLength: 1000 }\r\n      }\r\n    }\r\n  },\r\n  updateSchema: {\r\n    body: {\r\n      type: 'object',\r\n      properties: {\r\n        name: { type: 'string', minLength: 1, maxLength: 255 },\r\n        description: { type: 'string', maxLength: 1000 }\r\n      }\r\n    }\r\n  },\r\n  querySchema: {\r\n    query: {\r\n      type: 'object',\r\n      properties: {\r\n        page: { type: 'integer', minimum: 1, default: 1 },\r\n        limit: { type: 'integer', minimum: 1, maximum: 100, default: 20 },\r\n        search: { type: 'string', maxLength: 100 }\r\n      }\r\n    }\r\n  }\r\n};\r\n`;\r\n    \r\n    // Добавляем схемы в начало файла\r\n    if (!content.includes('schemas')) {\r\n      content = schemas + '\\n' + content;\r\n    }\r\n    \r\n    // Добавляем schema к routes\r\n    content = content.replace(\r\n      /fastify\\.(get|post|put|patch|delete)\\s*\\(\\s*['\"][^'\"]+['\"]\\s*,\\s*async/g,\r\n      (match) => {\r\n        if (match.includes('post') || match.includes('put') || match.includes('patch')) {\r\n          return match.replace('async', '{ schema: schemas.createSchema }, async');\r\n        } else if (match.includes('get') && !match.includes('/health')) {\r\n          return match.replace('async', '{ schema: schemas.querySchema }, async');\r\n        }\r\n        return match;\r\n      }\r\n    );\r\n    \r\n    return content;\r\n  }\r\n\r\n  addTryCatch(filePath) {\r\n    try {\r\n      let content = fs.readFileSync(filePath, 'utf8');\r\n      \r\n      // Находим async функции без try-catch\r\n      const asyncFunctionRegex = /(async\\s+(?:function\\s+)?\\w*\\s*\\([^)]*\\)\\s*(?:=>)?\\s*\\{)([^}]+)(\\})/g;\r\n      \r\n      content = content.replace(asyncFunctionRegex, (match, start, body, end) => {\r\n        if (!body.includes('try')) {\r\n          return `${start}\r\n  try {${body}  } catch (error) {\r\n    console.error('Error:', error);\r\n    throw error;\r\n  }\r\n${end}`;\r\n        }\r\n        return match;\r\n      });\r\n      \r\n      fs.writeFileSync(filePath, content);\r\n      this.fixed.push(`Added try-catch blocks: ${filePath}`);\r\n    } catch (error) {\r\n      this.failed.push(`Failed to add try-catch: ${filePath}`);\r\n    }\r\n  }\r\n\r\n  replaceConsoleLog(filePath) {\r\n    try {\r\n      let content = fs.readFileSync(filePath, 'utf8');\r\n      \r\n      // Добавляем logger если его нет\r\n      if (!content.includes('logger')) {\r\n        content = `const logger = require('@vhm24/shared/logger');\\n\\n` + content;\r\n      }\r\n      \r\n      // Заменяем console.log\r\n      content = content.replace(/console\\.log\\(/g, 'logger.info(');\r\n      content = content.replace(/console\\.error\\(/g, 'logger.error(');\r\n      content = content.replace(/console\\.warn\\(/g, 'logger.warn(');\r\n      \r\n      fs.writeFileSync(filePath, content);\r\n      this.fixed.push(`Replaced console.log with logger: ${filePath}`);\r\n    } catch (error) {\r\n      this.failed.push(`Failed to replace console.log: ${filePath}`);\r\n    }\r\n  }\r\n\r\n  createDockerfile(service, dockerfilePath) {\r\n    const dockerfile = `# Build stage\r\nFROM node:18-alpine AS builder\r\n\r\nWORKDIR /app\r\n\r\n# Copy package files\r\nCOPY package*.json ./\r\nCOPY services/${service}/package*.json ./services/${service}/\r\n\r\n# Install dependencies\r\nRUN npm ci --only=production\r\n\r\n# Copy source code\r\nCOPY services/${service} ./services/${service}\r\nCOPY packages ./packages\r\n\r\n# Production stage\r\nFROM node:18-alpine\r\n\r\nWORKDIR /app\r\n\r\n# Copy from builder\r\nCOPY --from=builder /app/node_modules ./node_modules\r\nCOPY --from=builder /app/services/${service} ./services/${service}\r\nCOPY --from=builder /app/packages ./packages\r\n\r\n# Add non-root user\r\nRUN addgroup -g 1001 -S nodejs\r\nRUN adduser -S nodejs -u 1001\r\nUSER nodejs\r\n\r\n# Expose port\r\nEXPOSE \\${PORT:-3000}\r\n\r\n# Health check\r\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\\\r\n  CMD node -e \"require('http').get('http://localhost:' + (process.env.PORT || 3000) + '/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))\"\r\n\r\n# Start service\r\nCMD [\"node\", \"services/${service}/src/index.js\"]\r\n`;\r\n    \r\n    fs.writeFileSync(dockerfilePath, dockerfile);\r\n    this.fixed.push(`Created Dockerfile for ${service}`);\r\n  }\r\n\r\n  createGitHubActions() {\r\n    const workflowDir = '.github/workflows';\r\n    fs.mkdirSync(workflowDir, { recursive: true });\r\n    \r\n    const ciWorkflow = `name: CI/CD Pipeline\r\n\r\non:\r\n  push:\r\n    branches: [main, develop]\r\n  pull_request:\r\n    branches: [main]\r\n\r\njobs:\r\n  test:\r\n    runs-on: ubuntu-latest\r\n    \r\n    services:\r\n      postgres:\r\n        image: postgres:15\r\n        env:\r\n          POSTGRES_PASSWORD: postgres\r\n        options: >-\r\n          --health-cmd pg_isready\r\n          --health-interval 10s\r\n          --health-timeout 5s\r\n          --health-retries 5\r\n        ports:\r\n          - 5432:5432\r\n          \r\n      redis:\r\n        image: redis:7\r\n        options: >-\r\n          --health-cmd \"redis-cli ping\"\r\n          --health-interval 10s\r\n          --health-timeout 5s\r\n          --health-retries 5\r\n        ports:\r\n          - 6379:6379\r\n    \r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      \r\n      - name: Setup Node.js\r\n        uses: actions/setup-node@v3\r\n        with:\r\n          node-version: 18\r\n          cache: 'npm'\r\n      \r\n      - name: Install dependencies\r\n        run: |\r\n          npm ci\r\n          npm ci --workspaces\r\n      \r\n      - name: Run linter\r\n        run: npm run lint --if-present\r\n      \r\n      - name: Run tests\r\n        run: npm test\r\n        env:\r\n          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test\r\n          REDIS_URL: redis://localhost:6379\r\n          JWT_SECRET: test-secret-key-for-testing-only\r\n      \r\n      - name: Build\r\n        run: npm run build --if-present\r\n      \r\n      - name: Upload coverage\r\n        uses: codecov/codecov-action@v3\r\n        if: always()\r\n\r\n  security:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      \r\n      - name: Run security audit\r\n        run: npm audit --audit-level=high\r\n      \r\n      - name: Run Snyk\r\n        uses: snyk/actions/node@master\r\n        env:\r\n          SNYK_TOKEN: \\${{ secrets.SNYK_TOKEN }}\r\n        continue-on-error: true\r\n\r\n  docker:\r\n    needs: [test, security]\r\n    runs-on: ubuntu-latest\r\n    if: github.ref == 'refs/heads/main'\r\n    \r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      \r\n      - name: Set up Docker Buildx\r\n        uses: docker/setup-buildx-action@v2\r\n      \r\n      - name: Login to Docker Hub\r\n        uses: docker/login-action@v2\r\n        with:\r\n          username: \\${{ secrets.DOCKER_USERNAME }}\r\n          password: \\${{ secrets.DOCKER_PASSWORD }}\r\n      \r\n      - name: Build and push\r\n        uses: docker/build-push-action@v4\r\n        with:\r\n          context: .\r\n          push: true\r\n          tags: |\r\n            vhm24/platform:latest\r\n            vhm24/platform:\\${{ github.sha }}\r\n          cache-from: type=registry,ref=vhm24/platform:buildcache\r\n          cache-to: type=registry,ref=vhm24/platform:buildcache,mode=max\r\n`;\r\n    \r\n    fs.writeFileSync(path.join(workflowDir, 'ci.yml'), ciWorkflow);\r\n    this.fixed.push('Created GitHub Actions CI/CD pipeline');\r\n  }\r\n\r\n  addHealthCheck(filePath) {\r\n    try {\r\n      let content = fs.readFileSync(filePath, 'utf8');\r\n      \r\n      if (!content.includes('/health')) {\r\n        const healthEndpoint = `\r\n// Health check endpoint\r\nfastify.get('/health', async (request, reply) => {\r\n  const health = {\r\n    status: 'ok',\r\n    timestamp: new Date().toISOString(),\r\n    service: '${path.basename(path.dirname(path.dirname(filePath)))}',\r\n    uptime: process.uptime(),\r\n    memory: process.memoryUsage(),\r\n    checks: {}\r\n  };\r\n  \r\n  // Database check\r\n  try {\r\n    await prisma.$queryRaw\\`SELECT 1\\`;\r\n    health.checks.database = 'ok';\r\n  } catch (error) {\r\n    health.checks.database = 'error';\r\n    health.status = 'degraded';\r\n  }\r\n  \r\n  // Redis check (if applicable)\r\n  if (typeof redis !== 'undefined') {\r\n    try {\r\n      await redis.ping();\r\n      health.checks.redis = 'ok';\r\n    } catch (error) {\r\n      health.checks.redis = 'error';\r\n      health.status = 'degraded';\r\n    }\r\n  }\r\n  \r\n  reply.code(health.status === 'ok' ? 200 : 503).send(health);\r\n});\r\n`;\r\n        \r\n        // Добавляем перед fastify.listen\r\n        content = content.replace(/(fastify\\.listen)/g, healthEndpoint + '\\n$1');\r\n        \r\n        fs.writeFileSync(filePath, content);\r\n        this.fixed.push(`Added health check: ${filePath}`);\r\n      }\r\n    } catch (error) {\r\n      this.failed.push(`Failed to add health check: ${filePath}`);\r\n    }\r\n  }\r\n\r\n  createTestsForService(service) {\r\n    const testDir = path.join('services', service, 'tests');\r\n    fs.mkdirSync(testDir, { recursive: true });\r\n    \r\n    // Создаем базовый тест\r\n    const testFile = `const { test } = require('tap');\r\nconst build = require('../src/app');\r\n\r\ntest('health check', async (t) => {\r\n  const app = build({ logger: false });\r\n  \r\n  const response = await app.inject({\r\n    method: 'GET',\r\n    url: '/health'\r\n  });\r\n  \r\n  t.equal(response.statusCode, 200);\r\n  t.match(JSON.parse(response.payload), {\r\n    status: 'ok',\r\n    service: '${service}'\r\n  });\r\n});\r\n\r\ntest('requires authentication', async (t) => {\r\n  const app = build({ logger: false });\r\n  \r\n  const response = await app.inject({\r\n    method: 'GET',\r\n    url: '/api/v1/${service}'\r\n  });\r\n  \r\n  t.equal(response.statusCode, 401);\r\n});\r\n`;\r\n    \r\n    const testPath = path.join(testDir, `${service}.test.js`);\r\n    if (!fs.existsSync(testPath)) {\r\n      fs.writeFileSync(testPath, testFile);\r\n      this.fixed.push(`Created tests for ${service}`);\r\n    }\r\n  }\r\n\r\n  addPagination(filePath) {\r\n    try {\r\n      let content = fs.readFileSync(filePath, 'utf8');\r\n      \r\n      // Заменяем findMany() на findMany с пагинацией\r\n      content = content.replace(\r\n        /\\.findMany\\(\\s*\\)/g,\r\n        `.findMany({\r\n      skip: (request.query.page - 1) * request.query.limit,\r\n      take: request.query.limit,\r\n      orderBy: { createdAt: 'desc' }\r\n    })`\r\n      );\r\n      \r\n      // Также для findMany({})\r\n      content = content.replace(\r\n        /\\.findMany\\(\\s*\\{\\s*\\}\\s*\\)/g,\r\n        `.findMany({\r\n      skip: (request.query.page - 1) * request.query.limit,\r\n      take: request.query.limit,\r\n      orderBy: { createdAt: 'desc' }\r\n    })`\r\n      );\r\n      \r\n      fs.writeFileSync(filePath, content);\r\n      this.fixed.push(`Added pagination: ${filePath}`);\r\n    } catch (error) {\r\n      this.failed.push(`Failed to add pagination: ${filePath}`);\r\n    }\r\n  }\r\n\r\n  makeAsync(filePath) {\r\n    try {\r\n      let content = fs.readFileSync(filePath, 'utf8');\r\n      \r\n      // Заменяем синхронные операции на асинхронные\r\n      content = content.replace(/readFileSync\\(/g, 'await fs.promises.readFile(');\r\n      content = content.replace(/writeFileSync\\(/g, 'await fs.promises.writeFile(');\r\n      \r\n      // Добавляем импорт если нужно\r\n      if (content.includes('fs.promises') && !content.includes(\"require('fs').promises\")) {\r\n        content = content.replace(\r\n          /const fs = require\\(['\"]fs['\"]\\)/,\r\n          \"const fs = require('fs')\\nconst { promises: fsPromises } = fs\"\r\n        );\r\n        content = content.replace(/fs\\.promises/g, 'fsPromises');\r\n      }\r\n      \r\n      fs.writeFileSync(filePath, content);\r\n      this.fixed.push(`Made operations async: ${filePath}`);\r\n    } catch (error) {\r\n      this.failed.push(`Failed to make async: ${filePath}`);\r\n    }\r\n  }\r\n\r\n  async rollbackAll() {\r\n    console.log('\\n🔄 Rolling back all changes...');\r\n    \r\n    this.backups.forEach((content, filePath) => {\r\n      fs.writeFileSync(filePath, content);\r\n      console.log(`Restored: ${filePath}`);\r\n    });\r\n  }\r\n\r\n  generateFixReport() {\r\n    const report = {\r\n      timestamp: new Date().toISOString(),\r\n      fixed: this.fixed,\r\n      failed: this.failed,\r\n      summary: {\r\n        totalFixed: this.fixed.length,\r\n        totalFailed: this.failed.length,\r\n        successRate: Math.round((this.fixed.length / (this.fixed.length + this.failed.length)) * 100)\r\n      }\r\n    };\r\n    \r\n    fs.writeFileSync('fix-report.json', JSON.stringify(report, null, 2));\r\n    \r\n    console.log('\\n📊 Fix Report:');\r\n    console.log(`✅ Fixed: ${this.fixed.length} issues`);\r\n    console.log(`❌ Failed: ${this.failed.length} issues`);\r\n    console.log(`📈 Success rate: ${report.summary.successRate}%`);\r\n    \r\n    if (this.failed.length > 0) {\r\n      console.log('\\n❌ Failed fixes:');\r\n      this.failed.forEach(fail => console.log(`  - ${fail}`));\r\n    }\r\n  }\r\n}\r\n\r\n// Запуск автоматического исправления\r\nasync function runAutoFix() {\r\n  // Сначала запускаем анализ\r\n  const analysisReport = JSON.parse(fs.readFileSync('analysis-report.json', 'utf8'));\r\n  \r\n  // Затем исправляем\r\n  const fixer = new AutoFixer(analysisReport);\r\n  await fixer.fixAllIssues();\r\n}\r\n\r\nrunAutoFix().catch(console.error);\r\n",
  "scripts/deploy-to-railway.js": "const { execSync } = require('child_process');\r\nconst fs = require('fs');\r\n\r\nconsole.log('🚂 VHM24 Railway Deployment Script\\n');\r\n\r\n// Проверяем наличие Railway CLI\r\nfunction checkRailwayCLI() {\r\n  try {\r\n    execSync('railway --version', { stdio: 'pipe' });\r\n    console.log('✅ Railway CLI найден');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('❌ Railway CLI не найден. Установите: npm install -g @railway/cli');\r\n    return false;\r\n  }\r\n}\r\n\r\n// Проверяем авторизацию в Railway\r\nfunction checkRailwayAuth() {\r\n  try {\r\n    execSync('railway whoami', { stdio: 'pipe' });\r\n    console.log('✅ Авторизация в Railway активна');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('❌ Не авторизованы в Railway. Выполните: railway login');\r\n    return false;\r\n  }\r\n}\r\n\r\n// Проверяем наличие необходимых файлов\r\nfunction checkRequiredFiles() {\r\n  const requiredFiles = [\r\n    'package.json',\r\n    'nixpacks.toml',\r\n    'railway.toml',\r\n    'scripts/start-production.js',\r\n    'scripts/check-env.js',\r\n    'packages/shared/storage/s3.js'\r\n  ];\r\n\r\n  let allFilesExist = true;\r\n  \r\n  requiredFiles.forEach(file => {\r\n    if (fs.existsSync(file)) {\r\n      console.log(`✅ ${file}`);\r\n    } else {\r\n      console.error(`❌ ${file} не найден`);\r\n      allFilesExist = false;\r\n    }\r\n  });\r\n\r\n  return allFilesExist;\r\n}\r\n\r\n// Основная функция деплоя\r\nasync function deployToRailway() {\r\n  console.log('🔍 Проверка готовности к деплою...\\n');\r\n\r\n  // Проверки\r\n  if (!checkRailwayCLI()) return;\r\n  if (!checkRailwayAuth()) return;\r\n  if (!checkRequiredFiles()) return;\r\n\r\n  console.log('\\n🚀 Начинаем деплой...\\n');\r\n\r\n  try {\r\n    // 1. Проверяем текущий проект\r\n    console.log('1️⃣ Проверка Railway проекта...');\r\n    try {\r\n      const projectInfo = execSync('railway status', { stdio: 'pipe' }).toString();\r\n      console.log('✅ Подключен к Railway проекту');\r\n    } catch (error) {\r\n      console.log('⚠️ Не подключен к проекту. Создаем новый...');\r\n      execSync('railway new vhm24-production', { stdio: 'inherit' });\r\n    }\r\n\r\n    // 2. Добавляем базы данных если их нет\r\n    console.log('\\n2️⃣ Проверка баз данных...');\r\n    try {\r\n      const services = execSync('railway services', { stdio: 'pipe' }).toString();\r\n      \r\n      if (!services.includes('postgresql')) {\r\n        console.log('📦 Добавляем PostgreSQL...');\r\n        execSync('railway add postgresql', { stdio: 'inherit' });\r\n      } else {\r\n        console.log('✅ PostgreSQL уже добавлен');\r\n      }\r\n      \r\n      if (!services.includes('redis')) {\r\n        console.log('📦 Добавляем Redis...');\r\n        execSync('railway add redis', { stdio: 'inherit' });\r\n      } else {\r\n        console.log('✅ Redis уже добавлен');\r\n      }\r\n    } catch (error) {\r\n      console.log('⚠️ Не удалось проверить сервисы, продолжаем...');\r\n    }\r\n\r\n    // 3. Устанавливаем переменные окружения\r\n    console.log('\\n3️⃣ Настройка переменных окружения...');\r\n    \r\n    const envVars = {\r\n      NODE_ENV: 'production',\r\n      RAILWAY_SERVICE_NAME: 'gateway',\r\n      JWT_SECRET: 'your-super-secret-jwt-key-change-this-in-production-12345678',\r\n      TELEGRAM_BOT_TOKEN: '8015112367:AAHi25gHhI3p1X1uyuCAt8vUnlMZRrcoKEQ',\r\n      ADMIN_IDS: '42283329',\r\n      ALLOWED_ORIGINS: 'https://your-app.railway.app',\r\n      MAX_FILE_SIZE: '10485760',\r\n      RATE_LIMIT_MAX: '100',\r\n      RATE_LIMIT_WINDOW: '60000',\r\n      SESSION_EXPIRY: '86400000',\r\n      EMAIL_FROM: 'noreply@vhm24.ru'\r\n    };\r\n\r\n    Object.entries(envVars).forEach(([key, value]) => {\r\n      try {\r\n        execSync(`railway variables set ${key}=\"${value}\"`, { stdio: 'pipe' });\r\n        console.log(`✅ ${key} установлен`);\r\n      } catch (error) {\r\n        console.log(`⚠️ Не удалось установить ${key}`);\r\n      }\r\n    });\r\n\r\n    // 4. Проверяем переменные окружения\r\n    console.log('\\n4️⃣ Проверка переменных окружения...');\r\n    try {\r\n      execSync('node scripts/check-env.js', { stdio: 'inherit' });\r\n    } catch (error) {\r\n      console.log('⚠️ Некоторые переменные отсутствуют, но продолжаем деплой...');\r\n    }\r\n\r\n    // 5. Запускаем деплой\r\n    console.log('\\n5️⃣ Запуск деплоя...');\r\n    execSync('railway up', { stdio: 'inherit' });\r\n\r\n    // 6. Получаем URL приложения\r\n    console.log('\\n6️⃣ Получение URL приложения...');\r\n    try {\r\n      const domain = execSync('railway domain', { stdio: 'pipe' }).toString().trim();\r\n      console.log(`🌐 Приложение доступно по адресу: ${domain}`);\r\n      \r\n      // Тестируем health endpoint\r\n      console.log('\\n7️⃣ Тестирование приложения...');\r\n      setTimeout(() => {\r\n        try {\r\n          const { execSync } = require('child_process');\r\n          execSync(`curl -f ${domain}/health`, { stdio: 'pipe' });\r\n          console.log('✅ Health check прошел успешно');\r\n        } catch (error) {\r\n          console.log('⚠️ Health check не прошел, проверьте логи');\r\n        }\r\n      }, 30000); // Ждем 30 секунд для запуска\r\n\r\n    } catch (error) {\r\n      console.log('⚠️ Не удалось получить домен, проверьте Railway dashboard');\r\n    }\r\n\r\n    console.log('\\n🎉 Деплой завершен!');\r\n    console.log('\\n📋 Следующие шаги:');\r\n    console.log('1. Настройте DigitalOcean Spaces (см. DIGITALOCEAN_SPACES_SETUP.md)');\r\n    console.log('2. Обновите ALLOWED_ORIGINS с реальным URL');\r\n    console.log('3. Проверьте логи: railway logs');\r\n    console.log('4. Настройте домен: railway domain add your-domain.com');\r\n\r\n  } catch (error) {\r\n    console.error('\\n❌ Ошибка деплоя:', error.message);\r\n    console.log('\\n🔧 Troubleshooting:');\r\n    console.log('1. Проверьте логи: railway logs');\r\n    console.log('2. Проверьте переменные: railway variables');\r\n    console.log('3. Проверьте статус: railway status');\r\n  }\r\n}\r\n\r\n// Запуск\r\ndeployToRailway();\r\n",
  "scripts/project-analyzer.js": "const fs = require('fs');\r\nconst path = require('path');\r\nconst { execSync } = require('child_process');\r\n\r\nclass ProjectAnalyzer {\r\n  constructor() {\r\n    this.issues = {\r\n      critical: [],\r\n      high: [],\r\n      medium: [],\r\n      low: [],\r\n      info: []\r\n    };\r\n    this.stats = {\r\n      filesAnalyzed: 0,\r\n      totalIssues: 0,\r\n      fixedIssues: 0\r\n    };\r\n  }\r\n\r\n  async runFullAnalysis() {\r\n    console.log('🔍 VHM24 Project Deep Analysis\\n');\r\n    \r\n    // 1. Анализ безопасности\r\n    await this.securityAnalysis();\r\n    \r\n    // 2. Анализ кода\r\n    await this.codeQualityAnalysis();\r\n    \r\n    // 3. Анализ зависимостей\r\n    await this.dependencyAnalysis();\r\n    \r\n    // 4. Анализ производительности\r\n    await this.performanceAnalysis();\r\n    \r\n    // 5. Анализ архитектуры\r\n    await this.architectureAnalysis();\r\n    \r\n    // 6. Анализ DevOps\r\n    await this.devopsAnalysis();\r\n    \r\n    // 7. Генерация отчета\r\n    this.generateReport();\r\n  }\r\n\r\n  async securityAnalysis() {\r\n    console.log('🔒 Анализ безопасности...\\n');\r\n    \r\n    // Поиск утечек данных\r\n    this.scanFiles('**/*.js', (filePath, content) => {\r\n      // Проверка на reply.send(err)\r\n      if (content.match(/reply\\.(send|code\\(\\d+\\)\\.send)\\s*\\(\\s*err\\s*\\)/)) {\r\n        this.addIssue('critical', {\r\n          file: filePath,\r\n          line: this.getLineNumber(content, /reply\\.send\\s*\\(\\s*err\\s*\\)/),\r\n          issue: 'Утечка информации об ошибках',\r\n          fix: 'reply.code(500).send({ error: \"Internal Server Error\" })'\r\n        });\r\n      }\r\n      \r\n      // Проверка на отсутствие валидации\r\n      if (content.includes('request.body') && !content.includes('schema:')) {\r\n        this.addIssue('high', {\r\n          file: filePath,\r\n          issue: 'Отсутствует валидация входных данных',\r\n          fix: 'Добавить JSON Schema валидацию'\r\n        });\r\n      }\r\n      \r\n      // Проверка на hardcoded credentials\r\n      const secretPatterns = [\r\n        /password\\s*[:=]\\s*[\"'][\\w\\d]{4,}/i,\r\n        /secret\\s*[:=]\\s*[\"'][\\w\\d]{4,}/i,\r\n        /api[_-]?key\\s*[:=]\\s*[\"'][\\w\\d]{4,}/i\r\n      ];\r\n      \r\n      secretPatterns.forEach(pattern => {\r\n        if (pattern.test(content)) {\r\n          this.addIssue('critical', {\r\n            file: filePath,\r\n            issue: 'Hardcoded credentials',\r\n            fix: 'Использовать переменные окружения'\r\n          });\r\n        }\r\n      });\r\n      \r\n      // Проверка JWT\r\n      if (content.includes('jwt') && !content.includes('expiresIn')) {\r\n        this.addIssue('medium', {\r\n          file: filePath,\r\n          issue: 'JWT токены без срока жизни',\r\n          fix: 'Добавить expiresIn в JWT опции'\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  async codeQualityAnalysis() {\r\n    console.log('📝 Анализ качества кода...\\n');\r\n    \r\n    // Проверка на смешивание модулей\r\n    this.scanFiles('**/*.js', (filePath, content) => {\r\n      const hasImport = content.includes('import ');\r\n      const hasRequire = content.includes('require(');\r\n      \r\n      if (hasImport && hasRequire) {\r\n        this.addIssue('high', {\r\n          file: filePath,\r\n          issue: 'Смешивание ES6 и CommonJS модулей',\r\n          fix: 'Использовать только CommonJS (require/module.exports)'\r\n        });\r\n      }\r\n      \r\n      // Проверка на отсутствие try-catch\r\n      if (content.includes('async') && !content.includes('try')) {\r\n        this.addIssue('medium', {\r\n          file: filePath,\r\n          issue: 'Async функции без обработки ошибок',\r\n          fix: 'Добавить try-catch блоки'\r\n        });\r\n      }\r\n      \r\n      // Проверка на console.log\r\n      if (content.includes('console.log')) {\r\n        this.addIssue('low', {\r\n          file: filePath,\r\n          issue: 'Использование console.log вместо logger',\r\n          fix: 'Использовать структурированное логирование (pino/winston)'\r\n        });\r\n      }\r\n      \r\n      // Проверка на магические числа\r\n      const magicNumbers = content.match(/\\b\\d{4,}\\b/g);\r\n      if (magicNumbers && magicNumbers.length > 2) {\r\n        this.addIssue('low', {\r\n          file: filePath,\r\n          issue: 'Магические числа в коде',\r\n          fix: 'Вынести в константы'\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  async dependencyAnalysis() {\r\n    console.log('📦 Анализ зависимостей...\\n');\r\n    \r\n    try {\r\n      // npm audit\r\n      const auditResult = execSync('npm audit --json', { stdio: 'pipe' }).toString();\r\n      const audit = JSON.parse(auditResult);\r\n      \r\n      if (audit.metadata.vulnerabilities.total > 0) {\r\n        this.addIssue('critical', {\r\n          issue: `Найдено ${audit.metadata.vulnerabilities.total} уязвимостей`,\r\n          critical: audit.metadata.vulnerabilities.critical,\r\n          high: audit.metadata.vulnerabilities.high,\r\n          fix: 'npm audit fix --force'\r\n        });\r\n      }\r\n    } catch (e) {\r\n      // npm audit возвращает non-zero при наличии уязвимостей\r\n    }\r\n    \r\n    // Проверка отсутствующих зависимостей\r\n    this.scanFiles('services/*/src/**/*.js', (filePath, content) => {\r\n      const requires = content.match(/require\\(['\"]([^'\"]+)['\"]\\)/g) || [];\r\n      requires.forEach(req => {\r\n        const module = req.match(/require\\(['\"]([^'\"]+)['\"]\\)/)[1];\r\n        if (!module.startsWith('.') && !module.startsWith('@vhm24')) {\r\n          const servicePath = filePath.split('/').slice(0, 2).join('/');\r\n          const packageJsonPath = path.join(servicePath, 'package.json');\r\n          \r\n          if (fs.existsSync(packageJsonPath)) {\r\n            const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\r\n            const deps = Object.keys(pkg.dependencies || {});\r\n            \r\n            if (!deps.includes(module) && !this.isBuiltinModule(module)) {\r\n              this.addIssue('high', {\r\n                file: filePath,\r\n                issue: `Отсутствует зависимость: ${module}`,\r\n                fix: `cd ${servicePath} && npm install ${module}`\r\n              });\r\n            }\r\n          }\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  async performanceAnalysis() {\r\n    console.log('⚡ Анализ производительности...\\n');\r\n    \r\n    this.scanFiles('**/*.js', (filePath, content) => {\r\n      // Проверка на отсутствие пагинации\r\n      if (content.includes('findMany()') || content.includes('findMany({})')) {\r\n        this.addIssue('high', {\r\n          file: filePath,\r\n          issue: 'findMany без пагинации',\r\n          fix: 'Добавить skip/take параметры'\r\n        });\r\n      }\r\n      \r\n      // Проверка на синхронные операции\r\n      if (content.includes('readFileSync') || content.includes('writeFileSync')) {\r\n        this.addIssue('medium', {\r\n          file: filePath,\r\n          issue: 'Синхронные операции файловой системы',\r\n          fix: 'Использовать асинхронные версии'\r\n        });\r\n      }\r\n      \r\n      // Проверка на отсутствие индексов\r\n      if (content.includes('where:') && content.includes('createdAt')) {\r\n        this.addIssue('medium', {\r\n          file: filePath,\r\n          issue: 'Запросы по неиндексированным полям',\r\n          fix: 'Добавить индексы в schema.prisma'\r\n        });\r\n      }\r\n      \r\n      // Проверка на N+1 проблемы\r\n      if (content.includes('.map') && content.includes('await') && content.includes('prisma')) {\r\n        this.addIssue('high', {\r\n          file: filePath,\r\n          issue: 'Потенциальная N+1 проблема',\r\n          fix: 'Использовать include или Promise.all'\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  async architectureAnalysis() {\r\n    console.log('🏗️ Анализ архитектуры...\\n');\r\n    \r\n    // Проверка структуры сервисов\r\n    const services = fs.readdirSync('services');\r\n    services.forEach(service => {\r\n      const requiredDirs = ['src', 'tests', 'docs'];\r\n      const servicePath = path.join('services', service);\r\n      \r\n      requiredDirs.forEach(dir => {\r\n        if (!fs.existsSync(path.join(servicePath, dir))) {\r\n          this.addIssue('medium', {\r\n            service,\r\n            issue: `Отсутствует директория ${dir}`,\r\n            fix: `mkdir -p ${servicePath}/${dir}`\r\n          });\r\n        }\r\n      });\r\n      \r\n      // Проверка наличия тестов\r\n      const testDir = path.join(servicePath, 'tests');\r\n      if (!fs.existsSync(testDir) || fs.readdirSync(testDir).length === 0) {\r\n        this.addIssue('high', {\r\n          service,\r\n          issue: 'Отсутствуют тесты',\r\n          fix: 'Создать модульные и интеграционные тесты'\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Проверка дублирования кода\r\n    const codePatterns = new Map();\r\n    this.scanFiles('**/*.js', (filePath, content) => {\r\n      // Ищем повторяющиеся паттерны\r\n      const functions = content.match(/function\\s+\\w+|const\\s+\\w+\\s*=\\s*(?:async\\s*)?\\(/g) || [];\r\n      functions.forEach(func => {\r\n        if (codePatterns.has(func)) {\r\n          codePatterns.get(func).push(filePath);\r\n        } else {\r\n          codePatterns.set(func, [filePath]);\r\n        }\r\n      });\r\n    });\r\n    \r\n    codePatterns.forEach((files, pattern) => {\r\n      if (files.length > 2) {\r\n        this.addIssue('medium', {\r\n          issue: `Дублирование кода: ${pattern}`,\r\n          files: files,\r\n          fix: 'Вынести в shared пакет'\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  async devopsAnalysis() {\r\n    console.log('🚀 Анализ DevOps...\\n');\r\n    \r\n    // Проверка Dockerfile\r\n    const services = fs.readdirSync('services');\r\n    services.forEach(service => {\r\n      if (!fs.existsSync(path.join('services', service, 'Dockerfile'))) {\r\n        this.addIssue('high', {\r\n          service,\r\n          issue: 'Отсутствует Dockerfile',\r\n          fix: 'Создать multi-stage Dockerfile'\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Проверка CI/CD\r\n    if (!fs.existsSync('.github/workflows')) {\r\n      this.addIssue('high', {\r\n        issue: 'Отсутствует CI/CD pipeline',\r\n        fix: 'Создать GitHub Actions workflow'\r\n      });\r\n    }\r\n    \r\n    // Проверка .dockerignore\r\n    if (!fs.existsSync('.dockerignore')) {\r\n      this.addIssue('medium', {\r\n        issue: 'Отсутствует .dockerignore',\r\n        fix: 'Создать .dockerignore файл'\r\n      });\r\n    }\r\n    \r\n    // Проверка health checks\r\n    this.scanFiles('services/*/src/index.js', (filePath, content) => {\r\n      if (!content.includes('/health')) {\r\n        this.addIssue('high', {\r\n          file: filePath,\r\n          issue: 'Отсутствует health check endpoint',\r\n          fix: 'Добавить GET /health endpoint'\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  // Вспомогательные методы\r\n  scanFiles(pattern, callback) {\r\n    const glob = require('glob');\r\n    const files = glob.sync(pattern, { \r\n      ignore: ['**/node_modules/**', '**/dist/**', '**/coverage/**'] \r\n    });\r\n    \r\n    files.forEach(file => {\r\n      const content = fs.readFileSync(file, 'utf8');\r\n      callback(file, content);\r\n      this.stats.filesAnalyzed++;\r\n    });\r\n  }\r\n\r\n  addIssue(severity, issue) {\r\n    this.issues[severity].push(issue);\r\n    this.stats.totalIssues++;\r\n  }\r\n\r\n  getLineNumber(content, pattern) {\r\n    const lines = content.split('\\n');\r\n    for (let i = 0; i < lines.length; i++) {\r\n      if (pattern.test(lines[i])) {\r\n        return i + 1;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  isBuiltinModule(module) {\r\n    const builtins = ['fs', 'path', 'http', 'https', 'crypto', 'os', 'util', 'stream', 'events'];\r\n    return builtins.includes(module);\r\n  }\r\n\r\n  generateReport() {\r\n    const report = {\r\n      timestamp: new Date().toISOString(),\r\n      stats: this.stats,\r\n      issues: this.issues,\r\n      summary: {\r\n        critical: this.issues.critical.length,\r\n        high: this.issues.high.length,\r\n        medium: this.issues.medium.length,\r\n        low: this.issues.low.length,\r\n        total: this.stats.totalIssues\r\n      }\r\n    };\r\n    \r\n    // Сохраняем детальный JSON отчет\r\n    fs.writeFileSync('analysis-report.json', JSON.stringify(report, null, 2));\r\n    \r\n    // Создаем Markdown отчет\r\n    let markdown = `# VHM24 Project Analysis Report\r\n\r\nGenerated: ${new Date().toLocaleString()}\r\n\r\n## 📊 Summary\r\n\r\n- **Files Analyzed**: ${this.stats.filesAnalyzed}\r\n- **Total Issues**: ${this.stats.totalIssues}\r\n- **Critical**: ${this.issues.critical.length}\r\n- **High**: ${this.issues.high.length}\r\n- **Medium**: ${this.issues.medium.length}\r\n- **Low**: ${this.issues.low.length}\r\n\r\n## 🚨 Critical Issues\\n\\n`;\r\n\r\n    ['critical', 'high', 'medium', 'low'].forEach(severity => {\r\n      if (this.issues[severity].length > 0) {\r\n        markdown += `### ${severity.toUpperCase()} Priority\\n\\n`;\r\n        this.issues[severity].forEach((issue, index) => {\r\n          markdown += `${index + 1}. **${issue.issue}**\\n`;\r\n          if (issue.file) markdown += `   - File: \\`${issue.file}\\`\\n`;\r\n          if (issue.line) markdown += `   - Line: ${issue.line}\\n`;\r\n          if (issue.fix) markdown += `   - Fix: \\`${issue.fix}\\`\\n`;\r\n          markdown += '\\n';\r\n        });\r\n      }\r\n    });\r\n    \r\n    fs.writeFileSync('ANALYSIS_REPORT.md', markdown);\r\n    \r\n    console.log('\\n✅ Analysis complete!');\r\n    console.log(`📄 Reports saved: analysis-report.json, ANALYSIS_REPORT.md`);\r\n  }\r\n}\r\n\r\n// Запуск анализа\r\nconst analyzer = new ProjectAnalyzer();\r\nanalyzer.runFullAnalysis().catch(console.error);\r\n",
  "scripts/setup-railway-env.js": "const { execSync } = require('child_process');\r\n\r\nconsole.log('🚂 Настройка переменных окружения для Railway...\\n');\r\n\r\n// Переменные из вашего .env файла\r\nconst envVars = {\r\n  // Безопасность\r\n  JWT_SECRET: 'your-super-secret-jwt-key-change-this-in-production-12345678',\r\n  ALLOWED_ORIGINS: 'https://your-app.railway.app,https://your-dashboard.railway.app',\r\n  \r\n  // База данных (уже есть в Railway)\r\n  DATABASE_URL: 'postgresql://postgres:tcaqejEXLSdaUdMQXFqEDGBQvavWVbGy@metro.proxy.rlwy.net:36258/railway',\r\n  AUTH_DATABASE_URL: 'postgresql://postgres:tcaqejEXLSdaUdMQXFqEDGBQvavWVbGy@metro.proxy.rlwy.net:36258/railway',\r\n  \r\n  // Redis (уже есть в Railway)\r\n  REDIS_URL: 'redis://default:RgADgivPNrtbjDUQYGWfzkJnmwCEnPil@maglev.proxy.rlwy.net:56313',\r\n  REDIS_TTL: '3600',\r\n  \r\n  // Telegram Bot\r\n  TELEGRAM_BOT_TOKEN: '8015112367:AAHi25gHhI3p1X1uyuCAt8vUnlMZRrcoKEQ',\r\n  ADMIN_IDS: '42283329',\r\n  \r\n  // Порты (Railway автоматически назначает PORT)\r\n  GATEWAY_PORT: '8000',\r\n  AUTH_PORT: '3001',\r\n  MACHINES_PORT: '3002',\r\n  INVENTORY_PORT: '3003',\r\n  TASKS_PORT: '3004',\r\n  BUNKERS_PORT: '3005',\r\n  \r\n  // API Configuration\r\n  API_URL: 'https://your-app.railway.app/api/v1',\r\n  \r\n  // File Storage - НУЖНО ЗАМЕНИТЬ НА DIGITALOCEAN SPACES\r\n  MAX_FILE_SIZE: '10485760',\r\n  \r\n  // Rate Limiting\r\n  RATE_LIMIT_MAX: '100',\r\n  RATE_LIMIT_WINDOW: '60000',\r\n  \r\n  // Session\r\n  SESSION_EXPIRY: '86400000',\r\n  \r\n  // Environment\r\n  NODE_ENV: 'production',\r\n  \r\n  // Monitoring\r\n  PROMETHEUS_PORT: '9090',\r\n  \r\n  // Email\r\n  SMTP_HOST: 'smtp.gmail.com',\r\n  SMTP_PORT: '587',\r\n  EMAIL_FROM: 'noreply@vhm24.ru',\r\n  \r\n  // Backup\r\n  BACKUP_ENABLED: 'true',\r\n  BACKUP_SCHEDULE: '0 2 * * *',\r\n  BACKUP_RETENTION_DAYS: '30'\r\n};\r\n\r\n// DigitalOcean Spaces переменные (нужно будет добавить после создания)\r\nconst digitalOceanVars = {\r\n  // DigitalOcean Spaces для файлов\r\n  S3_ENDPOINT: 'https://fra1.digitaloceanspaces.com', // или другой регион\r\n  S3_BUCKET: 'vhm24-uploads',\r\n  S3_ACCESS_KEY: 'YOUR_DO_SPACES_ACCESS_KEY',\r\n  S3_SECRET_KEY: 'YOUR_DO_SPACES_SECRET_KEY',\r\n  S3_REGION: 'fra1', // или другой регион\r\n  \r\n  // Для бэкапов\r\n  BACKUP_S3_BUCKET: 'vhm24-backups',\r\n  BACKUP_S3_ACCESS_KEY: 'YOUR_DO_SPACES_ACCESS_KEY',\r\n  BACKUP_S3_SECRET_KEY: 'YOUR_DO_SPACES_SECRET_KEY',\r\n  BACKUP_S3_ENDPOINT: 'https://fra1.digitaloceanspaces.com'\r\n};\r\n\r\nfunction setRailwayVariable(key, value) {\r\n  try {\r\n    console.log(`Setting ${key}...`);\r\n    execSync(`railway variables set ${key}=\"${value}\"`, { stdio: 'pipe' });\r\n    console.log(`✅ ${key} set successfully`);\r\n  } catch (error) {\r\n    console.error(`❌ Failed to set ${key}: ${error.message}`);\r\n  }\r\n}\r\n\r\nconsole.log('🔧 Устанавливаем основные переменные...\\n');\r\n\r\n// Устанавливаем основные переменные\r\nObject.entries(envVars).forEach(([key, value]) => {\r\n  setRailwayVariable(key, value);\r\n});\r\n\r\nconsole.log('\\n⚠️ ВАЖНО: Нужно настроить DigitalOcean Spaces переменные:');\r\nconsole.log('После создания DigitalOcean Spaces выполните:');\r\nconsole.log('');\r\n\r\nObject.entries(digitalOceanVars).forEach(([key, value]) => {\r\n  console.log(`railway variables set ${key}=\"${value}\"`);\r\n});\r\n\r\nconsole.log('\\n✅ Основные переменные установлены!');\r\nconsole.log('\\n📋 Следующие шаги:');\r\nconsole.log('1. Создайте DigitalOcean Spaces (инструкции ниже)');\r\nconsole.log('2. Установите DigitalOcean переменные');\r\nconsole.log('3. Запустите деплой: railway up');\r\n",
  "services/audit/src/index.js": "const fastify = require('fastify')({ logger: true });\r\nconst { PrismaClient } = require('@prisma/client');\r\nconst cron = require('node-cron');\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// Регистрация плагинов\r\nfastify.register(require('@fastify/cors'), {\r\n  origin: true,\r\n  credentials: true\r\n});\r\n\r\nfastify.register(require('@fastify/helmet'));\r\nfastify.register(require('@fastify/rate-limit'), {\r\n  max: 100,\r\n  timeWindow: '1 minute'\r\n});\r\n\r\nfastify.register(require('@fastify/jwt'), {\r\n  secret: process.env.JWT_SECRET || 'your-secret-key'\r\n});\r\n\r\n// Импорт маршрутов\r\nfastify.register(require('./routes/audit'), { prefix: '/api/audit' });\r\nfastify.register(require('./routes/reports'), { prefix: '/api/reports' });\r\nfastify.register(require('./routes/incomplete-data'), { prefix: '/api/incomplete-data' });\r\n\r\n// Middleware для аутентификации\r\nfastify.decorate('authenticate', async function(request, reply) {\r\n  try {\r\n    await request.jwtVerify();\r\n  } catch (err) {\r\n    reply.send(err);\r\n  }\r\n});\r\n\r\n// Middleware для логирования всех запросов\r\nfastify.addHook('preHandler', async (request, reply) => {\r\n  const auditService = require('./services/auditService');\r\n  \r\n  // Логируем все входящие запросы\r\n  await auditService.logSystemAction({\r\n    userId: request.user?.id || null,\r\n    sessionId: request.headers['x-session-id'] || null,\r\n    action: 'READ',\r\n    entity: 'API_REQUEST',\r\n    description: `${request.method} ${request.url}`,\r\n    inputData: {\r\n      method: request.method,\r\n      url: request.url,\r\n      params: request.params,\r\n      query: request.query,\r\n      body: request.method !== 'GET' ? request.body : undefined\r\n    },\r\n    ipAddress: request.ip,\r\n    userAgent: request.headers['user-agent'],\r\n    endpoint: request.url,\r\n    method: request.method\r\n  });\r\n});\r\n\r\n// Hook для логирования ответов\r\nfastify.addHook('onSend', async (request, reply, payload) => {\r\n  const auditService = require('./services/auditService');\r\n  \r\n  await auditService.logSystemAction({\r\n    userId: request.user?.id || null,\r\n    sessionId: request.headers['x-session-id'] || null,\r\n    action: 'INFO',\r\n    entity: 'API_RESPONSE',\r\n    description: `Response for ${request.method} ${request.url}`,\r\n    metadata: {\r\n      statusCode: reply.statusCode,\r\n      responseTime: reply.getResponseTime()\r\n    },\r\n    ipAddress: request.ip,\r\n    userAgent: request.headers['user-agent'],\r\n    endpoint: request.url,\r\n    method: request.method,\r\n    statusCode: reply.statusCode,\r\n    responseTime: reply.getResponseTime()\r\n  });\r\n});\r\n\r\n// Проверка здоровья сервиса\r\nfastify.get('/health', async (request, reply) => {\r\n  try {\r\n    await prisma.$queryRaw`SELECT 1`;\r\n    return { status: 'ok', service: 'audit', timestamp: new Date().toISOString() };\r\n  } catch (error) {\r\n    reply.code(500);\r\n    return { status: 'error', service: 'audit', error: error.message };\r\n  }\r\n});\r\n\r\n// Запуск cron задач для обработки незавершенных данных\r\ncron.schedule('0 */6 * * *', async () => {\r\n  const incompleteDataService = require('./services/incompleteDataService');\r\n  await incompleteDataService.processIncompleteData();\r\n});\r\n\r\n// Запуск cron задач для очистки старых логов\r\ncron.schedule('0 2 * * 0', async () => {\r\n  const auditService = require('./services/auditService');\r\n  await auditService.cleanupOldLogs();\r\n});\r\n\r\n// Запуск сервера\r\nconst start = async () => {\r\n  try {\r\n    const port = process.env.AUDIT_SERVICE_PORT || 3009;\r\n    await fastify.listen({ port, host: '0.0.0.0' });\r\n    console.log(`🔍 Audit service запущен на порту ${port}`);\r\n  } catch (err) {\r\n    fastify.log.error(err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGTERM', async () => {\r\n  await prisma.$disconnect();\r\n  await fastify.close();\r\n});\r\n\r\nprocess.on('SIGINT', async () => {\r\n  await prisma.$disconnect();\r\n  await fastify.close();\r\n});\r\n\r\nstart();\r\n",
  "services/auth/src/__tests__/auth.test.js": "/**\r\n * VHM24 Auth Service Tests\r\n * Production-ready тесты для аутентификации\r\n */\r\n\r\nconst { test, beforeAll, afterAll, describe } = require('@jest/globals');\r\nconst Fastify = require('fastify');\r\nconst { getAuthClient } = require('@vhm24/database');\r\n\r\n// Мокаем shared пакет для тестов\r\njest.mock('@vhm24/shared', () => ({\r\n  setupCORS: jest.fn(),\r\n  setupHelmet: jest.fn(),\r\n  setupRateLimit: jest.fn(),\r\n  setupJWT: jest.fn(),\r\n  authenticate: jest.fn(),\r\n  authorize: jest.fn(),\r\n  sanitizeInputs: jest.fn(),\r\n  securityLogger: jest.fn(),\r\n  healthCheck: jest.fn(),\r\n  validateBody: jest.fn(),\r\n  validateQuery: jest.fn(),\r\n  validateId: jest.fn(),\r\n  registerErrorHandlers: jest.fn(),\r\n  setupGlobalErrorHandlers: jest.fn(),\r\n  createError: {\r\n    authentication: jest.fn((msg) => new Error(msg)),\r\n    database: jest.fn((msg) => new Error(msg)),\r\n    validation: jest.fn((msg) => new Error(msg))\r\n  },\r\n  asyncHandler: jest.fn((fn) => fn),\r\n  logger: {\r\n    info: jest.fn(),\r\n    error: jest.fn(),\r\n    warn: jest.fn(),\r\n    debug: jest.fn()\r\n  },\r\n  config: {},\r\n  createFastifyConfig: jest.fn(() => ({ logger: false }))\r\n}));\r\n\r\n// Мокаем Prisma клиент\r\nconst mockPrisma = {\r\n  user: {\r\n    findFirst: jest.fn(),\r\n    findUnique: jest.fn(),\r\n    create: jest.fn(),\r\n    update: jest.fn(),\r\n    count: jest.fn()\r\n  },\r\n  auditLog: {\r\n    create: jest.fn()\r\n  },\r\n  $transaction: jest.fn(),\r\n  $disconnect: jest.fn()\r\n};\r\n\r\njest.mock('@vhm24/database', () => ({\r\n  getAuthClient: jest.fn(() => mockPrisma)\r\n}));\r\n\r\n// Мокаем bcrypt\r\njest.mock('bcrypt', () => ({\r\n  hash: jest.fn(() => Promise.resolve('hashedPassword')),\r\n  compare: jest.fn(() => Promise.resolve(true))\r\n}));\r\n\r\ndescribe('Auth Service', () => {\r\n  let app;\r\n  \r\n  beforeAll(async () => {\r\n    // Устанавливаем тестовые переменные окружения\r\n    process.env.NODE_ENV = 'test';\r\n    process.env.JWT_SECRET = 'test-secret-key-for-testing-purposes-only';\r\n    process.env.SERVICE_NAME = 'auth';\r\n    \r\n    // Создаем тестовое приложение\r\n    app = Fastify({ logger: false });\r\n    \r\n    // Регистрируем JWT для тестов\r\n    await app.register(require('@fastify/jwt'), {\r\n      secret: process.env.JWT_SECRET\r\n    });\r\n    \r\n    // Простые тестовые роуты\r\n    app.get('/health', async () => ({ status: 'ok', service: 'auth' }));\r\n    \r\n    app.post('/api/v1/auth/login', async (request, reply) => {\r\n      const { email, password } = request.body;\r\n      \r\n      if (!email || !password) {\r\n        return reply.code(400).send({ error: 'Email and password required' });\r\n      }\r\n      \r\n      // Мокаем поиск пользователя\r\n      const user = await mockPrisma.user.findFirst({\r\n        where: { email: email.toLowerCase() }\r\n      });\r\n      \r\n      if (!user) {\r\n        return reply.code(401).send({ error: 'Invalid credentials' });\r\n      }\r\n      \r\n      const token = app.jwt.sign({\r\n        id: user.id,\r\n        email: user.email,\r\n        roles: user.roles\r\n      });\r\n      \r\n      return {\r\n        success: true,\r\n        token,\r\n        user: {\r\n          id: user.id,\r\n          email: user.email,\r\n          name: user.name,\r\n          roles: user.roles\r\n        }\r\n      };\r\n    });\r\n    \r\n    app.post('/api/v1/auth/register', async (request, reply) => {\r\n      const { email, password, name } = request.body;\r\n      \r\n      if (!email || !password || !name) {\r\n        return reply.code(400).send({ \r\n          error: 'Email, password and name are required' \r\n        });\r\n      }\r\n      \r\n      // Проверяем существующего пользователя\r\n      const existingUser = await mockPrisma.user.findFirst({\r\n        where: { email: email.toLowerCase() }\r\n      });\r\n      \r\n      if (existingUser) {\r\n        return reply.code(400).send({ \r\n          error: 'User already exists' \r\n        });\r\n      }\r\n      \r\n      // Создаем пользователя\r\n      const user = await mockPrisma.user.create({\r\n        data: {\r\n          email: email.toLowerCase(),\r\n          passwordHash: 'hashedPassword',\r\n          name,\r\n          roles: ['OPERATOR']\r\n        }\r\n      });\r\n      \r\n      const token = app.jwt.sign({\r\n        id: user.id,\r\n        email: user.email,\r\n        roles: user.roles\r\n      });\r\n      \r\n      return {\r\n        success: true,\r\n        data: {\r\n          user,\r\n          token\r\n        }\r\n      };\r\n    });\r\n    \r\n    await app.ready();\r\n  });\r\n  \r\n  afterAll(async () => {\r\n    await app.close();\r\n    await mockPrisma.$disconnect();\r\n  });\r\n  \r\n  describe('Health Check', () => {\r\n    test('should return health status', async () => {\r\n      const response = await app.inject({\r\n        method: 'GET',\r\n        url: '/health'\r\n      });\r\n      \r\n      expect(response.statusCode).toBe(200);\r\n      const payload = JSON.parse(response.payload);\r\n      expect(payload.status).toBe('ok');\r\n      expect(payload.service).toBe('auth');\r\n    });\r\n  });\r\n  \r\n  describe('Authentication', () => {\r\n    beforeEach(() => {\r\n      // Сбрасываем моки перед каждым тестом\r\n      jest.clearAllMocks();\r\n    });\r\n    \r\n    test('should login with valid credentials', async () => {\r\n      // Мокаем успешный поиск пользователя\r\n      mockPrisma.user.findFirst.mockResolvedValue({\r\n        id: '1',\r\n        email: 'test@example.com',\r\n        name: 'Test User',\r\n        roles: ['OPERATOR'],\r\n        isActive: true,\r\n        passwordHash: 'hashedPassword'\r\n      });\r\n      \r\n      const response = await app.inject({\r\n        method: 'POST',\r\n        url: '/api/v1/auth/login',\r\n        payload: {\r\n          email: 'test@example.com',\r\n          password: 'password123'\r\n        }\r\n      });\r\n      \r\n      expect(response.statusCode).toBe(200);\r\n      const payload = JSON.parse(response.payload);\r\n      expect(payload.success).toBe(true);\r\n      expect(payload.token).toBeDefined();\r\n      expect(payload.user.email).toBe('test@example.com');\r\n      expect(mockPrisma.user.findFirst).toHaveBeenCalledWith({\r\n        where: { email: 'test@example.com' }\r\n      });\r\n    });\r\n    \r\n    test('should reject login with invalid credentials', async () => {\r\n      // Мокаем отсутствие пользователя\r\n      mockPrisma.user.findFirst.mockResolvedValue(null);\r\n      \r\n      const response = await app.inject({\r\n        method: 'POST',\r\n        url: '/api/v1/auth/login',\r\n        payload: {\r\n          email: 'nonexistent@example.com',\r\n          password: 'wrongpassword'\r\n        }\r\n      });\r\n      \r\n      expect(response.statusCode).toBe(401);\r\n      const payload = JSON.parse(response.payload);\r\n      expect(payload.error).toBe('Invalid credentials');\r\n    });\r\n    \r\n    test('should reject login without email or password', async () => {\r\n      const response = await app.inject({\r\n        method: 'POST',\r\n        url: '/api/v1/auth/login',\r\n        payload: {\r\n          email: 'test@example.com'\r\n          // password отсутствует\r\n        }\r\n      });\r\n      \r\n      expect(response.statusCode).toBe(400);\r\n      const payload = JSON.parse(response.payload);\r\n      expect(payload.error).toBe('Email and password required');\r\n    });\r\n  });\r\n  \r\n  describe('Registration', () => {\r\n    beforeEach(() => {\r\n      jest.clearAllMocks();\r\n    });\r\n    \r\n    test('should register new user successfully', async () => {\r\n      // Мокаем отсутствие существующего пользователя\r\n      mockPrisma.user.findFirst.mockResolvedValue(null);\r\n      \r\n      // Мокаем создание пользователя\r\n      mockPrisma.user.create.mockResolvedValue({\r\n        id: '2',\r\n        email: 'newuser@example.com',\r\n        name: 'New User',\r\n        roles: ['OPERATOR'],\r\n        createdAt: new Date()\r\n      });\r\n      \r\n      const response = await app.inject({\r\n        method: 'POST',\r\n        url: '/api/v1/auth/register',\r\n        payload: {\r\n          email: 'newuser@example.com',\r\n          password: 'password123',\r\n          name: 'New User'\r\n        }\r\n      });\r\n      \r\n      expect(response.statusCode).toBe(200);\r\n      const payload = JSON.parse(response.payload);\r\n      expect(payload.success).toBe(true);\r\n      expect(payload.data.token).toBeDefined();\r\n      expect(payload.data.user.email).toBe('newuser@example.com');\r\n      expect(mockPrisma.user.create).toHaveBeenCalled();\r\n    });\r\n    \r\n    test('should reject registration for existing user', async () => {\r\n      // Мокаем существующего пользователя\r\n      mockPrisma.user.findFirst.mockResolvedValue({\r\n        id: '1',\r\n        email: 'existing@example.com',\r\n        name: 'Existing User'\r\n      });\r\n      \r\n      const response = await app.inject({\r\n        method: 'POST',\r\n        url: '/api/v1/auth/register',\r\n        payload: {\r\n          email: 'existing@example.com',\r\n          password: 'password123',\r\n          name: 'New User'\r\n        }\r\n      });\r\n      \r\n      expect(response.statusCode).toBe(400);\r\n      const payload = JSON.parse(response.payload);\r\n      expect(payload.error).toBe('User already exists');\r\n      expect(mockPrisma.user.create).not.toHaveBeenCalled();\r\n    });\r\n    \r\n    test('should reject registration without required fields', async () => {\r\n      const response = await app.inject({\r\n        method: 'POST',\r\n        url: '/api/v1/auth/register',\r\n        payload: {\r\n          email: 'test@example.com'\r\n          // password и name отсутствуют\r\n        }\r\n      });\r\n      \r\n      expect(response.statusCode).toBe(400);\r\n      const payload = JSON.parse(response.payload);\r\n      expect(payload.error).toBe('Email, password and name are required');\r\n    });\r\n  });\r\n  \r\n  describe('Security', () => {\r\n    test('should normalize email to lowercase', async () => {\r\n      mockPrisma.user.findFirst.mockResolvedValue({\r\n        id: '1',\r\n        email: 'test@example.com',\r\n        name: 'Test User',\r\n        roles: ['OPERATOR'],\r\n        isActive: true\r\n      });\r\n      \r\n      await app.inject({\r\n        method: 'POST',\r\n        url: '/api/v1/auth/login',\r\n        payload: {\r\n          email: 'TEST@EXAMPLE.COM',\r\n          password: 'password123'\r\n        }\r\n      });\r\n      \r\n      expect(mockPrisma.user.findFirst).toHaveBeenCalledWith({\r\n        where: { email: 'test@example.com' }\r\n      });\r\n    });\r\n    \r\n    test('should generate valid JWT token', async () => {\r\n      mockPrisma.user.findFirst.mockResolvedValue({\r\n        id: '1',\r\n        email: 'test@example.com',\r\n        name: 'Test User',\r\n        roles: ['OPERATOR'],\r\n        isActive: true\r\n      });\r\n      \r\n      const response = await app.inject({\r\n        method: 'POST',\r\n        url: '/api/v1/auth/login',\r\n        payload: {\r\n          email: 'test@example.com',\r\n          password: 'password123'\r\n        }\r\n      });\r\n      \r\n      const payload = JSON.parse(response.payload);\r\n      const token = payload.token;\r\n      \r\n      // Проверяем, что токен можно декодировать\r\n      const decoded = app.jwt.verify(token);\r\n      expect(decoded.id).toBe('1');\r\n      expect(decoded.email).toBe('test@example.com');\r\n      expect(decoded.roles).toEqual(['OPERATOR']);\r\n    });\r\n  });\r\n  \r\n  describe('Error Handling', () => {\r\n    test('should handle database errors gracefully', async () => {\r\n      // Мокаем ошибку базы данных\r\n      mockPrisma.user.findFirst.mockRejectedValue(new Error('Database connection failed'));\r\n      \r\n      const response = await app.inject({\r\n        method: 'POST',\r\n        url: '/api/v1/auth/login',\r\n        payload: {\r\n          email: 'test@example.com',\r\n          password: 'password123'\r\n        }\r\n      });\r\n      \r\n      // Должен вернуть 500 ошибку, но не раскрывать детали\r\n      expect(response.statusCode).toBe(500);\r\n    });\r\n  });\r\n});\r\n",
  "services/routes/src/index.js": "/**\r\n * VHM24 Routes Service\r\n * Микросервис для управления маршрутами водителей\r\n */\r\n\r\nconst fastify = require('fastify')({ logger: true });\r\nconst { PrismaClient } = require('@prisma/client');\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// Регистрируем плагины\r\nfastify.register(require('@fastify/cors'), {\r\n  origin: true\r\n});\r\n\r\nfastify.register(require('@fastify/jwt'), {\r\n  secret: process.env.JWT_SECRET || 'your-secret-key'\r\n});\r\n\r\n// Middleware для аутентификации\r\nfastify.decorate('authenticate', async function (request, reply) {\r\n  try {\r\n    await request.jwtVerify();\r\n  } catch (err) {\r\n    reply.send(err);\r\n  }\r\n});\r\n\r\n// Получить маршруты\r\nfastify.get('/routes', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { driverId, status, limit = 10, offset = 0 } = request.query;\r\n    \r\n    const where = {};\r\n    if (driverId) where.driverId = driverId;\r\n    if (status) {\r\n      if (status.includes(',')) {\r\n        where.status = { in: status.split(',') };\r\n      } else {\r\n        where.status = status;\r\n      }\r\n    }\r\n\r\n    const routes = await prisma.route.findMany({\r\n      where,\r\n      include: {\r\n        driver: {\r\n          select: { id: true, name: true, email: true }\r\n        },\r\n        stops: {\r\n          include: {\r\n            machine: {\r\n              select: { id: true, name: true, location: true }\r\n            }\r\n          },\r\n          orderBy: { order: 'asc' }\r\n        }\r\n      },\r\n      orderBy: { createdAt: 'desc' },\r\n      take: parseInt(limit),\r\n      skip: parseInt(offset)\r\n    });\r\n\r\n    // Добавляем вычисляемые поля\r\n    const routesWithStats = routes.map(route => ({\r\n      ...route,\r\n      totalStops: route.stops.length,\r\n      completedStops: route.stops.filter(stop => stop.status === 'COMPLETED').length,\r\n      currentStop: route.stops.find(stop => stop.status === 'ARRIVED') || \r\n                   route.stops.find(stop => stop.status === 'PENDING')\r\n    }));\r\n\r\n    reply.send({\r\n      success: true,\r\n      data: routesWithStats,\r\n      pagination: {\r\n        limit: parseInt(limit),\r\n        offset: parseInt(offset),\r\n        total: await prisma.route.count({ where })\r\n      }\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch routes'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить конкретный маршрут\r\nfastify.get('/routes/:id', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { id } = request.params;\r\n\r\n    const route = await prisma.route.findUnique({\r\n      where: { id },\r\n      include: {\r\n        driver: {\r\n          select: { id: true, name: true, email: true }\r\n        },\r\n        stops: {\r\n          include: {\r\n            machine: {\r\n              select: { id: true, name: true, location: true }\r\n            }\r\n          },\r\n          orderBy: { order: 'asc' }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (!route) {\r\n      return reply.status(404).send({\r\n        success: false,\r\n        error: 'Route not found'\r\n      });\r\n    }\r\n\r\n    // Добавляем статистику\r\n    const routeWithStats = {\r\n      ...route,\r\n      totalStops: route.stops.length,\r\n      completedStops: route.stops.filter(stop => stop.status === 'COMPLETED').length,\r\n      currentStop: route.stops.find(stop => stop.status === 'ARRIVED') || \r\n                   route.stops.find(stop => stop.status === 'PENDING')\r\n    };\r\n\r\n    reply.send({\r\n      success: true,\r\n      data: routeWithStats\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch route'\r\n    });\r\n  }\r\n});\r\n\r\n// Создать новый маршрут\r\nfastify.post('/routes', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { name, description, driverId, plannedDate, stops } = request.body;\r\n\r\n    // Валидация\r\n    if (!name || !driverId || !stops || stops.length === 0) {\r\n      return reply.status(400).send({\r\n        success: false,\r\n        error: 'Name, driverId and stops are required'\r\n      });\r\n    }\r\n\r\n    // Проверяем существование водителя\r\n    const driver = await prisma.user.findUnique({\r\n      where: { id: driverId }\r\n    });\r\n\r\n    if (!driver || !driver.isDriver) {\r\n      return reply.status(400).send({\r\n        success: false,\r\n        error: 'Invalid driver'\r\n      });\r\n    }\r\n\r\n    // Создаем маршрут с остановками\r\n    const route = await prisma.route.create({\r\n      data: {\r\n        name,\r\n        description,\r\n        driverId,\r\n        plannedDate: plannedDate ? new Date(plannedDate) : null,\r\n        status: 'PLANNED',\r\n        stops: {\r\n          create: stops.map((stop, index) => ({\r\n            machineId: stop.machineId,\r\n            order: index + 1,\r\n            status: 'PENDING',\r\n            plannedTime: stop.plannedTime ? new Date(stop.plannedTime) : null,\r\n            description: stop.description\r\n          }))\r\n        }\r\n      },\r\n      include: {\r\n        driver: {\r\n          select: { id: true, name: true, email: true }\r\n        },\r\n        stops: {\r\n          include: {\r\n            machine: {\r\n              select: { id: true, name: true, location: true }\r\n            }\r\n          },\r\n          orderBy: { order: 'asc' }\r\n        }\r\n      }\r\n    });\r\n\r\n    reply.status(201).send({\r\n      success: true,\r\n      data: route\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to create route'\r\n    });\r\n  }\r\n});\r\n\r\n// Обновить маршрут\r\nfastify.patch('/routes/:id', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { id } = request.params;\r\n    const updateData = request.body;\r\n\r\n    // Проверяем существование маршрута\r\n    const existingRoute = await prisma.route.findUnique({\r\n      where: { id }\r\n    });\r\n\r\n    if (!existingRoute) {\r\n      return reply.status(404).send({\r\n        success: false,\r\n        error: 'Route not found'\r\n      });\r\n    }\r\n\r\n    // Обновляем маршрут\r\n    const route = await prisma.route.update({\r\n      where: { id },\r\n      data: {\r\n        ...updateData,\r\n        updatedAt: new Date()\r\n      },\r\n      include: {\r\n        driver: {\r\n          select: { id: true, name: true, email: true }\r\n        },\r\n        stops: {\r\n          include: {\r\n            machine: {\r\n              select: { id: true, name: true, location: true }\r\n            }\r\n          },\r\n          orderBy: { order: 'asc' }\r\n        }\r\n      }\r\n    });\r\n\r\n    reply.send({\r\n      success: true,\r\n      data: route\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to update route'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить остановки маршрута\r\nfastify.get('/route-stops', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { routeId, status, limit = 10, offset = 0 } = request.query;\r\n    \r\n    const where = {};\r\n    if (routeId) where.routeId = routeId;\r\n    if (status) {\r\n      if (status.includes(',')) {\r\n        where.status = { in: status.split(',') };\r\n      } else {\r\n        where.status = status;\r\n      }\r\n    }\r\n\r\n    const stops = await prisma.routeStop.findMany({\r\n      where,\r\n      include: {\r\n        route: {\r\n          select: { id: true, name: true, status: true }\r\n        },\r\n        machine: {\r\n          select: { id: true, name: true, location: true }\r\n        }\r\n      },\r\n      orderBy: [\r\n        { routeId: 'asc' },\r\n        { order: 'asc' }\r\n      ],\r\n      take: parseInt(limit),\r\n      skip: parseInt(offset)\r\n    });\r\n\r\n    reply.send({\r\n      success: true,\r\n      data: stops,\r\n      pagination: {\r\n        limit: parseInt(limit),\r\n        offset: parseInt(offset),\r\n        total: await prisma.routeStop.count({ where })\r\n      }\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch route stops'\r\n    });\r\n  }\r\n});\r\n\r\n// Обновить остановку\r\nfastify.patch('/route-stops/:id', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { id } = request.params;\r\n    const updateData = request.body;\r\n\r\n    // Проверяем существование остановки\r\n    const existingStop = await prisma.routeStop.findUnique({\r\n      where: { id }\r\n    });\r\n\r\n    if (!existingStop) {\r\n      return reply.status(404).send({\r\n        success: false,\r\n        error: 'Route stop not found'\r\n      });\r\n    }\r\n\r\n    // Обновляем остановку\r\n    const stop = await prisma.routeStop.update({\r\n      where: { id },\r\n      data: {\r\n        ...updateData,\r\n        updatedAt: new Date()\r\n      },\r\n      include: {\r\n        route: {\r\n          select: { id: true, name: true, status: true }\r\n        },\r\n        machine: {\r\n          select: { id: true, name: true, location: true }\r\n        }\r\n      }\r\n    });\r\n\r\n    reply.send({\r\n      success: true,\r\n      data: stop\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to update route stop'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить логи водителя\r\nfastify.get('/driver-logs', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { driverId, type, routeId, limit = 50, offset = 0 } = request.query;\r\n    \r\n    const where = {};\r\n    if (driverId) where.driverId = driverId;\r\n    if (type) where.type = type;\r\n    if (routeId) where.routeId = routeId;\r\n\r\n    const logs = await prisma.driverLog.findMany({\r\n      where,\r\n      include: {\r\n        driver: {\r\n          select: { id: true, name: true, email: true }\r\n        },\r\n        route: {\r\n          select: { id: true, name: true }\r\n        }\r\n      },\r\n      orderBy: { createdAt: 'desc' },\r\n      take: parseInt(limit),\r\n      skip: parseInt(offset)\r\n    });\r\n\r\n    reply.send({\r\n      success: true,\r\n      data: logs,\r\n      pagination: {\r\n        limit: parseInt(limit),\r\n        offset: parseInt(offset),\r\n        total: await prisma.driverLog.count({ where })\r\n      }\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch driver logs'\r\n    });\r\n  }\r\n});\r\n\r\n// Создать лог водителя\r\nfastify.post('/driver-logs', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { type, description, driverId, routeId, mileage, latitude, longitude, photos, metadata } = request.body;\r\n\r\n    // Валидация\r\n    if (!type || !description) {\r\n      return reply.status(400).send({\r\n        success: false,\r\n        error: 'Type and description are required'\r\n      });\r\n    }\r\n\r\n    // Если driverId не указан, берем из токена\r\n    const finalDriverId = driverId || request.user.id;\r\n\r\n    const log = await prisma.driverLog.create({\r\n      data: {\r\n        type,\r\n        description,\r\n        driverId: finalDriverId,\r\n        routeId,\r\n        mileage: mileage ? parseFloat(mileage) : null,\r\n        latitude: latitude ? parseFloat(latitude) : null,\r\n        longitude: longitude ? parseFloat(longitude) : null,\r\n        photos: photos || [],\r\n        metadata: metadata || {}\r\n      },\r\n      include: {\r\n        driver: {\r\n          select: { id: true, name: true, email: true }\r\n        },\r\n        route: {\r\n          select: { id: true, name: true }\r\n        }\r\n      }\r\n    });\r\n\r\n    reply.status(201).send({\r\n      success: true,\r\n      data: log\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to create driver log'\r\n    });\r\n  }\r\n});\r\n\r\n// Health check\r\nfastify.get('/health', async (request, reply) => {\r\n  reply.send({ status: 'ok', service: 'routes', timestamp: new Date().toISOString() });\r\n});\r\n\r\n// Запуск сервера\r\nconst start = async () => {\r\n  try {\r\n    const port = process.env.PORT || 3005;\r\n    await fastify.listen({ port, host: '0.0.0.0' });\r\n    fastify.log.info(`Routes service listening on port ${port}`);\r\n  } catch (err) {\r\n    fastify.log.error(err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\nstart();\r\n",
  "services/telegram-bot/src/fsm/states.js": "/**\r\n * VHM24 Telegram Bot FSM States\r\n * Состояния для полного процесса регистрации и работы\r\n */\r\n\r\n// Состояния регистрации\r\nconst REGISTRATION_STATES = {\r\n  WAITING_PHONE: 'registration:waiting_phone',\r\n  WAITING_PASSWORD: 'registration:waiting_password',\r\n  WAITING_ADMIN_APPROVAL: 'registration:waiting_admin_approval',\r\n  COMPLETED: 'registration:completed'\r\n};\r\n\r\n// Состояния для водителей\r\nconst DRIVER_STATES = {\r\n  WAITING_ROUTE_START: 'driver:waiting_route_start',\r\n  WAITING_MILEAGE: 'driver:waiting_mileage',\r\n  WAITING_FUEL_PHOTO: 'driver:waiting_fuel_photo',\r\n  WAITING_ARRIVAL_CONFIRMATION: 'driver:waiting_arrival_confirmation',\r\n  WAITING_GPS_LOCATION: 'driver:waiting_gps_location'\r\n};\r\n\r\n// Состояния для задач\r\nconst TASK_STATES = {\r\n  WAITING_TASK_PHOTO_BEFORE: 'task:waiting_photo_before',\r\n  WAITING_TASK_PHOTO_AFTER: 'task:waiting_photo_after',\r\n  WAITING_TASK_COMMENT: 'task:waiting_comment',\r\n  WAITING_TASK_COMPLETION: 'task:waiting_completion'\r\n};\r\n\r\n// Состояния для склада\r\nconst WAREHOUSE_STATES = {\r\n  WAITING_ITEM_SCAN: 'warehouse:waiting_item_scan',\r\n  WAITING_QUANTITY_INPUT: 'warehouse:waiting_quantity_input',\r\n  WAITING_BUNKER_PHOTO: 'warehouse:waiting_bunker_photo',\r\n  WAITING_WEIGHT_INPUT: 'warehouse:waiting_weight_input'\r\n};\r\n\r\n// Состояния для операторов\r\nconst OPERATOR_STATES = {\r\n  WAITING_MACHINE_SELECTION: 'operator:waiting_machine_selection',\r\n  WAITING_BUNKER_INSTALLATION: 'operator:waiting_bunker_installation',\r\n  WAITING_REMAINS_INPUT: 'operator:waiting_remains_input',\r\n  WAITING_PROBLEM_DESCRIPTION: 'operator:waiting_problem_description'\r\n};\r\n\r\n// Состояния для техников\r\nconst TECHNICIAN_STATES = {\r\n  TECHNICIAN_MENU: 'technician:menu',\r\n  TECHNICIAN_SELECT_MACHINE: 'technician:select_machine',\r\n  TECHNICIAN_MAINTENANCE: 'technician:maintenance',\r\n  TECHNICIAN_CHECKLIST: 'technician:checklist',\r\n  TECHNICIAN_PART_REPLACEMENT: 'technician:part_replacement',\r\n  TECHNICIAN_REPORT_PROBLEM: 'technician:report_problem',\r\n  WAITING_CHECKLIST_ITEM: 'technician:waiting_checklist_item',\r\n  WAITING_PART_REPLACEMENT: 'technician:waiting_part_replacement',\r\n  WAITING_SERVICE_PHOTO: 'technician:waiting_service_photo',\r\n  WAITING_SERVICE_REPORT: 'technician:waiting_service_report'\r\n};\r\n\r\n// Состояния для отчетов\r\nconst REPORT_STATES = {\r\n  WAITING_REPORT_TYPE: 'report:waiting_type',\r\n  WAITING_DATE_RANGE: 'report:waiting_date_range',\r\n  WAITING_MACHINE_FILTER: 'report:waiting_machine_filter'\r\n};\r\n\r\n// Общие состояния\r\nconst COMMON_STATES = {\r\n  IDLE: 'common:idle',\r\n  WAITING_CONFIRMATION: 'common:waiting_confirmation',\r\n  WAITING_ADMIN_ACTION: 'common:waiting_admin_action'\r\n};\r\n\r\n// Все состояния\r\nconst ALL_STATES = {\r\n  ...REGISTRATION_STATES,\r\n  ...DRIVER_STATES,\r\n  ...TASK_STATES,\r\n  ...WAREHOUSE_STATES,\r\n  ...OPERATOR_STATES,\r\n  ...TECHNICIAN_STATES,\r\n  ...REPORT_STATES,\r\n  ...COMMON_STATES\r\n};\r\n\r\n// Функции для проверки состояний\r\nconst isRegistrationState = (state) => {\r\n  return Object.values(REGISTRATION_STATES).includes(state);\r\n};\r\n\r\nconst isDriverState = (state) => {\r\n  return Object.values(DRIVER_STATES).includes(state);\r\n};\r\n\r\nconst isTaskState = (state) => {\r\n  return Object.values(TASK_STATES).includes(state);\r\n};\r\n\r\nconst isWarehouseState = (state) => {\r\n  return Object.values(WAREHOUSE_STATES).includes(state);\r\n};\r\n\r\nconst isOperatorState = (state) => {\r\n  return Object.values(OPERATOR_STATES).includes(state);\r\n};\r\n\r\nconst isTechnicianState = (state) => {\r\n  return Object.values(TECHNICIAN_STATES).includes(state);\r\n};\r\n\r\nconst isReportState = (state) => {\r\n  return Object.values(REPORT_STATES).includes(state);\r\n};\r\n\r\nmodule.exports = {\r\n  REGISTRATION_STATES,\r\n  DRIVER_STATES,\r\n  TASK_STATES,\r\n  WAREHOUSE_STATES,\r\n  OPERATOR_STATES,\r\n  TECHNICIAN_STATES,\r\n  REPORT_STATES,\r\n  COMMON_STATES,\r\n  ALL_STATES,\r\n  isRegistrationState,\r\n  isDriverState,\r\n  isTaskState,\r\n  isWarehouseState,\r\n  isOperatorState,\r\n  isTechnicianState,\r\n  isReportState\r\n};\r\n",
  "services/warehouse/src/index.js": "/**\r\n * VHM24 Warehouse Service\r\n * Микросервис для управления складскими операциями\r\n */\r\n\r\nconst fastify = require('fastify')({ logger: true });\r\nconst { PrismaClient } = require('@prisma/client');\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// Регистрируем плагины\r\nfastify.register(require('@fastify/cors'), {\r\n  origin: true\r\n});\r\n\r\nfastify.register(require('@fastify/jwt'), {\r\n  secret: process.env.JWT_SECRET || 'your-secret-key'\r\n});\r\n\r\n// Middleware для аутентификации\r\nfastify.decorate('authenticate', async function (request, reply) {\r\n  try {\r\n    await request.jwtVerify();\r\n  } catch (err) {\r\n    reply.send(err);\r\n  }\r\n});\r\n\r\n// Получить статистику склада\r\nfastify.get('/warehouse/stats', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n    const tomorrow = new Date(today);\r\n    tomorrow.setDate(tomorrow.getDate() + 1);\r\n\r\n    // Общее количество товаров\r\n    const totalItems = await prisma.inventoryItem.count();\r\n\r\n    // Товары с низкими остатками\r\n    const lowStock = await prisma.inventoryItem.count({\r\n      where: {\r\n        quantity: {\r\n          lte: prisma.inventoryItem.fields.minQuantity\r\n        }\r\n      }\r\n    });\r\n\r\n    // Поступления сегодня\r\n    const todayReceived = await prisma.stockMovement.count({\r\n      where: {\r\n        type: 'IN',\r\n        createdAt: {\r\n          gte: today,\r\n          lt: tomorrow\r\n        }\r\n      }\r\n    });\r\n\r\n    // Отгружено сегодня\r\n    const todayShipped = await prisma.stockMovement.count({\r\n      where: {\r\n        type: 'OUT',\r\n        createdAt: {\r\n          gte: today,\r\n          lt: tomorrow\r\n        }\r\n      }\r\n    });\r\n\r\n    reply.send({\r\n      success: true,\r\n      data: {\r\n        totalItems,\r\n        lowStock,\r\n        todayReceived,\r\n        todayShipped\r\n      }\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch warehouse stats'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить движения товаров\r\nfastify.get('/stock-movements', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { type, itemId, userId, limit = 50, offset = 0 } = request.query;\r\n    \r\n    const where = {};\r\n    if (type) where.type = type;\r\n    if (itemId) where.itemId = itemId;\r\n    if (userId) where.userId = userId;\r\n\r\n    const movements = await prisma.stockMovement.findMany({\r\n      where,\r\n      include: {\r\n        item: {\r\n          select: { id: true, name: true, sku: true, unit: true }\r\n        },\r\n        user: {\r\n          select: { id: true, name: true, email: true }\r\n        }\r\n      },\r\n      orderBy: { createdAt: 'desc' },\r\n      take: parseInt(limit),\r\n      skip: parseInt(offset)\r\n    });\r\n\r\n    reply.send({\r\n      success: true,\r\n      data: movements,\r\n      pagination: {\r\n        limit: parseInt(limit),\r\n        offset: parseInt(offset),\r\n        total: await prisma.stockMovement.count({ where })\r\n      }\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch stock movements'\r\n    });\r\n  }\r\n});\r\n\r\n// Создать движение товара\r\nfastify.post('/stock-movements', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { \r\n      itemId, \r\n      type, \r\n      quantity, \r\n      quantityBefore,\r\n      quantityAfter,\r\n      reason, \r\n      reference, \r\n      machineId,\r\n      metadata \r\n    } = request.body;\r\n\r\n    // Валидация\r\n    if (!itemId || !type || !quantity || !reason) {\r\n      return reply.status(400).send({\r\n        success: false,\r\n        error: 'ItemId, type, quantity and reason are required'\r\n      });\r\n    }\r\n\r\n    // Проверяем существование товара\r\n    const item = await prisma.inventoryItem.findUnique({\r\n      where: { id: itemId }\r\n    });\r\n\r\n    if (!item) {\r\n      return reply.status(404).send({\r\n        success: false,\r\n        error: 'Item not found'\r\n      });\r\n    }\r\n\r\n    // Создаем движение в транзакции\r\n    const result = await prisma.$transaction(async (tx) => {\r\n      // Создаем запись о движении\r\n      const movement = await tx.stockMovement.create({\r\n        data: {\r\n          itemId,\r\n          type,\r\n          quantity: parseFloat(quantity),\r\n          quantityBefore: quantityBefore ? parseFloat(quantityBefore) : item.quantity,\r\n          quantityAfter: quantityAfter ? parseFloat(quantityAfter) : null,\r\n          reason,\r\n          reference,\r\n          userId: request.user.id,\r\n          machineId,\r\n          metadata: metadata || {}\r\n        },\r\n        include: {\r\n          item: {\r\n            select: { id: true, name: true, sku: true, unit: true }\r\n          },\r\n          user: {\r\n            select: { id: true, name: true, email: true }\r\n          }\r\n        }\r\n      });\r\n\r\n      // Обновляем остаток товара\r\n      let newQuantity;\r\n      if (quantityAfter !== undefined) {\r\n        newQuantity = parseFloat(quantityAfter);\r\n      } else {\r\n        newQuantity = type === 'IN' \r\n          ? item.quantity + parseFloat(quantity)\r\n          : item.quantity - parseFloat(quantity);\r\n      }\r\n\r\n      await tx.inventoryItem.update({\r\n        where: { id: itemId },\r\n        data: { \r\n          quantity: newQuantity,\r\n          updatedAt: new Date()\r\n        }\r\n      });\r\n\r\n      return { ...movement, newQuantity };\r\n    });\r\n\r\n    reply.status(201).send({\r\n      success: true,\r\n      data: result\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to create stock movement'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить складские логи\r\nfastify.get('/warehouse-logs', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { type, userId, limit = 50, offset = 0 } = request.query;\r\n    \r\n    const where = {};\r\n    if (type) where.type = type;\r\n    if (userId) where.userId = userId;\r\n\r\n    // Используем общую таблицу логов или создаем отдельную для склада\r\n    const logs = await prisma.activityLog.findMany({\r\n      where: {\r\n        ...where,\r\n        category: 'WAREHOUSE'\r\n      },\r\n      include: {\r\n        user: {\r\n          select: { id: true, name: true, email: true }\r\n        }\r\n      },\r\n      orderBy: { createdAt: 'desc' },\r\n      take: parseInt(limit),\r\n      skip: parseInt(offset)\r\n    });\r\n\r\n    reply.send({\r\n      success: true,\r\n      data: logs,\r\n      pagination: {\r\n        limit: parseInt(limit),\r\n        offset: parseInt(offset),\r\n        total: await prisma.activityLog.count({ \r\n          where: { ...where, category: 'WAREHOUSE' } \r\n        })\r\n      }\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch warehouse logs'\r\n    });\r\n  }\r\n});\r\n\r\n// Создать складской лог\r\nfastify.post('/warehouse-logs', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { type, description, weight, photos, metadata } = request.body;\r\n\r\n    // Валидация\r\n    if (!type || !description) {\r\n      return reply.status(400).send({\r\n        success: false,\r\n        error: 'Type and description are required'\r\n      });\r\n    }\r\n\r\n    const log = await prisma.activityLog.create({\r\n      data: {\r\n        category: 'WAREHOUSE',\r\n        type,\r\n        description,\r\n        userId: request.user.id,\r\n        metadata: {\r\n          ...metadata,\r\n          weight: weight ? parseFloat(weight) : null,\r\n          photos: photos || []\r\n        }\r\n      },\r\n      include: {\r\n        user: {\r\n          select: { id: true, name: true, email: true }\r\n        }\r\n      }\r\n    });\r\n\r\n    reply.status(201).send({\r\n      success: true,\r\n      data: log\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to create warehouse log'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить товары для заполнения бункеров\r\nfastify.get('/machine-inventory', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { machineId, needsRefill, limit = 20, offset = 0 } = request.query;\r\n    \r\n    const where = {};\r\n    if (machineId) where.machineId = machineId;\r\n    if (needsRefill === 'true') {\r\n      where.quantity = {\r\n        lte: 10 // Считаем что нужна дозаправка если меньше 10 единиц\r\n      };\r\n    }\r\n\r\n    const inventory = await prisma.machineInventory.findMany({\r\n      where,\r\n      include: {\r\n        machine: {\r\n          select: { id: true, name: true, location: true }\r\n        },\r\n        item: {\r\n          select: { id: true, name: true, sku: true, unit: true }\r\n        }\r\n      },\r\n      orderBy: { updatedAt: 'desc' },\r\n      take: parseInt(limit),\r\n      skip: parseInt(offset)\r\n    });\r\n\r\n    reply.send({\r\n      success: true,\r\n      data: inventory,\r\n      pagination: {\r\n        limit: parseInt(limit),\r\n        offset: parseInt(offset),\r\n        total: await prisma.machineInventory.count({ where })\r\n      }\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch machine inventory'\r\n    });\r\n  }\r\n});\r\n\r\n// Обновить остатки в бункере\r\nfastify.patch('/machine-inventory/:id', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { id } = request.params;\r\n    const { quantity } = request.body;\r\n\r\n    if (quantity === undefined || quantity < 0) {\r\n      return reply.status(400).send({\r\n        success: false,\r\n        error: 'Valid quantity is required'\r\n      });\r\n    }\r\n\r\n    // Проверяем существование записи\r\n    const existing = await prisma.machineInventory.findUnique({\r\n      where: { id },\r\n      include: {\r\n        machine: { select: { id: true, name: true } },\r\n        item: { select: { id: true, name: true, sku: true } }\r\n      }\r\n    });\r\n\r\n    if (!existing) {\r\n      return reply.status(404).send({\r\n        success: false,\r\n        error: 'Machine inventory record not found'\r\n      });\r\n    }\r\n\r\n    // Обновляем количество\r\n    const updated = await prisma.machineInventory.update({\r\n      where: { id },\r\n      data: {\r\n        quantity: parseFloat(quantity),\r\n        updatedAt: new Date()\r\n      },\r\n      include: {\r\n        machine: {\r\n          select: { id: true, name: true, location: true }\r\n        },\r\n        item: {\r\n          select: { id: true, name: true, sku: true, unit: true }\r\n        }\r\n      }\r\n    });\r\n\r\n    // Создаем лог изменения\r\n    await prisma.activityLog.create({\r\n      data: {\r\n        category: 'WAREHOUSE',\r\n        type: 'INVENTORY_UPDATE',\r\n        description: `Обновлены остатки ${existing.item.name} в ${existing.machine.name}: ${existing.quantity} → ${quantity}`,\r\n        userId: request.user.id,\r\n        metadata: {\r\n          machineId: existing.machineId,\r\n          itemId: existing.itemId,\r\n          oldQuantity: existing.quantity,\r\n          newQuantity: parseFloat(quantity)\r\n        }\r\n      }\r\n    });\r\n\r\n    reply.send({\r\n      success: true,\r\n      data: updated\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to update machine inventory'\r\n    });\r\n  }\r\n});\r\n\r\n// Поиск товаров по артикулу/названию\r\nfastify.get('/inventory/items', {\r\n  preHandler: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { sku, name, limit = 20, offset = 0 } = request.query;\r\n    \r\n    const where = {};\r\n    if (sku) {\r\n      where.sku = {\r\n        contains: sku,\r\n        mode: 'insensitive'\r\n      };\r\n    }\r\n    if (name) {\r\n      where.name = {\r\n        contains: name,\r\n        mode: 'insensitive'\r\n      };\r\n    }\r\n\r\n    const items = await prisma.inventoryItem.findMany({\r\n      where,\r\n      orderBy: { name: 'asc' },\r\n      take: parseInt(limit),\r\n      skip: parseInt(offset)\r\n    });\r\n\r\n    reply.send({\r\n      success: true,\r\n      data: items,\r\n      pagination: {\r\n        limit: parseInt(limit),\r\n        offset: parseInt(offset),\r\n        total: await prisma.inventoryItem.count({ where })\r\n      }\r\n    });\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.status(500).send({\r\n      success: false,\r\n      error: 'Failed to search items'\r\n    });\r\n  }\r\n});\r\n\r\n// Health check\r\nfastify.get('/health', async (request, reply) => {\r\n  reply.send({ status: 'ok', service: 'warehouse', timestamp: new Date().toISOString() });\r\n});\r\n\r\n// Запуск сервера\r\nconst start = async () => {\r\n  try {\r\n    const port = process.env.PORT || 3006;\r\n    await fastify.listen({ port, host: '0.0.0.0' });\r\n    fastify.log.info(`Warehouse service listening on port ${port}`);\r\n  } catch (err) {\r\n    fastify.log.error(err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\nstart();\r\n",
  "test-all-services.js": "/**\r\n * VHM24 - Test All Services\r\n * Comprehensive test script for all microservices\r\n */\r\n\r\nconst axios = require('axios');\r\nconst colors = require('colors/safe');\r\n\r\n// Configuration\r\nconst GATEWAY_URL = 'http://localhost:8000';\r\nconst AUTH_URL = 'http://localhost:3001';\r\nconst SERVICES = {\r\n  gateway: { url: GATEWAY_URL, port: 8000 },\r\n  auth: { url: AUTH_URL, port: 3001 },\r\n  machines: { url: 'http://localhost:3002', port: 3002 },\r\n  inventory: { url: 'http://localhost:3003', port: 3003 },\r\n  tasks: { url: 'http://localhost:3004', port: 3004 },\r\n  bunkers: { url: 'http://localhost:3005', port: 3005 }\r\n};\r\n\r\n// Test credentials\r\nconst TEST_USER = {\r\n  email: 'admin@vhm24.ru',\r\n  password: 'admin123'\r\n};\r\n\r\nlet authToken = null;\r\n\r\n// Helper functions\r\nfunction logSuccess(message) {\r\n  console.log(colors.green('✓ ' + message));\r\n}\r\n\r\nfunction logError(message) {\r\n  console.log(colors.red('✗ ' + message));\r\n}\r\n\r\nfunction logInfo(message) {\r\n  console.log(colors.blue('ℹ ' + message));\r\n}\r\n\r\nfunction logSection(title) {\r\n  console.log('\\n' + colors.yellow('═'.repeat(50)));\r\n  console.log(colors.yellow(title));\r\n  console.log(colors.yellow('═'.repeat(50)));\r\n}\r\n\r\n// Test functions\r\nasync function testServiceHealth(name, service) {\r\n  try {\r\n    const response = await axios.get(`${service.url}/health`, { timeout: 5000 });\r\n    if (response.data.status === 'ok') {\r\n      logSuccess(`${name} service is healthy on port ${service.port}`);\r\n      return true;\r\n    } else {\r\n      logError(`${name} service returned unexpected status: ${response.data.status}`);\r\n      return false;\r\n    }\r\n  } catch (error) {\r\n    logError(`${name} service is not responding on port ${service.port}: ${error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function testGatewayHealth() {\r\n  try {\r\n    const response = await axios.get(`${GATEWAY_URL}/health`);\r\n    logSuccess('Gateway is healthy');\r\n    \r\n    // Check individual services through gateway\r\n    if (response.data.services) {\r\n      console.log('\\nService Status through Gateway:');\r\n      Object.entries(response.data.services).forEach(([service, status]) => {\r\n        if (status === 'ok') {\r\n          logSuccess(`  ${service}: ${status}`);\r\n        } else {\r\n          logError(`  ${service}: ${status}`);\r\n        }\r\n      });\r\n    }\r\n    \r\n    // Check database status\r\n    if (response.data.dbStatus) {\r\n      if (response.data.dbStatus === 'connected') {\r\n        logSuccess(`Database: ${response.data.dbStatus}`);\r\n      } else {\r\n        logError(`Database: ${response.data.dbStatus}`);\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    logError(`Gateway health check failed: ${error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function testAuthentication() {\r\n  try {\r\n    // Test login\r\n    const loginResponse = await axios.post(`${GATEWAY_URL}/api/v1/auth/login`, TEST_USER);\r\n    \r\n    if (loginResponse.data.success && loginResponse.data.token) {\r\n      authToken = loginResponse.data.token;\r\n      logSuccess(`Authentication successful for ${TEST_USER.email}`);\r\n      logInfo(`Token received: ${authToken.substring(0, 20)}...`);\r\n      \r\n      // Test /me endpoint\r\n      const meResponse = await axios.get(`${GATEWAY_URL}/api/v1/auth/me`, {\r\n        headers: { Authorization: `Bearer ${authToken}` }\r\n      });\r\n      \r\n      if (meResponse.data.success) {\r\n        logSuccess('Auth /me endpoint working');\r\n        logInfo(`User: ${meResponse.data.data.name} (${meResponse.data.data.email})`);\r\n        logInfo(`Roles: ${meResponse.data.data.roles.join(', ')}`);\r\n      }\r\n      \r\n      return true;\r\n    } else {\r\n      logError('Authentication failed - no token received');\r\n      return false;\r\n    }\r\n  } catch (error) {\r\n    logError(`Authentication test failed: ${error.response?.data?.error || error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function testMachinesAPI() {\r\n  if (!authToken) {\r\n    logError('No auth token - skipping machines API test');\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    const response = await axios.get(`${GATEWAY_URL}/api/v1/machines`, {\r\n      headers: { Authorization: `Bearer ${authToken}` }\r\n    });\r\n    \r\n    if (response.data.success !== undefined) {\r\n      logSuccess('Machines API is accessible');\r\n      logInfo(`Total machines: ${response.data.data?.total || 0}`);\r\n      return true;\r\n    }\r\n  } catch (error) {\r\n    logError(`Machines API test failed: ${error.response?.data?.error || error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function testInventoryAPI() {\r\n  if (!authToken) {\r\n    logError('No auth token - skipping inventory API test');\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    const response = await axios.get(`${GATEWAY_URL}/api/v1/inventory/items`, {\r\n      headers: { Authorization: `Bearer ${authToken}` }\r\n    });\r\n    \r\n    if (response.data.success !== undefined) {\r\n      logSuccess('Inventory API is accessible');\r\n      logInfo(`Total items: ${response.data.data?.total || 0}`);\r\n      return true;\r\n    }\r\n  } catch (error) {\r\n    logError(`Inventory API test failed: ${error.response?.data?.error || error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function testTasksAPI() {\r\n  if (!authToken) {\r\n    logError('No auth token - skipping tasks API test');\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    const response = await axios.get(`${GATEWAY_URL}/api/v1/tasks`, {\r\n      headers: { Authorization: `Bearer ${authToken}` }\r\n    });\r\n    \r\n    if (response.data.success !== undefined) {\r\n      logSuccess('Tasks API is accessible');\r\n      logInfo(`Total tasks: ${response.data.data?.total || 0}`);\r\n      return true;\r\n    }\r\n  } catch (error) {\r\n    logError(`Tasks API test failed: ${error.response?.data?.error || error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function testBunkersAPI() {\r\n  if (!authToken) {\r\n    logError('No auth token - skipping bunkers API test');\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    const response = await axios.get(`${GATEWAY_URL}/api/v1/bunkers`, {\r\n      headers: { Authorization: `Bearer ${authToken}` }\r\n    });\r\n    \r\n    if (response.data.success !== undefined) {\r\n      logSuccess('Bunkers API is accessible');\r\n      logInfo(`Total bunkers: ${response.data.data?.total || 0}`);\r\n      \r\n      // Test critical bunkers endpoint\r\n      const criticalResponse = await axios.get(`${GATEWAY_URL}/api/v1/bunkers/critical`, {\r\n        headers: { Authorization: `Bearer ${authToken}` }\r\n      });\r\n      \r\n      if (criticalResponse.data.success) {\r\n        logSuccess('Critical bunkers endpoint working');\r\n        logInfo(`Critical bunkers: ${criticalResponse.data.data?.totalCritical || 0}`);\r\n      }\r\n      \r\n      return true;\r\n    }\r\n  } catch (error) {\r\n    logError(`Bunkers API test failed: ${error.response?.data?.error || error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function testDashboardStats() {\r\n  if (!authToken) {\r\n    logError('No auth token - skipping dashboard stats test');\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    const response = await axios.get(`${GATEWAY_URL}/api/v1/dashboard/stats`, {\r\n      headers: { Authorization: `Bearer ${authToken}` }\r\n    });\r\n    \r\n    if (response.data.success) {\r\n      logSuccess('Dashboard stats endpoint working');\r\n      const stats = response.data.data;\r\n      console.log('\\nDashboard Statistics:');\r\n      logInfo(`  Total Machines: ${stats.totalMachines}`);\r\n      logInfo(`  Online Machines: ${stats.onlineMachines}`);\r\n      logInfo(`  Total Tasks: ${stats.totalTasks}`);\r\n      logInfo(`  Pending Tasks: ${stats.pendingTasks}`);\r\n      logInfo(`  Total Users: ${stats.totalUsers}`);\r\n      logInfo(`  Active Users: ${stats.activeUsers}`);\r\n      logInfo(`  Inventory Items: ${stats.inventoryItems}`);\r\n      logInfo(`  Low Stock Items: ${stats.lowStockItems}`);\r\n      logInfo(`  Today's Revenue: ${stats.todayRevenue}`);\r\n      return true;\r\n    }\r\n  } catch (error) {\r\n    logError(`Dashboard stats test failed: ${error.response?.data?.error || error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function testWebSocket() {\r\n  // Note: This is a basic test. For full WebSocket testing, consider using a WebSocket client library\r\n  logInfo('WebSocket endpoint available at: ws://localhost:8000/ws');\r\n  logInfo('(WebSocket testing requires a WebSocket client)');\r\n  return true;\r\n}\r\n\r\n// Main test runner\r\nasync function runAllTests() {\r\n  console.log(colors.cyan('\\n🚀 VHM24 Platform - Service Test Suite\\n'));\r\n  \r\n  let totalTests = 0;\r\n  let passedTests = 0;\r\n  \r\n  // Test individual service health\r\n  logSection('Testing Individual Services');\r\n  for (const [name, service] of Object.entries(SERVICES)) {\r\n    totalTests++;\r\n    if (await testServiceHealth(name, service)) {\r\n      passedTests++;\r\n    }\r\n  }\r\n  \r\n  // Test Gateway comprehensive health\r\n  logSection('Testing Gateway Health Check');\r\n  totalTests++;\r\n  if (await testGatewayHealth()) {\r\n    passedTests++;\r\n  }\r\n  \r\n  // Test Authentication\r\n  logSection('Testing Authentication');\r\n  totalTests++;\r\n  if (await testAuthentication()) {\r\n    passedTests++;\r\n  }\r\n  \r\n  // Test API Endpoints\r\n  logSection('Testing API Endpoints');\r\n  \r\n  totalTests++;\r\n  if (await testMachinesAPI()) {\r\n    passedTests++;\r\n  }\r\n  \r\n  totalTests++;\r\n  if (await testInventoryAPI()) {\r\n    passedTests++;\r\n  }\r\n  \r\n  totalTests++;\r\n  if (await testTasksAPI()) {\r\n    passedTests++;\r\n  }\r\n  \r\n  totalTests++;\r\n  if (await testBunkersAPI()) {\r\n    passedTests++;\r\n  }\r\n  \r\n  totalTests++;\r\n  if (await testDashboardStats()) {\r\n    passedTests++;\r\n  }\r\n  \r\n  // Test WebSocket\r\n  logSection('Testing WebSocket');\r\n  totalTests++;\r\n  if (await testWebSocket()) {\r\n    passedTests++;\r\n  }\r\n  \r\n  // Summary\r\n  logSection('Test Summary');\r\n  console.log(`\\nTotal Tests: ${totalTests}`);\r\n  console.log(colors.green(`Passed: ${passedTests}`));\r\n  console.log(colors.red(`Failed: ${totalTests - passedTests}`));\r\n  \r\n  const successRate = (passedTests / totalTests * 100).toFixed(1);\r\n  if (passedTests === totalTests) {\r\n    console.log(colors.green(`\\n✅ All tests passed! (${successRate}%)`));\r\n  } else {\r\n    console.log(colors.yellow(`\\n⚠️  ${successRate}% tests passed`));\r\n  }\r\n  \r\n  // Additional information\r\n  console.log('\\n' + colors.cyan('Additional Information:'));\r\n  logInfo('Default credentials: admin@vhm24.ru / admin123');\r\n  logInfo('API Documentation: http://localhost:8000/docs (if enabled)');\r\n  logInfo('MinIO Console: http://localhost:9001 (minioadmin/minioadmin)');\r\n  logInfo('Database: PostgreSQL on localhost:5432');\r\n  logInfo('Cache: Redis on localhost:6379');\r\n}\r\n\r\n// Run tests\r\nrunAllTests().catch(error => {\r\n  console.error(colors.red('\\n❌ Test suite failed with error:'), error);\r\n  process.exit(1);\r\n});\r\n",
  "test-audit-system.js": "#!/usr/bin/env node\r\n\r\nconst axios = require('axios');\r\nconst { PrismaClient } = require('@prisma/client');\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nconsole.log('🔍 Тестирование системы аудита VHM24...\\n');\r\n\r\nconst AUDIT_SERVICE_URL = process.env.AUDIT_SERVICE_URL || 'http://localhost:3009';\r\nconst TEST_USER_ID = 'test-user-123';\r\nconst TEST_SESSION_ID = 'test-session-456';\r\n\r\nasync function testAuditService() {\r\n  try {\r\n    console.log('📡 Проверка доступности сервиса аудита...');\r\n    \r\n    // Проверка health endpoint\r\n    const healthResponse = await axios.get(`${AUDIT_SERVICE_URL}/health`);\r\n    console.log('✅ Сервис аудита доступен:', healthResponse.data);\r\n\r\n    // Тест логирования действия\r\n    console.log('\\n📝 Тестирование логирования действия...');\r\n    const logResponse = await axios.post(`${AUDIT_SERVICE_URL}/api/audit/log`, {\r\n      userId: TEST_USER_ID,\r\n      sessionId: TEST_SESSION_ID,\r\n      action: 'CREATE',\r\n      entity: 'TEST_ENTITY',\r\n      entityId: 'test-entity-789',\r\n      description: 'Тестовое создание сущности',\r\n      inputData: { name: 'Test Entity', value: 123 },\r\n      ipAddress: '127.0.0.1',\r\n      userAgent: 'Test Agent'\r\n    });\r\n    console.log('✅ Действие залогировано:', logResponse.data);\r\n\r\n    // Тест получения логов\r\n    console.log('\\n📊 Тестирование получения логов...');\r\n    const logsResponse = await axios.get(`${AUDIT_SERVICE_URL}/api/audit/logs?limit=5`);\r\n    console.log('✅ Логи получены:', logsResponse.data.logs.length, 'записей');\r\n\r\n    // Тест статистики активности\r\n    console.log('\\n📈 Тестирование статистики активности...');\r\n    const statsResponse = await axios.get(`${AUDIT_SERVICE_URL}/api/audit/stats/activity`);\r\n    console.log('✅ Статистика получена:', statsResponse.data);\r\n\r\n    // Тест логирования изменений данных\r\n    console.log('\\n🔄 Тестирование логирования изменений данных...');\r\n    const dataChangeResponse = await axios.post(`${AUDIT_SERVICE_URL}/api/audit/log-data-change`, {\r\n      entity: 'TEST_ENTITY',\r\n      entityId: 'test-entity-789',\r\n      oldData: { name: 'Old Name', value: 100 },\r\n      newData: { name: 'New Name', value: 200 },\r\n      action: 'UPDATE'\r\n    }, {\r\n      headers: {\r\n        'x-user-id': TEST_USER_ID\r\n      }\r\n    });\r\n    console.log('✅ Изменения данных залогированы:', dataChangeResponse.data);\r\n\r\n    // Тест незаполненных данных\r\n    console.log('\\n📋 Тестирование незаполненных данных...');\r\n    const incompleteDataResponse = await axios.get(`${AUDIT_SERVICE_URL}/api/incomplete-data/`);\r\n    console.log('✅ Незаполненные данные получены:', incompleteDataResponse.data.data.length, 'записей');\r\n\r\n    // Тест валидации\r\n    console.log('\\n✔️ Тестирование валидации...');\r\n    const validationResponse = await axios.post(`${AUDIT_SERVICE_URL}/api/audit/validate`, {\r\n      entity: 'TEST_ENTITY',\r\n      entityId: 'test-entity-789',\r\n      fieldName: 'email',\r\n      fieldValue: 'test@example.com',\r\n      validationType: 'EMAIL'\r\n    }, {\r\n      headers: {\r\n        'x-user-id': TEST_USER_ID\r\n      }\r\n    });\r\n    console.log('✅ Валидация выполнена:', validationResponse.data);\r\n\r\n    // Тест отчетов\r\n    console.log('\\n📊 Тестирование отчетов...');\r\n    const reportResponse = await axios.get(`${AUDIT_SERVICE_URL}/api/reports/system-activity`);\r\n    console.log('✅ Отчет системной активности получен:', reportResponse.data);\r\n\r\n    console.log('\\n🎉 Все тесты системы аудита прошли успешно!');\r\n\r\n  } catch (error) {\r\n    console.error('❌ Ошибка при тестировании системы аудита:', error.message);\r\n    if (error.response) {\r\n      console.error('Статус:', error.response.status);\r\n      console.error('Данные:', error.response.data);\r\n    }\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nasync function testDatabase() {\r\n  try {\r\n    console.log('\\n🗄️ Тестирование базы данных...');\r\n\r\n    // Проверка подключения к базе данных\r\n    await prisma.$connect();\r\n    console.log('✅ Подключение к базе данных установлено');\r\n\r\n    // Проверка существования таблиц аудита\r\n    const auditLogs = await prisma.systemAuditLog.findMany({\r\n      take: 1\r\n    });\r\n    console.log('✅ Таблица SystemAuditLog доступна');\r\n\r\n    const incompleteLogs = await prisma.incompleteDataLog.findMany({\r\n      take: 1\r\n    });\r\n    console.log('✅ Таблица IncompleteDataLog доступна');\r\n\r\n    const userSessions = await prisma.userSession.findMany({\r\n      take: 1\r\n    });\r\n    console.log('✅ Таблица UserSession доступна');\r\n\r\n    const validationLogs = await prisma.dataValidationLog.findMany({\r\n      take: 1\r\n    });\r\n    console.log('✅ Таблица DataValidationLog доступна');\r\n\r\n    console.log('✅ Все таблицы аудита доступны');\r\n\r\n  } catch (error) {\r\n    console.error('❌ Ошибка при тестировании базы данных:', error.message);\r\n    process.exit(1);\r\n  } finally {\r\n    await prisma.$disconnect();\r\n  }\r\n}\r\n\r\nasync function testMiddleware() {\r\n  try {\r\n    console.log('\\n🔧 Тестирование middleware...');\r\n\r\n    const AuditMiddleware = require('./packages/shared/middleware/auditMiddleware');\r\n    const auditMiddleware = new AuditMiddleware();\r\n\r\n    // Тест генерации ID сессии\r\n    const sessionId = auditMiddleware.generateSessionId();\r\n    console.log('✅ ID сессии сгенерирован:', sessionId);\r\n\r\n    // Тест определения действия из HTTP метода\r\n    const action = auditMiddleware.getActionFromMethod('POST');\r\n    console.log('✅ Действие определено:', action);\r\n\r\n    // Тест определения сущности из URL\r\n    const entity = auditMiddleware.getEntityFromUrl('/api/users/123');\r\n    console.log('✅ Сущность определена:', entity);\r\n\r\n    // Тест валидации ID\r\n    const isValidId = auditMiddleware.isValidId('123');\r\n    console.log('✅ Валидация ID:', isValidId);\r\n\r\n    // Тест очистки чувствительных данных\r\n    const testData = {\r\n      name: 'Test User',\r\n      password: 'secret123',\r\n      email: 'test@example.com'\r\n    };\r\n    const sanitized = auditMiddleware.removeSensitiveFields(testData, ['password']);\r\n    console.log('✅ Данные очищены:', sanitized);\r\n\r\n    console.log('✅ Middleware работает корректно');\r\n\r\n  } catch (error) {\r\n    console.error('❌ Ошибка при тестировании middleware:', error.message);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nasync function runAllTests() {\r\n  console.log('🚀 Запуск полного тестирования системы аудита VHM24\\n');\r\n  \r\n  await testDatabase();\r\n  await testMiddleware();\r\n  await testAuditService();\r\n  \r\n  console.log('\\n🎊 Все тесты завершены успешно!');\r\n  console.log('📋 Система аудита готова к использованию');\r\n  \r\n  process.exit(0);\r\n}\r\n\r\n// Запуск тестов\r\nrunAllTests().catch((error) => {\r\n  console.error('💥 Критическая ошибка при тестировании:', error);\r\n  process.exit(1);\r\n});\r\n",
  "test-complete-system-with-notifications.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Complete System Test with Notifications & Audit\r\n * Комплексное тестирование всей системы включая уведомления и аудит\r\n */\r\n\r\nconst axios = require('axios');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n// Конфигурация тестирования\r\nconst config = {\r\n  baseURL: 'http://localhost:8000/api/v1',\r\n  timeout: 10000,\r\n  testUser: {\r\n    email: 'test@vhm24.com',\r\n    password: 'Test123!',\r\n    name: 'Test User',\r\n    role: 'ADMIN'\r\n  }\r\n};\r\n\r\n// Создаем HTTP клиент\r\nconst api = axios.create({\r\n  baseURL: config.baseURL,\r\n  timeout: config.timeout,\r\n  headers: {\r\n    'Content-Type': 'application/json'\r\n  }\r\n});\r\n\r\nlet authToken = null;\r\n\r\n// Цвета для консоли\r\nconst colors = {\r\n  reset: '\\x1b[0m',\r\n  bright: '\\x1b[1m',\r\n  red: '\\x1b[31m',\r\n  green: '\\x1b[32m',\r\n  yellow: '\\x1b[33m',\r\n  blue: '\\x1b[34m',\r\n  magenta: '\\x1b[35m',\r\n  cyan: '\\x1b[36m'\r\n};\r\n\r\nfunction log(message, color = 'reset') {\r\n  console.log(`${colors[color]}${message}${colors.reset}`);\r\n}\r\n\r\nfunction logSuccess(message) {\r\n  log(`✅ ${message}`, 'green');\r\n}\r\n\r\nfunction logError(message) {\r\n  log(`❌ ${message}`, 'red');\r\n}\r\n\r\nfunction logInfo(message) {\r\n  log(`ℹ️  ${message}`, 'blue');\r\n}\r\n\r\nfunction logWarning(message) {\r\n  log(`⚠️  ${message}`, 'yellow');\r\n}\r\n\r\n// Функция для выполнения HTTP запросов с обработкой ошибок\r\nasync function makeRequest(method, url, data = null, headers = {}) {\r\n  try {\r\n    const requestConfig = {\r\n      method,\r\n      url,\r\n      headers: {\r\n        ...headers,\r\n        ...(authToken && { Authorization: `Bearer ${authToken}` })\r\n      }\r\n    };\r\n\r\n    if (data) {\r\n      requestConfig.data = data;\r\n    }\r\n\r\n    const response = await api(requestConfig);\r\n    return { success: true, data: response.data, status: response.status };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error.response?.data || error.message,\r\n      status: error.response?.status || 500\r\n    };\r\n  }\r\n}\r\n\r\n// Тест аутентификации\r\nasync function testAuthentication() {\r\n  log('\\n🔐 Тестирование аутентификации...', 'cyan');\r\n\r\n  // Попытка входа\r\n  const loginResult = await makeRequest('POST', '/auth/login', {\r\n    email: config.testUser.email,\r\n    password: config.testUser.password\r\n  });\r\n\r\n  if (loginResult.success && loginResult.data.data?.token) {\r\n    authToken = loginResult.data.data.token;\r\n    logSuccess('Аутентификация успешна');\r\n    return true;\r\n  } else {\r\n    logWarning('Пользователь не найден, попытка регистрации...');\r\n    \r\n    // Попытка регистрации\r\n    const registerResult = await makeRequest('POST', '/auth/register', config.testUser);\r\n    \r\n    if (registerResult.success) {\r\n      logSuccess('Регистрация успешна');\r\n      \r\n      // Повторная попытка входа\r\n      const secondLoginResult = await makeRequest('POST', '/auth/login', {\r\n        email: config.testUser.email,\r\n        password: config.testUser.password\r\n      });\r\n      \r\n      if (secondLoginResult.success && secondLoginResult.data.data?.token) {\r\n        authToken = secondLoginResult.data.data.token;\r\n        logSuccess('Вход после регистрации успешен');\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    logError('Не удалось аутентифицироваться');\r\n    return false;\r\n  }\r\n}\r\n\r\n// Тест системы аудита\r\nasync function testAuditSystem() {\r\n  log('\\n🔍 Тестирование системы аудита...', 'cyan');\r\n\r\n  try {\r\n    // Проверяем доступность сервиса аудита\r\n    const healthResult = await makeRequest('GET', '/audit/health');\r\n    if (!healthResult.success) {\r\n      logWarning('Сервис аудита недоступен');\r\n      return false;\r\n    }\r\n    logSuccess('Сервис аудита доступен');\r\n\r\n    // Получаем логи аудита\r\n    const logsResult = await makeRequest('GET', '/audit/logs?limit=10');\r\n    if (logsResult.success) {\r\n      logSuccess(`Получено ${logsResult.data.data?.items?.length || 0} записей аудита`);\r\n    }\r\n\r\n    // Получаем незаполненные данные\r\n    const incompleteResult = await makeRequest('GET', '/audit/incomplete-data?limit=5');\r\n    if (incompleteResult.success) {\r\n      logSuccess(`Найдено ${incompleteResult.data.data?.items?.length || 0} незаполненных записей`);\r\n    }\r\n\r\n    // Получаем отчеты\r\n    const reportsResult = await makeRequest('GET', '/audit/reports/summary');\r\n    if (reportsResult.success) {\r\n      logSuccess('Отчеты аудита получены');\r\n    }\r\n\r\n    return true;\r\n  } catch (error) {\r\n    logError(`Ошибка тестирования аудита: ${error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Тест системы уведомлений\r\nasync function testNotificationSystem() {\r\n  log('\\n🔔 Тестирование системы уведомлений...', 'cyan');\r\n\r\n  try {\r\n    // Проверяем доступность сервиса уведомлений\r\n    const healthResult = await makeRequest('GET', '/notifications/health');\r\n    if (!healthResult.success) {\r\n      logWarning('Сервис уведомлений недоступен');\r\n      return false;\r\n    }\r\n    logSuccess('Сервис уведомлений доступен');\r\n\r\n    // Тестируем отправку уведомления\r\n    const notificationResult = await makeRequest('POST', '/notifications/send', {\r\n      type: 'SYSTEM_ALERT',\r\n      recipients: [config.testUser.email],\r\n      data: {\r\n        alertType: 'TEST_ALERT',\r\n        message: 'Тестовое системное уведомление',\r\n        timestamp: new Date().toISOString()\r\n      }\r\n    });\r\n\r\n    if (notificationResult.success) {\r\n      logSuccess('Уведомление отправлено успешно');\r\n    } else {\r\n      logWarning('Не удалось отправить уведомление');\r\n    }\r\n\r\n    // Получаем статистику уведомлений\r\n    const statsResult = await makeRequest('GET', '/notifications/stats?period=7d');\r\n    if (statsResult.success) {\r\n      logSuccess('Статистика уведомлений получена');\r\n    }\r\n\r\n    // Получаем историю уведомлений\r\n    const historyResult = await makeRequest('GET', '/notifications/history?take=5');\r\n    if (historyResult.success) {\r\n      logSuccess(`История уведомлений: ${historyResult.data.data?.items?.length || 0} записей`);\r\n    }\r\n\r\n    return true;\r\n  } catch (error) {\r\n    logError(`Ошибка тестирования уведомлений: ${error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Тест основных сервисов\r\nasync function testCoreServices() {\r\n  log('\\n🏗️ Тестирование основных сервисов...', 'cyan');\r\n\r\n  const services = [\r\n    { name: 'Machines', endpoint: '/machines' },\r\n    { name: 'Inventory', endpoint: '/inventory' },\r\n    { name: 'Tasks', endpoint: '/tasks' },\r\n    { name: 'Routes', endpoint: '/routes' },\r\n    { name: 'Warehouse', endpoint: '/warehouse' },\r\n    { name: 'Recipes', endpoint: '/recipes' }\r\n  ];\r\n\r\n  let successCount = 0;\r\n\r\n  for (const service of services) {\r\n    const result = await makeRequest('GET', service.endpoint);\r\n    if (result.success) {\r\n      logSuccess(`${service.name} сервис работает`);\r\n      successCount++;\r\n    } else {\r\n      logError(`${service.name} сервис недоступен (${result.status})`);\r\n    }\r\n  }\r\n\r\n  logInfo(`Работающих сервисов: ${successCount}/${services.length}`);\r\n  return successCount === services.length;\r\n}\r\n\r\n// Тест создания и управления данными\r\nasync function testDataOperations() {\r\n  log('\\n📊 Тестирование операций с данными...', 'cyan');\r\n\r\n  try {\r\n    // Создаем тестовую машину\r\n    const machineResult = await makeRequest('POST', '/machines', {\r\n      name: 'Test Machine',\r\n      location: {\r\n        address: 'Test Address',\r\n        latitude: 41.2995,\r\n        longitude: 69.2401\r\n      },\r\n      status: 'ONLINE'\r\n    });\r\n\r\n    let machineId = null;\r\n    if (machineResult.success) {\r\n      machineId = machineResult.data.data?.id;\r\n      logSuccess('Тестовая машина создана');\r\n    }\r\n\r\n    // Создаем тестовую задачу\r\n    const taskResult = await makeRequest('POST', '/tasks', {\r\n      title: 'Test Task',\r\n      description: 'Тестовая задача для проверки системы',\r\n      priority: 'MEDIUM',\r\n      dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\r\n      machineId: machineId\r\n    });\r\n\r\n    let taskId = null;\r\n    if (taskResult.success) {\r\n      taskId = taskResult.data.data?.id;\r\n      logSuccess('Тестовая задача создана');\r\n    }\r\n\r\n    // Создаем тестовый товар\r\n    const inventoryResult = await makeRequest('POST', '/inventory', {\r\n      name: 'Test Item',\r\n      sku: 'TEST-001',\r\n      quantity: 100,\r\n      unit: 'шт',\r\n      minQuantity: 10,\r\n      price: 1000\r\n    });\r\n\r\n    if (inventoryResult.success) {\r\n      logSuccess('Тестовый товар создан');\r\n    }\r\n\r\n    // Обновляем задачу\r\n    if (taskId) {\r\n      const updateResult = await makeRequest('PATCH', `/tasks/${taskId}`, {\r\n        status: 'IN_PROGRESS'\r\n      });\r\n      \r\n      if (updateResult.success) {\r\n        logSuccess('Задача обновлена');\r\n      }\r\n    }\r\n\r\n    return true;\r\n  } catch (error) {\r\n    logError(`Ошибка операций с данными: ${error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Тест интеграции между сервисами\r\nasync function testServiceIntegration() {\r\n  log('\\n🔗 Тестирование интеграции сервисов...', 'cyan');\r\n\r\n  try {\r\n    // Тестируем создание маршрута с остановками\r\n    const routeResult = await makeRequest('POST', '/routes', {\r\n      name: 'Test Route',\r\n      description: 'Тестовый маршрут',\r\n      status: 'PLANNED'\r\n    });\r\n\r\n    if (routeResult.success) {\r\n      logSuccess('Маршрут создан');\r\n      \r\n      // Получаем список машин для маршрута\r\n      const machinesResult = await makeRequest('GET', '/machines?limit=3');\r\n      if (machinesResult.success && machinesResult.data.data?.length > 0) {\r\n        logSuccess('Машины для маршрута получены');\r\n      }\r\n    }\r\n\r\n    // Тестируем создание рецепта\r\n    const recipeResult = await makeRequest('POST', '/recipes', {\r\n      name: 'Test Recipe',\r\n      description: 'Тестовый рецепт',\r\n      ingredients: [\r\n        { name: 'Ingredient 1', quantity: 100, unit: 'г' },\r\n        { name: 'Ingredient 2', quantity: 50, unit: 'мл' }\r\n      ],\r\n      instructions: 'Тестовые инструкции'\r\n    });\r\n\r\n    if (recipeResult.success) {\r\n      logSuccess('Рецепт создан');\r\n    }\r\n\r\n    return true;\r\n  } catch (error) {\r\n    logError(`Ошибка интеграции сервисов: ${error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Тест производительности\r\nasync function testPerformance() {\r\n  log('\\n⚡ Тестирование производительности...', 'cyan');\r\n\r\n  const tests = [\r\n    { name: 'Health Check', endpoint: '/health' },\r\n    { name: 'Machines List', endpoint: '/machines?limit=10' },\r\n    { name: 'Tasks List', endpoint: '/tasks?limit=10' },\r\n    { name: 'Audit Logs', endpoint: '/audit/logs?limit=10' }\r\n  ];\r\n\r\n  for (const test of tests) {\r\n    const startTime = Date.now();\r\n    const result = await makeRequest('GET', test.endpoint);\r\n    const endTime = Date.now();\r\n    const duration = endTime - startTime;\r\n\r\n    if (result.success) {\r\n      if (duration < 1000) {\r\n        logSuccess(`${test.name}: ${duration}ms ✨`);\r\n      } else if (duration < 3000) {\r\n        logWarning(`${test.name}: ${duration}ms ⚠️`);\r\n      } else {\r\n        logError(`${test.name}: ${duration}ms 🐌`);\r\n      }\r\n    } else {\r\n      logError(`${test.name}: FAILED`);\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// Генерация отчета\r\nasync function generateReport(results) {\r\n  log('\\n📋 Генерация отчета...', 'cyan');\r\n\r\n  const report = {\r\n    timestamp: new Date().toISOString(),\r\n    summary: {\r\n      total: Object.keys(results).length,\r\n      passed: Object.values(results).filter(r => r).length,\r\n      failed: Object.values(results).filter(r => !r).length\r\n    },\r\n    details: results,\r\n    recommendations: []\r\n  };\r\n\r\n  // Добавляем рекомендации\r\n  if (!results.authentication) {\r\n    report.recommendations.push('Настройте аутентификацию и создайте тестового пользователя');\r\n  }\r\n  if (!results.auditSystem) {\r\n    report.recommendations.push('Запустите сервис аудита для полного функционала');\r\n  }\r\n  if (!results.notificationSystem) {\r\n    report.recommendations.push('Настройте сервис уведомлений для алертов');\r\n  }\r\n  if (!results.coreServices) {\r\n    report.recommendations.push('Проверьте запуск всех основных сервисов');\r\n  }\r\n\r\n  // Сохраняем отчет\r\n  const reportPath = path.join(__dirname, 'test-report.json');\r\n  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));\r\n\r\n  log('\\n📊 РЕЗУЛЬТАТЫ ТЕСТИРОВАНИЯ:', 'bright');\r\n  log(`✅ Пройдено: ${report.summary.passed}`, 'green');\r\n  log(`❌ Провалено: ${report.summary.failed}`, 'red');\r\n  log(`📈 Успешность: ${Math.round((report.summary.passed / report.summary.total) * 100)}%`, 'blue');\r\n  \r\n  if (report.recommendations.length > 0) {\r\n    log('\\n💡 Рекомендации:', 'yellow');\r\n    report.recommendations.forEach(rec => log(`   • ${rec}`, 'yellow'));\r\n  }\r\n\r\n  log(`\\n📄 Подробный отчет сохранен: ${reportPath}`, 'cyan');\r\n\r\n  return report;\r\n}\r\n\r\n// Основная функция тестирования\r\nasync function runTests() {\r\n  log('🚀 Запуск комплексного тестирования VHM24...', 'bright');\r\n  log(`🌐 Базовый URL: ${config.baseURL}`, 'blue');\r\n\r\n  const results = {};\r\n\r\n  try {\r\n    // Выполняем тесты последовательно\r\n    results.authentication = await testAuthentication();\r\n    results.auditSystem = await testAuditSystem();\r\n    results.notificationSystem = await testNotificationSystem();\r\n    results.coreServices = await testCoreServices();\r\n    results.dataOperations = await testDataOperations();\r\n    results.serviceIntegration = await testServiceIntegration();\r\n    results.performance = await testPerformance();\r\n\r\n    // Генерируем отчет\r\n    const report = await generateReport(results);\r\n\r\n    // Определяем общий результат\r\n    const overallSuccess = Object.values(results).every(result => result === true);\r\n    \r\n    if (overallSuccess) {\r\n      log('\\n🎉 ВСЕ ТЕСТЫ ПРОЙДЕНЫ УСПЕШНО!', 'green');\r\n      process.exit(0);\r\n    } else {\r\n      log('\\n⚠️  НЕКОТОРЫЕ ТЕСТЫ НЕ ПРОЙДЕНЫ', 'yellow');\r\n      process.exit(1);\r\n    }\r\n\r\n  } catch (error) {\r\n    logError(`Критическая ошибка тестирования: ${error.message}`);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Обработка сигналов завершения\r\nprocess.on('SIGINT', () => {\r\n  log('\\n👋 Тестирование прервано пользователем', 'yellow');\r\n  process.exit(1);\r\n});\r\n\r\nprocess.on('unhandledRejection', (reason, promise) => {\r\n  logError(`Необработанная ошибка: ${reason}`);\r\n  process.exit(1);\r\n});\r\n\r\n// Запуск тестов\r\nif (require.main === module) {\r\n  runTests();\r\n}\r\n\r\nmodule.exports = {\r\n  runTests,\r\n  testAuthentication,\r\n  testAuditSystem,\r\n  testNotificationSystem,\r\n  testCoreServices,\r\n  testDataOperations,\r\n  testServiceIntegration,\r\n  testPerformance\r\n};\r\n",
  "test-complete-system-with-recipes.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Complete System Test with Recipes API\r\n * Комплексное тестирование системы включая новый Recipes API\r\n */\r\n\r\nconst axios = require('axios');\r\nconst fs = require('fs');\r\n\r\n// Конфигурация\r\nconst config = {\r\n  gateway: 'http://localhost:3000',\r\n  services: {\r\n    auth: 'http://localhost:3001',\r\n    machines: 'http://localhost:3002',\r\n    inventory: 'http://localhost:3003',\r\n    tasks: 'http://localhost:3004',\r\n    routes: 'http://localhost:3005',\r\n    warehouse: 'http://localhost:3006',\r\n    recipes: 'http://localhost:3007',\r\n    notifications: 'http://localhost:3008',\r\n    monitoring: 'http://localhost:3009',\r\n    backup: 'http://localhost:3010'\r\n  },\r\n  dashboard: 'http://localhost:3001'\r\n};\r\n\r\n// Тестовые данные\r\nconst testData = {\r\n  user: {\r\n    telegramId: '123456789',\r\n    username: 'test_user',\r\n    firstName: 'Test',\r\n    lastName: 'User',\r\n    email: 'test@vhm24.uz',\r\n    password: 'test123456',\r\n    roles: ['MANAGER']\r\n  },\r\n  recipe: {\r\n    name: 'Тестовый кофе',\r\n    description: 'Простой рецепт кофе для автомата',\r\n    category: 'Напитки',\r\n    preparationTime: 2,\r\n    servings: 1,\r\n    instructions: 'Смешать ингредиенты и подать горячим',\r\n    ingredients: [\r\n      { ingredientId: 1, quantity: 15, unit: 'г' },\r\n      { ingredientId: 2, quantity: 200, unit: 'мл' }\r\n    ]\r\n  },\r\n  ingredient: {\r\n    name: 'Кофе молотый',\r\n    category: 'Напитки',\r\n    unit: 'г',\r\n    costPerUnit: 2.5,\r\n    supplier: 'Coffee Supply Co',\r\n    description: 'Высококачественный молотый кофе'\r\n  }\r\n};\r\n\r\nlet authToken = null;\r\nlet testResults = {\r\n  passed: 0,\r\n  failed: 0,\r\n  tests: []\r\n};\r\n\r\n// Утилиты\r\nfunction log(message, type = 'info') {\r\n  const timestamp = new Date().toISOString();\r\n  const colors = {\r\n    info: '\\x1b[36m',\r\n    success: '\\x1b[32m',\r\n    error: '\\x1b[31m',\r\n    warning: '\\x1b[33m',\r\n    reset: '\\x1b[0m'\r\n  };\r\n  \r\n  console.log(`${colors[type]}[${timestamp}] ${message}${colors.reset}`);\r\n}\r\n\r\nfunction addTestResult(name, passed, message = '') {\r\n  testResults.tests.push({ name, passed, message });\r\n  if (passed) {\r\n    testResults.passed++;\r\n    log(`✅ ${name}`, 'success');\r\n  } else {\r\n    testResults.failed++;\r\n    log(`❌ ${name}: ${message}`, 'error');\r\n  }\r\n}\r\n\r\nasync function makeRequest(url, options = {}) {\r\n  try {\r\n    const response = await axios({\r\n      url,\r\n      timeout: 10000,\r\n      ...options,\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        ...(authToken && { 'Authorization': `Bearer ${authToken}` }),\r\n        ...options.headers\r\n      }\r\n    });\r\n    return { success: true, data: response.data, status: response.status };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error.message,\r\n      status: error.response?.status,\r\n      data: error.response?.data\r\n    };\r\n  }\r\n}\r\n\r\n// Тесты сервисов\r\nasync function testServiceHealth(serviceName, url) {\r\n  log(`Тестирование здоровья сервиса: ${serviceName}`);\r\n  \r\n  const result = await makeRequest(`${url}/health`);\r\n  \r\n  if (result.success && result.status === 200) {\r\n    addTestResult(`${serviceName} Health Check`, true);\r\n    return true;\r\n  } else {\r\n    addTestResult(`${serviceName} Health Check`, false, result.error || 'Service unavailable');\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function testAuthService() {\r\n  log('Тестирование Auth Service...');\r\n  \r\n  // Регистрация пользователя\r\n  const registerResult = await makeRequest(`${config.services.auth}/api/v1/auth/register`, {\r\n    method: 'POST',\r\n    data: testData.user\r\n  });\r\n  \r\n  if (registerResult.success) {\r\n    addTestResult('User Registration', true);\r\n  } else {\r\n    addTestResult('User Registration', false, registerResult.error);\r\n  }\r\n  \r\n  // Вход в систему\r\n  const loginResult = await makeRequest(`${config.services.auth}/api/v1/auth/login`, {\r\n    method: 'POST',\r\n    data: {\r\n      telegramId: testData.user.telegramId,\r\n      password: testData.user.password\r\n    }\r\n  });\r\n  \r\n  if (loginResult.success && loginResult.data.token) {\r\n    authToken = loginResult.data.token;\r\n    addTestResult('User Login', true);\r\n    return true;\r\n  } else {\r\n    addTestResult('User Login', false, loginResult.error);\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function testRecipesService() {\r\n  log('Тестирование Recipes Service...');\r\n  \r\n  // Создание ингредиента\r\n  const ingredientResult = await makeRequest(`${config.services.recipes}/api/v1/ingredients`, {\r\n    method: 'POST',\r\n    data: testData.ingredient\r\n  });\r\n  \r\n  if (ingredientResult.success) {\r\n    addTestResult('Create Ingredient', true);\r\n    \r\n    // Обновляем ID ингредиента в тестовых данных\r\n    testData.recipe.ingredients[0].ingredientId = ingredientResult.data.data.id;\r\n  } else {\r\n    addTestResult('Create Ingredient', false, ingredientResult.error);\r\n  }\r\n  \r\n  // Создание второго ингредиента (вода)\r\n  const waterIngredient = {\r\n    name: 'Вода',\r\n    category: 'Напитки',\r\n    unit: 'мл',\r\n    costPerUnit: 0.01,\r\n    supplier: 'Water Supply',\r\n    description: 'Очищенная вода'\r\n  };\r\n  \r\n  const waterResult = await makeRequest(`${config.services.recipes}/api/v1/ingredients`, {\r\n    method: 'POST',\r\n    data: waterIngredient\r\n  });\r\n  \r\n  if (waterResult.success) {\r\n    testData.recipe.ingredients[1].ingredientId = waterResult.data.data.id;\r\n  }\r\n  \r\n  // Получение списка ингредиентов\r\n  const ingredientsListResult = await makeRequest(`${config.services.recipes}/api/v1/ingredients`);\r\n  \r\n  if (ingredientsListResult.success && Array.isArray(ingredientsListResult.data.data)) {\r\n    addTestResult('Get Ingredients List', true);\r\n  } else {\r\n    addTestResult('Get Ingredients List', false, ingredientsListResult.error);\r\n  }\r\n  \r\n  // Создание рецепта\r\n  const recipeResult = await makeRequest(`${config.services.recipes}/api/v1/recipes`, {\r\n    method: 'POST',\r\n    data: testData.recipe\r\n  });\r\n  \r\n  if (recipeResult.success) {\r\n    addTestResult('Create Recipe', true);\r\n    \r\n    const recipeId = recipeResult.data.data.id;\r\n    \r\n    // Получение рецепта по ID\r\n    const getRecipeResult = await makeRequest(`${config.services.recipes}/api/v1/recipes/${recipeId}`);\r\n    \r\n    if (getRecipeResult.success) {\r\n      addTestResult('Get Recipe by ID', true);\r\n    } else {\r\n      addTestResult('Get Recipe by ID', false, getRecipeResult.error);\r\n    }\r\n    \r\n    // Обновление рецепта\r\n    const updateData = {\r\n      name: 'Обновлённый тестовый кофе',\r\n      description: 'Обновлённое описание рецепта'\r\n    };\r\n    \r\n    const updateResult = await makeRequest(`${config.services.recipes}/api/v1/recipes/${recipeId}`, {\r\n      method: 'PUT',\r\n      data: updateData\r\n    });\r\n    \r\n    if (updateResult.success) {\r\n      addTestResult('Update Recipe', true);\r\n    } else {\r\n      addTestResult('Update Recipe', false, updateResult.error);\r\n    }\r\n    \r\n  } else {\r\n    addTestResult('Create Recipe', false, recipeResult.error);\r\n  }\r\n  \r\n  // Получение списка рецептов\r\n  const recipesListResult = await makeRequest(`${config.services.recipes}/api/v1/recipes`);\r\n  \r\n  if (recipesListResult.success && Array.isArray(recipesListResult.data.data)) {\r\n    addTestResult('Get Recipes List', true);\r\n  } else {\r\n    addTestResult('Get Recipes List', false, recipesListResult.error);\r\n  }\r\n  \r\n  // Поиск рецептов\r\n  const searchResult = await makeRequest(`${config.services.recipes}/api/v1/recipes?search=кофе`);\r\n  \r\n  if (searchResult.success) {\r\n    addTestResult('Search Recipes', true);\r\n  } else {\r\n    addTestResult('Search Recipes', false, searchResult.error);\r\n  }\r\n  \r\n  // Фильтрация по категории\r\n  const filterResult = await makeRequest(`${config.services.recipes}/api/v1/recipes?category=Напитки`);\r\n  \r\n  if (filterResult.success) {\r\n    addTestResult('Filter Recipes by Category', true);\r\n  } else {\r\n    addTestResult('Filter Recipes by Category', false, filterResult.error);\r\n  }\r\n  \r\n  // Расчёт себестоимости\r\n  const costCalculationData = {\r\n    ingredients: testData.recipe.ingredients,\r\n    servings: 1,\r\n    markup: 20\r\n  };\r\n  \r\n  const costResult = await makeRequest(`${config.services.recipes}/api/v1/cost-calculation`, {\r\n    method: 'POST',\r\n    data: costCalculationData\r\n  });\r\n  \r\n  if (costResult.success && costResult.data.data.totalCost !== undefined) {\r\n    addTestResult('Cost Calculation', true);\r\n  } else {\r\n    addTestResult('Cost Calculation', false, costResult.error);\r\n  }\r\n  \r\n  // Получение категорий рецептов\r\n  const categoriesResult = await makeRequest(`${config.services.recipes}/api/v1/recipe-categories`);\r\n  \r\n  if (categoriesResult.success && Array.isArray(categoriesResult.data.data)) {\r\n    addTestResult('Get Recipe Categories', true);\r\n  } else {\r\n    addTestResult('Get Recipe Categories', false, categoriesResult.error);\r\n  }\r\n}\r\n\r\nasync function testMachinesService() {\r\n  log('Тестирование Machines Service...');\r\n  \r\n  const result = await makeRequest(`${config.services.machines}/api/v1/machines`);\r\n  \r\n  if (result.success) {\r\n    addTestResult('Get Machines List', true);\r\n  } else {\r\n    addTestResult('Get Machines List', false, result.error);\r\n  }\r\n}\r\n\r\nasync function testInventoryService() {\r\n  log('Тестирование Inventory Service...');\r\n  \r\n  const result = await makeRequest(`${config.services.inventory}/api/v1/inventory`);\r\n  \r\n  if (result.success) {\r\n    addTestResult('Get Inventory List', true);\r\n  } else {\r\n    addTestResult('Get Inventory List', false, result.error);\r\n  }\r\n}\r\n\r\nasync function testTasksService() {\r\n  log('Тестирование Tasks Service...');\r\n  \r\n  const result = await makeRequest(`${config.services.tasks}/api/v1/tasks`);\r\n  \r\n  if (result.success) {\r\n    addTestResult('Get Tasks List', true);\r\n  } else {\r\n    addTestResult('Get Tasks List', false, result.error);\r\n  }\r\n}\r\n\r\nasync function testRoutesService() {\r\n  log('Тестирование Routes Service...');\r\n  \r\n  const result = await makeRequest(`${config.services.routes}/api/v1/routes`);\r\n  \r\n  if (result.success) {\r\n    addTestResult('Get Routes List', true);\r\n  } else {\r\n    addTestResult('Get Routes List', false, result.error);\r\n  }\r\n}\r\n\r\nasync function testWarehouseService() {\r\n  log('Тестирование Warehouse Service...');\r\n  \r\n  const result = await makeRequest(`${config.services.warehouse}/api/v1/warehouse`);\r\n  \r\n  if (result.success) {\r\n    addTestResult('Get Warehouse Data', true);\r\n  } else {\r\n    addTestResult('Get Warehouse Data', false, result.error);\r\n  }\r\n}\r\n\r\nasync function testNotificationsService() {\r\n  log('Тестирование Notifications Service...');\r\n  \r\n  const result = await makeRequest(`${config.services.notifications}/api/v1/notifications`);\r\n  \r\n  if (result.success) {\r\n    addTestResult('Get Notifications', true);\r\n  } else {\r\n    addTestResult('Get Notifications', false, result.error);\r\n  }\r\n}\r\n\r\nasync function testMonitoringService() {\r\n  log('Тестирование Monitoring Service...');\r\n  \r\n  const result = await makeRequest(`${config.services.monitoring}/api/v1/monitoring/status`);\r\n  \r\n  if (result.success) {\r\n    addTestResult('Get Monitoring Status', true);\r\n  } else {\r\n    addTestResult('Get Monitoring Status', false, result.error);\r\n  }\r\n}\r\n\r\nasync function testBackupService() {\r\n  log('Тестирование Backup Service...');\r\n  \r\n  const result = await makeRequest(`${config.services.backup}/api/v1/backup/status`);\r\n  \r\n  if (result.success) {\r\n    addTestResult('Get Backup Status', true);\r\n  } else {\r\n    addTestResult('Get Backup Status', false, result.error);\r\n  }\r\n}\r\n\r\nasync function testGatewayIntegration() {\r\n  log('Тестирование Gateway Integration...');\r\n  \r\n  // Тест роутинга через gateway\r\n  const services = ['auth', 'machines', 'recipes', 'inventory', 'tasks'];\r\n  \r\n  for (const service of services) {\r\n    const result = await makeRequest(`${config.gateway}/api/v1/${service}/health`);\r\n    \r\n    if (result.success) {\r\n      addTestResult(`Gateway ${service} routing`, true);\r\n    } else {\r\n      addTestResult(`Gateway ${service} routing`, false, result.error);\r\n    }\r\n  }\r\n}\r\n\r\nasync function testWebDashboard() {\r\n  log('Тестирование Web Dashboard...');\r\n  \r\n  // Тест доступности dashboard\r\n  const result = await makeRequest(config.dashboard);\r\n  \r\n  if (result.success) {\r\n    addTestResult('Web Dashboard Accessibility', true);\r\n  } else {\r\n    addTestResult('Web Dashboard Accessibility', false, result.error);\r\n  }\r\n}\r\n\r\n// Основная функция тестирования\r\nasync function runCompleteSystemTest() {\r\n  log('🚀 Запуск комплексного тестирования системы VHM24 с Recipes API', 'info');\r\n  log('=' * 80, 'info');\r\n  \r\n  try {\r\n    // Тестирование здоровья всех сервисов\r\n    log('\\n📊 Проверка здоровья сервисов...', 'info');\r\n    for (const [name, url] of Object.entries(config.services)) {\r\n      await testServiceHealth(name, url);\r\n    }\r\n    \r\n    // Тестирование аутентификации\r\n    log('\\n🔐 Тестирование аутентификации...', 'info');\r\n    const authSuccess = await testAuthService();\r\n    \r\n    if (authSuccess) {\r\n      // Тестирование основных сервисов\r\n      log('\\n🔧 Тестирование основных сервисов...', 'info');\r\n      await testMachinesService();\r\n      await testInventoryService();\r\n      await testTasksService();\r\n      await testRoutesService();\r\n      await testWarehouseService();\r\n      \r\n      // Тестирование нового Recipes API\r\n      log('\\n🍳 Тестирование Recipes API...', 'info');\r\n      await testRecipesService();\r\n      \r\n      // Тестирование вспомогательных сервисов\r\n      log('\\n📡 Тестирование вспомогательных сервисов...', 'info');\r\n      await testNotificationsService();\r\n      await testMonitoringService();\r\n      await testBackupService();\r\n      \r\n      // Тестирование интеграции\r\n      log('\\n🌐 Тестирование интеграции...', 'info');\r\n      await testGatewayIntegration();\r\n      await testWebDashboard();\r\n    } else {\r\n      log('❌ Пропуск тестов из-за ошибки аутентификации', 'error');\r\n    }\r\n    \r\n  } catch (error) {\r\n    log(`❌ Критическая ошибка тестирования: ${error.message}`, 'error');\r\n  }\r\n  \r\n  // Генерация отчёта\r\n  generateTestReport();\r\n}\r\n\r\nfunction generateTestReport() {\r\n  log('\\n📋 Генерация отчёта тестирования...', 'info');\r\n  \r\n  const report = {\r\n    timestamp: new Date().toISOString(),\r\n    summary: {\r\n      total: testResults.passed + testResults.failed,\r\n      passed: testResults.passed,\r\n      failed: testResults.failed,\r\n      successRate: Math.round((testResults.passed / (testResults.passed + testResults.failed)) * 100)\r\n    },\r\n    tests: testResults.tests,\r\n    config: config\r\n  };\r\n  \r\n  // Сохранение отчёта\r\n  const reportFile = `test-report-complete-${Date.now()}.json`;\r\n  fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));\r\n  \r\n  // Вывод результатов\r\n  log('\\n' + '=' * 80, 'info');\r\n  log('📊 РЕЗУЛЬТАТЫ КОМПЛЕКСНОГО ТЕСТИРОВАНИЯ', 'info');\r\n  log('=' * 80, 'info');\r\n  log(`✅ Пройдено тестов: ${testResults.passed}`, 'success');\r\n  log(`❌ Провалено тестов: ${testResults.failed}`, 'error');\r\n  log(`📈 Процент успеха: ${report.summary.successRate}%`, 'info');\r\n  log(`📄 Отчёт сохранён: ${reportFile}`, 'info');\r\n  \r\n  if (testResults.failed > 0) {\r\n    log('\\n❌ Провалившиеся тесты:', 'error');\r\n    testResults.tests\r\n      .filter(test => !test.passed)\r\n      .forEach(test => log(`  • ${test.name}: ${test.message}`, 'error'));\r\n  }\r\n  \r\n  log('\\n🎉 Тестирование завершено!', 'success');\r\n  \r\n  // Возврат кода выхода\r\n  process.exit(testResults.failed > 0 ? 1 : 0);\r\n}\r\n\r\n// Запуск тестирования\r\nif (require.main === module) {\r\n  runCompleteSystemTest().catch(error => {\r\n    log(`💥 Фатальная ошибка: ${error.message}`, 'error');\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  runCompleteSystemTest,\r\n  testResults,\r\n  config\r\n};\r\n",
  "test-system-comprehensive.js": "/**\r\n * VHM24 - Comprehensive System Testing\r\n * Полная проверка всех компонентов системы\r\n */\r\n\r\nconst axios = require('axios');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n// Конфигурация тестирования\r\nconst config = {\r\n  baseUrl: process.env.API_URL || 'http://localhost:8000',\r\n  services: {\r\n    gateway: { port: 8000, path: '/health' },\r\n    auth: { port: 3001, path: '/health' },\r\n    machines: { port: 3002, path: '/health' },\r\n    inventory: { port: 3003, path: '/health' },\r\n    tasks: { port: 3004, path: '/health' },\r\n    bunkers: { port: 3005, path: '/health' },\r\n    notifications: { port: 3006, path: '/health' },\r\n    backup: { port: 3007, path: '/health' },\r\n    monitoring: { port: 3008, path: '/health' }\r\n  },\r\n  timeout: 10000,\r\n  retries: 3\r\n};\r\n\r\n// Результаты тестирования\r\nconst results = {\r\n  services: {},\r\n  api: {},\r\n  database: {},\r\n  security: {},\r\n  performance: {},\r\n  integration: {},\r\n  summary: {\r\n    total: 0,\r\n    passed: 0,\r\n    failed: 0,\r\n    warnings: 0\r\n  }\r\n};\r\n\r\n// Утилиты для тестирования\r\nclass TestRunner {\r\n  constructor() {\r\n    this.startTime = Date.now();\r\n  }\r\n\r\n  log(message, type = 'info') {\r\n    const timestamp = new Date().toISOString();\r\n    const colors = {\r\n      info: '\\x1b[36m',\r\n      success: '\\x1b[32m',\r\n      warning: '\\x1b[33m',\r\n      error: '\\x1b[31m',\r\n      reset: '\\x1b[0m'\r\n    };\r\n    \r\n    console.log(`${colors[type]}[${timestamp}] ${message}${colors.reset}`);\r\n  }\r\n\r\n  async sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n\r\n  async retry(fn, retries = config.retries) {\r\n    for (let i = 0; i < retries; i++) {\r\n      try {\r\n        return await fn();\r\n      } catch (error) {\r\n        if (i === retries - 1) throw error;\r\n        await this.sleep(1000 * (i + 1));\r\n      }\r\n    }\r\n  }\r\n\r\n  recordResult(category, test, status, message, data = null) {\r\n    if (!results[category]) results[category] = {};\r\n    \r\n    results[category][test] = {\r\n      status,\r\n      message,\r\n      data,\r\n      timestamp: new Date().toISOString()\r\n    };\r\n\r\n    results.summary.total++;\r\n    if (status === 'passed') results.summary.passed++;\r\n    else if (status === 'failed') results.summary.failed++;\r\n    else if (status === 'warning') results.summary.warnings++;\r\n\r\n    const statusIcon = {\r\n      passed: '✅',\r\n      failed: '❌',\r\n      warning: '⚠️'\r\n    };\r\n\r\n    this.log(`${statusIcon[status]} ${category}/${test}: ${message}`, \r\n             status === 'passed' ? 'success' : status === 'failed' ? 'error' : 'warning');\r\n  }\r\n}\r\n\r\n// Тесты сервисов\r\nclass ServiceTests {\r\n  constructor(runner) {\r\n    this.runner = runner;\r\n  }\r\n\r\n  async testServiceHealth(serviceName, serviceConfig) {\r\n    try {\r\n      const url = `http://localhost:${serviceConfig.port}${serviceConfig.path}`;\r\n      const response = await this.runner.retry(async () => {\r\n        return await axios.get(url, { timeout: config.timeout });\r\n      });\r\n\r\n      if (response.status === 200) {\r\n        this.runner.recordResult('services', serviceName, 'passed', \r\n          `Service is healthy (${response.status})`, response.data);\r\n        return true;\r\n      } else {\r\n        this.runner.recordResult('services', serviceName, 'warning', \r\n          `Service responded with status ${response.status}`, response.data);\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      this.runner.recordResult('services', serviceName, 'failed', \r\n        `Service is not responding: ${error.message}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async testAllServices() {\r\n    this.runner.log('🔍 Testing all services health...', 'info');\r\n    \r\n    const servicePromises = Object.entries(config.services).map(\r\n      ([name, config]) => this.testServiceHealth(name, config)\r\n    );\r\n\r\n    const results = await Promise.all(servicePromises);\r\n    const healthyServices = results.filter(Boolean).length;\r\n    const totalServices = Object.keys(config.services).length;\r\n\r\n    this.runner.log(`Services health: ${healthyServices}/${totalServices} healthy`, \r\n                   healthyServices === totalServices ? 'success' : 'warning');\r\n\r\n    return { healthy: healthyServices, total: totalServices };\r\n  }\r\n}\r\n\r\n// Тесты API\r\nclass ApiTests {\r\n  constructor(runner) {\r\n    this.runner = runner;\r\n    this.authToken = null;\r\n  }\r\n\r\n  async testGatewayEndpoints() {\r\n    const endpoints = [\r\n      { path: '/health', method: 'GET', auth: false },\r\n      { path: '/api/v1/test-db', method: 'GET', auth: false },\r\n      { path: '/api/v1/dashboard/stats', method: 'GET', auth: true },\r\n      { path: '/api/v1/machines', method: 'GET', auth: true },\r\n      { path: '/api/v1/machines/stats', method: 'GET', auth: true }\r\n    ];\r\n\r\n    for (const endpoint of endpoints) {\r\n      await this.testEndpoint(endpoint);\r\n    }\r\n  }\r\n\r\n  async testEndpoint({ path, method, auth }) {\r\n    try {\r\n      const url = `${config.baseUrl}${path}`;\r\n      const headers = {};\r\n      \r\n      if (auth && this.authToken) {\r\n        headers.Authorization = `Bearer ${this.authToken}`;\r\n      }\r\n\r\n      const response = await axios({\r\n        method,\r\n        url,\r\n        headers,\r\n        timeout: config.timeout,\r\n        validateStatus: () => true // Не бросать ошибку на любой статус\r\n      });\r\n\r\n      if (response.status >= 200 && response.status < 300) {\r\n        this.runner.recordResult('api', `${method} ${path}`, 'passed', \r\n          `Endpoint responded successfully (${response.status})`);\r\n      } else if (response.status === 401 && auth) {\r\n        this.runner.recordResult('api', `${method} ${path}`, 'warning', \r\n          `Authentication required (${response.status})`);\r\n      } else {\r\n        this.runner.recordResult('api', `${method} ${path}`, 'failed', \r\n          `Endpoint failed (${response.status}): ${response.data?.error || 'Unknown error'}`);\r\n      }\r\n    } catch (error) {\r\n      this.runner.recordResult('api', `${method} ${path}`, 'failed', \r\n        `Request failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  async testAuthentication() {\r\n    try {\r\n      // Тестируем регистрацию тестового пользователя\r\n      const testUser = {\r\n        email: `test-${Date.now()}@vhm24.test`,\r\n        password: 'TestPassword123!',\r\n        name: 'Test User',\r\n        role: 'OPERATOR'\r\n      };\r\n\r\n      const registerResponse = await axios.post(`${config.baseUrl}/api/v1/auth/register`, testUser, {\r\n        timeout: config.timeout,\r\n        validateStatus: () => true\r\n      });\r\n\r\n      if (registerResponse.status === 201 || registerResponse.status === 409) {\r\n        // 409 означает, что пользователь уже существует - это нормально для тестов\r\n        this.runner.recordResult('api', 'auth_register', 'passed', \r\n          `Registration test completed (${registerResponse.status})`);\r\n\r\n        // Тестируем вход\r\n        const loginResponse = await axios.post(`${config.baseUrl}/api/v1/auth/login`, {\r\n          email: testUser.email,\r\n          password: testUser.password\r\n        }, {\r\n          timeout: config.timeout,\r\n          validateStatus: () => true\r\n        });\r\n\r\n        if (loginResponse.status === 200 && loginResponse.data.data?.token) {\r\n          this.authToken = loginResponse.data.data.token;\r\n          this.runner.recordResult('api', 'auth_login', 'passed', \r\n            'Login successful, token received');\r\n        } else {\r\n          this.runner.recordResult('api', 'auth_login', 'failed', \r\n            `Login failed (${loginResponse.status})`);\r\n        }\r\n      } else {\r\n        this.runner.recordResult('api', 'auth_register', 'failed', \r\n          `Registration failed (${registerResponse.status})`);\r\n      }\r\n    } catch (error) {\r\n      this.runner.recordResult('api', 'auth_test', 'failed', \r\n        `Authentication test failed: ${error.message}`);\r\n    }\r\n  }\r\n}\r\n\r\n// Тесты базы данных\r\nclass DatabaseTests {\r\n  constructor(runner) {\r\n    this.runner = runner;\r\n  }\r\n\r\n  async testDatabaseConnection() {\r\n    try {\r\n      const response = await axios.get(`${config.baseUrl}/api/v1/test-db`, {\r\n        timeout: config.timeout\r\n      });\r\n\r\n      if (response.status === 200 && response.data.success) {\r\n        this.runner.recordResult('database', 'connection', 'passed', \r\n          'Database connection successful', response.data.data);\r\n      } else {\r\n        this.runner.recordResult('database', 'connection', 'failed', \r\n          'Database connection failed', response.data);\r\n      }\r\n    } catch (error) {\r\n      this.runner.recordResult('database', 'connection', 'failed', \r\n        `Database test failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  async testDatabasePerformance() {\r\n    try {\r\n      const startTime = Date.now();\r\n      \r\n      const response = await axios.get(`${config.baseUrl}/api/v1/machines/stats`, {\r\n        timeout: config.timeout\r\n      });\r\n\r\n      const responseTime = Date.now() - startTime;\r\n\r\n      if (response.status === 200) {\r\n        if (responseTime < 1000) {\r\n          this.runner.recordResult('database', 'performance', 'passed', \r\n            `Query performance good (${responseTime}ms)`);\r\n        } else if (responseTime < 3000) {\r\n          this.runner.recordResult('database', 'performance', 'warning', \r\n            `Query performance acceptable (${responseTime}ms)`);\r\n        } else {\r\n          this.runner.recordResult('database', 'performance', 'failed', \r\n            `Query performance poor (${responseTime}ms)`);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.runner.recordResult('database', 'performance', 'failed', \r\n        `Performance test failed: ${error.message}`);\r\n    }\r\n  }\r\n}\r\n\r\n// Тесты безопасности\r\nclass SecurityTests {\r\n  constructor(runner) {\r\n    this.runner = runner;\r\n  }\r\n\r\n  async testSecurityHeaders() {\r\n    try {\r\n      const response = await axios.get(`${config.baseUrl}/health`, {\r\n        timeout: config.timeout\r\n      });\r\n\r\n      const securityHeaders = [\r\n        'x-content-type-options',\r\n        'x-frame-options',\r\n        'x-xss-protection'\r\n      ];\r\n\r\n      let secureHeaders = 0;\r\n      securityHeaders.forEach(header => {\r\n        if (response.headers[header]) {\r\n          secureHeaders++;\r\n        }\r\n      });\r\n\r\n      if (secureHeaders === securityHeaders.length) {\r\n        this.runner.recordResult('security', 'headers', 'passed', \r\n          'All security headers present');\r\n      } else {\r\n        this.runner.recordResult('security', 'headers', 'warning', \r\n          `${secureHeaders}/${securityHeaders.length} security headers present`);\r\n      }\r\n    } catch (error) {\r\n      this.runner.recordResult('security', 'headers', 'failed', \r\n        `Security headers test failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  async testRateLimiting() {\r\n    try {\r\n      const requests = [];\r\n      const endpoint = `${config.baseUrl}/health`;\r\n\r\n      // Отправляем много запросов быстро\r\n      for (let i = 0; i < 20; i++) {\r\n        requests.push(axios.get(endpoint, { \r\n          timeout: config.timeout,\r\n          validateStatus: () => true \r\n        }));\r\n      }\r\n\r\n      const responses = await Promise.all(requests);\r\n      const rateLimited = responses.some(r => r.status === 429);\r\n\r\n      if (rateLimited) {\r\n        this.runner.recordResult('security', 'rate_limiting', 'passed', \r\n          'Rate limiting is working');\r\n      } else {\r\n        this.runner.recordResult('security', 'rate_limiting', 'warning', \r\n          'Rate limiting not detected (may be configured with high limits)');\r\n      }\r\n    } catch (error) {\r\n      this.runner.recordResult('security', 'rate_limiting', 'failed', \r\n        `Rate limiting test failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  async testUnauthorizedAccess() {\r\n    try {\r\n      const protectedEndpoints = [\r\n        '/api/v1/dashboard/stats',\r\n        '/api/v1/machines',\r\n        '/api/v1/audit-log'\r\n      ];\r\n\r\n      let protectedCount = 0;\r\n      \r\n      for (const endpoint of protectedEndpoints) {\r\n        const response = await axios.get(`${config.baseUrl}${endpoint}`, {\r\n          timeout: config.timeout,\r\n          validateStatus: () => true\r\n        });\r\n\r\n        if (response.status === 401 || response.status === 403) {\r\n          protectedCount++;\r\n        }\r\n      }\r\n\r\n      if (protectedCount === protectedEndpoints.length) {\r\n        this.runner.recordResult('security', 'authorization', 'passed', \r\n          'All protected endpoints require authentication');\r\n      } else {\r\n        this.runner.recordResult('security', 'authorization', 'failed', \r\n          `${protectedCount}/${protectedEndpoints.length} endpoints properly protected`);\r\n      }\r\n    } catch (error) {\r\n      this.runner.recordResult('security', 'authorization', 'failed', \r\n        `Authorization test failed: ${error.message}`);\r\n    }\r\n  }\r\n}\r\n\r\n// Тесты производительности\r\nclass PerformanceTests {\r\n  constructor(runner) {\r\n    this.runner = runner;\r\n  }\r\n\r\n  async testResponseTimes() {\r\n    const endpoints = [\r\n      { path: '/health', name: 'health_check' },\r\n      { path: '/api/v1/test-db', name: 'database_test' }\r\n    ];\r\n\r\n    for (const endpoint of endpoints) {\r\n      await this.testEndpointPerformance(endpoint);\r\n    }\r\n  }\r\n\r\n  async testEndpointPerformance({ path, name }) {\r\n    try {\r\n      const measurements = [];\r\n      const iterations = 5;\r\n\r\n      for (let i = 0; i < iterations; i++) {\r\n        const startTime = Date.now();\r\n        \r\n        const response = await axios.get(`${config.baseUrl}${path}`, {\r\n          timeout: config.timeout\r\n        });\r\n\r\n        const responseTime = Date.now() - startTime;\r\n        \r\n        if (response.status === 200) {\r\n          measurements.push(responseTime);\r\n        }\r\n\r\n        await this.runner.sleep(100); // Небольшая пауза между запросами\r\n      }\r\n\r\n      if (measurements.length > 0) {\r\n        const avgTime = measurements.reduce((a, b) => a + b, 0) / measurements.length;\r\n        const maxTime = Math.max(...measurements);\r\n\r\n        if (avgTime < 500) {\r\n          this.runner.recordResult('performance', name, 'passed', \r\n            `Good performance: avg ${avgTime.toFixed(0)}ms, max ${maxTime}ms`);\r\n        } else if (avgTime < 1000) {\r\n          this.runner.recordResult('performance', name, 'warning', \r\n            `Acceptable performance: avg ${avgTime.toFixed(0)}ms, max ${maxTime}ms`);\r\n        } else {\r\n          this.runner.recordResult('performance', name, 'failed', \r\n            `Poor performance: avg ${avgTime.toFixed(0)}ms, max ${maxTime}ms`);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.runner.recordResult('performance', name, 'failed', \r\n        `Performance test failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  async testConcurrentRequests() {\r\n    try {\r\n      const concurrentRequests = 10;\r\n      const endpoint = `${config.baseUrl}/health`;\r\n      \r\n      const startTime = Date.now();\r\n      \r\n      const requests = Array(concurrentRequests).fill().map(() => \r\n        axios.get(endpoint, { timeout: config.timeout })\r\n      );\r\n\r\n      const responses = await Promise.all(requests);\r\n      const totalTime = Date.now() - startTime;\r\n      \r\n      const successfulRequests = responses.filter(r => r.status === 200).length;\r\n\r\n      if (successfulRequests === concurrentRequests && totalTime < 2000) {\r\n        this.runner.recordResult('performance', 'concurrent_requests', 'passed', \r\n          `Handled ${concurrentRequests} concurrent requests in ${totalTime}ms`);\r\n      } else if (successfulRequests === concurrentRequests) {\r\n        this.runner.recordResult('performance', 'concurrent_requests', 'warning', \r\n          `Handled ${concurrentRequests} concurrent requests in ${totalTime}ms (slow)`);\r\n      } else {\r\n        this.runner.recordResult('performance', 'concurrent_requests', 'failed', \r\n          `Only ${successfulRequests}/${concurrentRequests} requests succeeded`);\r\n      }\r\n    } catch (error) {\r\n      this.runner.recordResult('performance', 'concurrent_requests', 'failed', \r\n        `Concurrent requests test failed: ${error.message}`);\r\n    }\r\n  }\r\n}\r\n\r\n// Интеграционные тесты\r\nclass IntegrationTests {\r\n  constructor(runner) {\r\n    this.runner = runner;\r\n  }\r\n\r\n  async testServiceCommunication() {\r\n    try {\r\n      // Тестируем, что gateway может общаться с другими сервисами\r\n      const response = await axios.get(`${config.baseUrl}/api/v1/dashboard/stats`, {\r\n        timeout: config.timeout,\r\n        validateStatus: () => true\r\n      });\r\n\r\n      // Даже если требуется авторизация, сервисы должны отвечать\r\n      if (response.status === 401 || response.status === 200) {\r\n        this.runner.recordResult('integration', 'service_communication', 'passed', \r\n          'Gateway can communicate with backend services');\r\n      } else {\r\n        this.runner.recordResult('integration', 'service_communication', 'failed', \r\n          `Service communication failed (${response.status})`);\r\n      }\r\n    } catch (error) {\r\n      this.runner.recordResult('integration', 'service_communication', 'failed', \r\n        `Service communication test failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  async testWebSocketConnection() {\r\n    // Простая проверка доступности WebSocket endpoint\r\n    try {\r\n      const response = await axios.get(`${config.baseUrl}/health`, {\r\n        timeout: config.timeout\r\n      });\r\n\r\n      if (response.status === 200) {\r\n        this.runner.recordResult('integration', 'websocket_availability', 'passed', \r\n          'WebSocket endpoint should be available (gateway is running)');\r\n      }\r\n    } catch (error) {\r\n      this.runner.recordResult('integration', 'websocket_availability', 'failed', \r\n        'WebSocket endpoint not available');\r\n    }\r\n  }\r\n}\r\n\r\n// Главная функция тестирования\r\nasync function runComprehensiveTests() {\r\n  const runner = new TestRunner();\r\n  \r\n  runner.log('🚀 Starting VHM24 Comprehensive System Tests', 'info');\r\n  runner.log('=' .repeat(60), 'info');\r\n\r\n  // Инициализируем тестовые классы\r\n  const serviceTests = new ServiceTests(runner);\r\n  const apiTests = new ApiTests(runner);\r\n  const databaseTests = new DatabaseTests(runner);\r\n  const securityTests = new SecurityTests(runner);\r\n  const performanceTests = new PerformanceTests(runner);\r\n  const integrationTests = new IntegrationTests(runner);\r\n\r\n  try {\r\n    // 1. Тестируем сервисы\r\n    runner.log('\\n📋 Phase 1: Service Health Tests', 'info');\r\n    await serviceTests.testAllServices();\r\n\r\n    // 2. Тестируем API\r\n    runner.log('\\n🔌 Phase 2: API Tests', 'info');\r\n    await apiTests.testAuthentication();\r\n    await apiTests.testGatewayEndpoints();\r\n\r\n    // 3. Тестируем базу данных\r\n    runner.log('\\n🗄️  Phase 3: Database Tests', 'info');\r\n    await databaseTests.testDatabaseConnection();\r\n    await databaseTests.testDatabasePerformance();\r\n\r\n    // 4. Тестируем безопасность\r\n    runner.log('\\n🛡️  Phase 4: Security Tests', 'info');\r\n    await securityTests.testSecurityHeaders();\r\n    await securityTests.testRateLimiting();\r\n    await securityTests.testUnauthorizedAccess();\r\n\r\n    // 5. Тестируем производительность\r\n    runner.log('\\n⚡ Phase 5: Performance Tests', 'info');\r\n    await performanceTests.testResponseTimes();\r\n    await performanceTests.testConcurrentRequests();\r\n\r\n    // 6. Интеграционные тесты\r\n    runner.log('\\n🔗 Phase 6: Integration Tests', 'info');\r\n    await integrationTests.testServiceCommunication();\r\n    await integrationTests.testWebSocketConnection();\r\n\r\n  } catch (error) {\r\n    runner.log(`❌ Critical error during testing: ${error.message}`, 'error');\r\n  }\r\n\r\n  // Генерируем отчет\r\n  await generateTestReport(runner);\r\n}\r\n\r\nasync function generateTestReport(runner) {\r\n  const totalTime = Date.now() - runner.startTime;\r\n  \r\n  runner.log('\\n📊 Test Results Summary', 'info');\r\n  runner.log('=' .repeat(60), 'info');\r\n  \r\n  const { total, passed, failed, warnings } = results.summary;\r\n  const successRate = total > 0 ? ((passed / total) * 100).toFixed(1) : 0;\r\n  \r\n  runner.log(`Total Tests: ${total}`, 'info');\r\n  runner.log(`✅ Passed: ${passed}`, 'success');\r\n  runner.log(`❌ Failed: ${failed}`, failed > 0 ? 'error' : 'info');\r\n  runner.log(`⚠️  Warnings: ${warnings}`, warnings > 0 ? 'warning' : 'info');\r\n  runner.log(`📈 Success Rate: ${successRate}%`, successRate >= 80 ? 'success' : 'warning');\r\n  runner.log(`⏱️  Total Time: ${(totalTime / 1000).toFixed(1)}s`, 'info');\r\n\r\n  // Сохраняем детальный отчет\r\n  const reportData = {\r\n    summary: {\r\n      ...results.summary,\r\n      successRate: parseFloat(successRate),\r\n      totalTime: totalTime,\r\n      timestamp: new Date().toISOString()\r\n    },\r\n    results: results,\r\n    environment: {\r\n      nodeVersion: process.version,\r\n      platform: process.platform,\r\n      baseUrl: config.baseUrl\r\n    }\r\n  };\r\n\r\n  const reportPath = path.join(__dirname, `test-report-${Date.now()}.json`);\r\n  fs.writeFileSync(reportPath, JSON.stringify(reportData, null, 2));\r\n  \r\n  runner.log(`\\n📄 Detailed report saved to: ${reportPath}`, 'info');\r\n\r\n  // Рекомендации\r\n  runner.log('\\n💡 Recommendations:', 'info');\r\n  \r\n  if (failed > 0) {\r\n    runner.log('• Fix failed tests before deployment', 'warning');\r\n  }\r\n  \r\n  if (warnings > 0) {\r\n    runner.log('• Review warnings for potential improvements', 'warning');\r\n  }\r\n  \r\n  if (successRate >= 95) {\r\n    runner.log('• System is ready for production! 🎉', 'success');\r\n  } else if (successRate >= 80) {\r\n    runner.log('• System is mostly stable, address remaining issues', 'warning');\r\n  } else {\r\n    runner.log('• System needs significant improvements before production', 'error');\r\n  }\r\n\r\n  runner.log('\\n🏁 Testing completed!', 'info');\r\n  \r\n  // Возвращаем код выхода для CI/CD\r\n  process.exit(failed > 0 ? 1 : 0);\r\n}\r\n\r\n// Запускаем тесты\r\nif (require.main === module) {\r\n  runComprehensiveTests().catch(error => {\r\n    console.error('❌ Test runner failed:', error);\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  runComprehensiveTests,\r\n  TestRunner,\r\n  ServiceTests,\r\n  ApiTests,\r\n  DatabaseTests,\r\n  SecurityTests,\r\n  PerformanceTests,\r\n  IntegrationTests\r\n};\r\n",
  "packages/shared/middleware/auditMiddleware.js": "const axios = require('axios');\r\n\r\n/**\r\n * Middleware для автоматического логирования действий пользователей\r\n */\r\nclass AuditMiddleware {\r\n  constructor(auditServiceUrl = process.env.AUDIT_SERVICE_URL || 'http://localhost:3009') {\r\n    this.auditServiceUrl = auditServiceUrl;\r\n  }\r\n\r\n  /**\r\n   * Middleware для Fastify\r\n   */\r\n  fastifyMiddleware() {\r\n    return async (request, reply) => {\r\n      const startTime = Date.now();\r\n      \r\n      // Генерируем уникальный ID сессии если его нет\r\n      if (!request.headers['x-session-id']) {\r\n        request.headers['x-session-id'] = this.generateSessionId();\r\n      }\r\n\r\n      // Логируем запрос\r\n      await this.logRequest(request);\r\n\r\n      // Перехватываем ответ\r\n      reply.addHook('onSend', async (request, reply, payload) => {\r\n        const responseTime = Date.now() - startTime;\r\n        await this.logResponse(request, reply, responseTime);\r\n        return payload;\r\n      });\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Логирование запроса\r\n   */\r\n  async logRequest(request) {\r\n    try {\r\n      const logData = {\r\n        userId: request.user?.id || null,\r\n        sessionId: request.headers['x-session-id'],\r\n        action: this.getActionFromMethod(request.method),\r\n        entity: this.getEntityFromUrl(request.url),\r\n        entityId: this.getEntityIdFromUrl(request.url),\r\n        description: `${request.method} ${request.url}`,\r\n        inputData: this.sanitizeInputData(request),\r\n        ipAddress: request.ip,\r\n        userAgent: request.headers['user-agent'],\r\n        endpoint: request.url,\r\n        method: request.method\r\n      };\r\n\r\n      await this.sendToAuditService('/api/audit/log', logData);\r\n    } catch (error) {\r\n      console.error('Ошибка при логировании запроса:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Логирование ответа\r\n   */\r\n  async logResponse(request, reply, responseTime) {\r\n    try {\r\n      const logData = {\r\n        userId: request.user?.id || null,\r\n        sessionId: request.headers['x-session-id'],\r\n        action: 'INFO',\r\n        entity: 'API_RESPONSE',\r\n        description: `Response for ${request.method} ${request.url}`,\r\n        metadata: {\r\n          statusCode: reply.statusCode,\r\n          responseTime\r\n        },\r\n        ipAddress: request.ip,\r\n        userAgent: request.headers['user-agent'],\r\n        endpoint: request.url,\r\n        method: request.method,\r\n        statusCode: reply.statusCode,\r\n        responseTime\r\n      };\r\n\r\n      await this.sendToAuditService('/api/audit/log', logData);\r\n    } catch (error) {\r\n      console.error('Ошибка при логировании ответа:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Логирование изменений данных\r\n   */\r\n  async logDataChange(userId, entity, entityId, oldData, newData, action = 'UPDATE') {\r\n    try {\r\n      const logData = {\r\n        entity,\r\n        entityId,\r\n        oldData,\r\n        newData,\r\n        action\r\n      };\r\n\r\n      await this.sendToAuditService('/api/audit/log-data-change', logData, {\r\n        'Authorization': `Bearer ${this.getUserToken(userId)}`,\r\n        'x-user-id': userId\r\n      });\r\n    } catch (error) {\r\n      console.error('Ошибка при логировании изменений данных:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Логирование входа пользователя\r\n   */\r\n  async logUserLogin(userId, sessionId, ipAddress, userAgent) {\r\n    try {\r\n      const logData = {\r\n        sessionId\r\n      };\r\n\r\n      await this.sendToAuditService('/api/audit/log-login', logData, {\r\n        'Authorization': `Bearer ${this.getUserToken(userId)}`,\r\n        'x-user-id': userId,\r\n        'x-forwarded-for': ipAddress,\r\n        'user-agent': userAgent\r\n      });\r\n    } catch (error) {\r\n      console.error('Ошибка при логировании входа пользователя:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Логирование выхода пользователя\r\n   */\r\n  async logUserLogout(userId, sessionId) {\r\n    try {\r\n      const logData = {\r\n        sessionId\r\n      };\r\n\r\n      await this.sendToAuditService('/api/audit/log-logout', logData, {\r\n        'Authorization': `Bearer ${this.getUserToken(userId)}`,\r\n        'x-user-id': userId\r\n      });\r\n    } catch (error) {\r\n      console.error('Ошибка при логировании выхода пользователя:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Валидация данных\r\n   */\r\n  async validateField(userId, entity, entityId, fieldName, fieldValue, validationType) {\r\n    try {\r\n      const validationData = {\r\n        entity,\r\n        entityId,\r\n        fieldName,\r\n        fieldValue,\r\n        validationType\r\n      };\r\n\r\n      const response = await this.sendToAuditService('/api/audit/validate', validationData, {\r\n        'Authorization': `Bearer ${this.getUserToken(userId)}`,\r\n        'x-user-id': userId\r\n      });\r\n\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Ошибка при валидации данных:', error);\r\n      return { isValid: false, errorMessage: 'Ошибка валидации' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение действия из HTTP метода\r\n   */\r\n  getActionFromMethod(method) {\r\n    const methodMap = {\r\n      'GET': 'READ',\r\n      'POST': 'CREATE',\r\n      'PUT': 'UPDATE',\r\n      'PATCH': 'UPDATE',\r\n      'DELETE': 'DELETE'\r\n    };\r\n    return methodMap[method] || 'READ';\r\n  }\r\n\r\n  /**\r\n   * Получение сущности из URL\r\n   */\r\n  getEntityFromUrl(url) {\r\n    const pathParts = url.split('/').filter(part => part && !part.includes('?'));\r\n    \r\n    // Пропускаем /api и берем следующую часть как сущность\r\n    const apiIndex = pathParts.indexOf('api');\r\n    if (apiIndex !== -1 && pathParts.length > apiIndex + 1) {\r\n      return pathParts[apiIndex + 1].toUpperCase();\r\n    }\r\n    \r\n    // Если нет /api, берем первую часть\r\n    return pathParts[0] ? pathParts[0].toUpperCase() : 'UNKNOWN';\r\n  }\r\n\r\n  /**\r\n   * Получение ID сущности из URL\r\n   */\r\n  getEntityIdFromUrl(url) {\r\n    const pathParts = url.split('/').filter(part => part && !part.includes('?'));\r\n    \r\n    // Ищем UUID или числовой ID в URL\r\n    for (const part of pathParts) {\r\n      if (this.isValidId(part)) {\r\n        return part;\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Проверка валидности ID\r\n   */\r\n  isValidId(str) {\r\n    // UUID pattern\r\n    const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n    // Числовой ID\r\n    const numericPattern = /^\\d+$/;\r\n    // CUID pattern\r\n    const cuidPattern = /^c[a-z0-9]{24}$/i;\r\n    \r\n    return uuidPattern.test(str) || numericPattern.test(str) || cuidPattern.test(str);\r\n  }\r\n\r\n  /**\r\n   * Очистка входных данных от чувствительной информации\r\n   */\r\n  sanitizeInputData(request) {\r\n    const sensitiveFields = ['password', 'passwordHash', 'token', 'secret', 'key'];\r\n    const data = {\r\n      params: request.params,\r\n      query: request.query,\r\n      body: request.method !== 'GET' ? request.body : undefined\r\n    };\r\n\r\n    return this.removeSensitiveFields(data, sensitiveFields);\r\n  }\r\n\r\n  /**\r\n   * Удаление чувствительных полей из объекта\r\n   */\r\n  removeSensitiveFields(obj, sensitiveFields) {\r\n    if (!obj || typeof obj !== 'object') {\r\n      return obj;\r\n    }\r\n\r\n    const cleaned = Array.isArray(obj) ? [] : {};\r\n\r\n    for (const [key, value] of Object.entries(obj)) {\r\n      if (sensitiveFields.some(field => key.toLowerCase().includes(field.toLowerCase()))) {\r\n        cleaned[key] = '[REDACTED]';\r\n      } else if (typeof value === 'object' && value !== null) {\r\n        cleaned[key] = this.removeSensitiveFields(value, sensitiveFields);\r\n      } else {\r\n        cleaned[key] = value;\r\n      }\r\n    }\r\n\r\n    return cleaned;\r\n  }\r\n\r\n  /**\r\n   * Генерация ID сессии\r\n   */\r\n  generateSessionId() {\r\n    return 'sess_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();\r\n  }\r\n\r\n  /**\r\n   * Получение токена пользователя (заглушка)\r\n   */\r\n  getUserToken(userId) {\r\n    // В реальном приложении здесь должна быть логика получения токена\r\n    return process.env.AUDIT_SERVICE_TOKEN || 'audit-service-token';\r\n  }\r\n\r\n  /**\r\n   * Отправка данных в сервис аудита\r\n   */\r\n  async sendToAuditService(endpoint, data, headers = {}) {\r\n    try {\r\n      const response = await axios.post(`${this.auditServiceUrl}${endpoint}`, data, {\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          ...headers\r\n        },\r\n        timeout: 5000 // 5 секунд таймаут\r\n      });\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      // Не прерываем основную логику при ошибках аудита\r\n      console.error(`Ошибка отправки в сервис аудита (${endpoint}):`, error.message);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Создание декоратора для автоматического логирования CRUD операций\r\n   */\r\n  createCrudLogger(entity) {\r\n    return {\r\n      /**\r\n       * Логирование создания\r\n       */\r\n      logCreate: async (userId, entityId, data) => {\r\n        await this.logDataChange(userId, entity, entityId, null, data, 'CREATE');\r\n      },\r\n\r\n      /**\r\n       * Логирование обновления\r\n       */\r\n      logUpdate: async (userId, entityId, oldData, newData) => {\r\n        await this.logDataChange(userId, entity, entityId, oldData, newData, 'UPDATE');\r\n      },\r\n\r\n      /**\r\n       * Логирование удаления\r\n       */\r\n      logDelete: async (userId, entityId, data) => {\r\n        await this.logDataChange(userId, entity, entityId, data, null, 'DELETE');\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Middleware для валидации обязательных полей\r\n   */\r\n  createValidationMiddleware(entity, requiredFields) {\r\n    return async (request, reply) => {\r\n      if (!request.user?.id) {\r\n        return; // Пропускаем валидацию для неаутентифицированных пользователей\r\n      }\r\n\r\n      const data = request.body;\r\n      const entityId = request.params?.id || 'new';\r\n\r\n      for (const field of requiredFields) {\r\n        const value = data?.[field];\r\n        const validation = await this.validateField(\r\n          request.user.id,\r\n          entity,\r\n          entityId,\r\n          field,\r\n          value,\r\n          'REQUIRED'\r\n        );\r\n\r\n        if (!validation.isValid) {\r\n          reply.code(400).send({\r\n            error: 'Validation failed',\r\n            field,\r\n            message: validation.errorMessage\r\n          });\r\n          return;\r\n        }\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = AuditMiddleware;\r\n",
  "packages/shared/middleware/validation.js": "/**\r\n * VHM24 Validation Middleware\r\n * JSON Schema валидация для всех endpoints\r\n */\r\n\r\nconst Ajv = require('ajv');\r\nconst addFormats = require('ajv-formats');\r\nconst { sanitizeInput } = require('../../shared-types/src/security');\r\n\r\n// Создаем экземпляр AJV с форматами\r\nconst ajv = new Ajv({ \r\n  allErrors: true,\r\n  removeAdditional: true, // Удаляем дополнительные поля\r\n  useDefaults: true, // Используем значения по умолчанию\r\n  coerceTypes: true // Приводим типы автоматически\r\n});\r\naddFormats(ajv);\r\n\r\n/**\r\n * Базовые схемы для переиспользования\r\n */\r\nconst baseSchemas = {\r\n  // ID схемы\r\n  id: {\r\n    type: 'string',\r\n    pattern: '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'\r\n  },\r\n  \r\n  // Email схема\r\n  email: {\r\n    type: 'string',\r\n    format: 'email',\r\n    maxLength: 255\r\n  },\r\n  \r\n  // Телефон схема (Узбекистан)\r\n  phone: {\r\n    type: 'string',\r\n    pattern: '^\\\\+998\\\\d{9}$'\r\n  },\r\n  \r\n  // Telegram ID схема\r\n  telegramId: {\r\n    type: 'string',\r\n    pattern: '^\\\\d+$',\r\n    minLength: 1,\r\n    maxLength: 20\r\n  },\r\n  \r\n  // Пагинация схемы\r\n  pagination: {\r\n    type: 'object',\r\n    properties: {\r\n      page: {\r\n        type: 'integer',\r\n        minimum: 1,\r\n        default: 1\r\n      },\r\n      limit: {\r\n        type: 'integer',\r\n        minimum: 1,\r\n        maximum: 100,\r\n        default: 20\r\n      },\r\n      sortBy: {\r\n        type: 'string',\r\n        maxLength: 50\r\n      },\r\n      sortOrder: {\r\n        type: 'string',\r\n        enum: ['asc', 'desc'],\r\n        default: 'desc'\r\n      }\r\n    },\r\n    additionalProperties: false\r\n  },\r\n  \r\n  // Координаты\r\n  coordinates: {\r\n    type: 'object',\r\n    properties: {\r\n      latitude: {\r\n        type: 'number',\r\n        minimum: -90,\r\n        maximum: 90\r\n      },\r\n      longitude: {\r\n        type: 'number',\r\n        minimum: -180,\r\n        maximum: 180\r\n      }\r\n    },\r\n    required: ['latitude', 'longitude'],\r\n    additionalProperties: false\r\n  }\r\n};\r\n\r\n/**\r\n * Схемы для аутентификации\r\n */\r\nconst authSchemas = {\r\n  login: {\r\n    type: 'object',\r\n    properties: {\r\n      email: baseSchemas.email,\r\n      password: {\r\n        type: 'string',\r\n        minLength: 8,\r\n        maxLength: 128\r\n      }\r\n    },\r\n    required: ['email', 'password'],\r\n    additionalProperties: false\r\n  },\r\n  \r\n  register: {\r\n    type: 'object',\r\n    properties: {\r\n      email: baseSchemas.email,\r\n      password: {\r\n        type: 'string',\r\n        minLength: 8,\r\n        maxLength: 128\r\n      },\r\n      firstName: {\r\n        type: 'string',\r\n        minLength: 2,\r\n        maxLength: 50\r\n      },\r\n      lastName: {\r\n        type: 'string',\r\n        minLength: 2,\r\n        maxLength: 50\r\n      },\r\n      phone: baseSchemas.phone,\r\n      telegramId: baseSchemas.telegramId\r\n    },\r\n    required: ['email', 'password', 'firstName', 'lastName'],\r\n    additionalProperties: false\r\n  },\r\n  \r\n  refreshToken: {\r\n    type: 'object',\r\n    properties: {\r\n      refreshToken: {\r\n        type: 'string',\r\n        minLength: 10\r\n      }\r\n    },\r\n    required: ['refreshToken'],\r\n    additionalProperties: false\r\n  }\r\n};\r\n\r\n/**\r\n * Схемы для машин\r\n */\r\nconst machineSchemas = {\r\n  create: {\r\n    type: 'object',\r\n    properties: {\r\n      name: {\r\n        type: 'string',\r\n        minLength: 2,\r\n        maxLength: 100\r\n      },\r\n      location: {\r\n        type: 'string',\r\n        minLength: 5,\r\n        maxLength: 255\r\n      },\r\n      coordinates: baseSchemas.coordinates,\r\n      type: {\r\n        type: 'string',\r\n        enum: ['SNACK', 'DRINK', 'COMBO', 'COFFEE']\r\n      },\r\n      capacity: {\r\n        type: 'integer',\r\n        minimum: 1,\r\n        maximum: 1000\r\n      },\r\n      isActive: {\r\n        type: 'boolean',\r\n        default: true\r\n      }\r\n    },\r\n    required: ['name', 'location', 'coordinates', 'type', 'capacity'],\r\n    additionalProperties: false\r\n  },\r\n  \r\n  update: {\r\n    type: 'object',\r\n    properties: {\r\n      name: {\r\n        type: 'string',\r\n        minLength: 2,\r\n        maxLength: 100\r\n      },\r\n      location: {\r\n        type: 'string',\r\n        minLength: 5,\r\n        maxLength: 255\r\n      },\r\n      coordinates: baseSchemas.coordinates,\r\n      type: {\r\n        type: 'string',\r\n        enum: ['SNACK', 'DRINK', 'COMBO', 'COFFEE']\r\n      },\r\n      capacity: {\r\n        type: 'integer',\r\n        minimum: 1,\r\n        maximum: 1000\r\n      },\r\n      isActive: {\r\n        type: 'boolean'\r\n      }\r\n    },\r\n    additionalProperties: false\r\n  },\r\n  \r\n  list: {\r\n    type: 'object',\r\n    properties: {\r\n      ...baseSchemas.pagination.properties,\r\n      type: {\r\n        type: 'string',\r\n        enum: ['SNACK', 'DRINK', 'COMBO', 'COFFEE']\r\n      },\r\n      isActive: {\r\n        type: 'boolean'\r\n      },\r\n      location: {\r\n        type: 'string',\r\n        maxLength: 255\r\n      }\r\n    },\r\n    additionalProperties: false\r\n  }\r\n};\r\n\r\n/**\r\n * Схемы для инвентаря\r\n */\r\nconst inventorySchemas = {\r\n  create: {\r\n    type: 'object',\r\n    properties: {\r\n      machineId: baseSchemas.id,\r\n      productName: {\r\n        type: 'string',\r\n        minLength: 2,\r\n        maxLength: 100\r\n      },\r\n      quantity: {\r\n        type: 'integer',\r\n        minimum: 0,\r\n        maximum: 1000\r\n      },\r\n      price: {\r\n        type: 'number',\r\n        minimum: 0,\r\n        maximum: 1000000\r\n      },\r\n      expiryDate: {\r\n        type: 'string',\r\n        format: 'date'\r\n      }\r\n    },\r\n    required: ['machineId', 'productName', 'quantity', 'price'],\r\n    additionalProperties: false\r\n  },\r\n  \r\n  update: {\r\n    type: 'object',\r\n    properties: {\r\n      productName: {\r\n        type: 'string',\r\n        minLength: 2,\r\n        maxLength: 100\r\n      },\r\n      quantity: {\r\n        type: 'integer',\r\n        minimum: 0,\r\n        maximum: 1000\r\n      },\r\n      price: {\r\n        type: 'number',\r\n        minimum: 0,\r\n        maximum: 1000000\r\n      },\r\n      expiryDate: {\r\n        type: 'string',\r\n        format: 'date'\r\n      }\r\n    },\r\n    additionalProperties: false\r\n  },\r\n  \r\n  list: {\r\n    type: 'object',\r\n    properties: {\r\n      ...baseSchemas.pagination.properties,\r\n      machineId: baseSchemas.id,\r\n      productName: {\r\n        type: 'string',\r\n        maxLength: 100\r\n      },\r\n      lowStock: {\r\n        type: 'boolean'\r\n      }\r\n    },\r\n    additionalProperties: false\r\n  }\r\n};\r\n\r\n/**\r\n * Схемы для задач\r\n */\r\nconst taskSchemas = {\r\n  create: {\r\n    type: 'object',\r\n    properties: {\r\n      machineId: baseSchemas.id,\r\n      type: {\r\n        type: 'string',\r\n        enum: ['MAINTENANCE', 'REFILL', 'REPAIR', 'INSPECTION', 'CLEANING']\r\n      },\r\n      priority: {\r\n        type: 'string',\r\n        enum: ['LOW', 'MEDIUM', 'HIGH', 'URGENT'],\r\n        default: 'MEDIUM'\r\n      },\r\n      description: {\r\n        type: 'string',\r\n        minLength: 10,\r\n        maxLength: 1000\r\n      },\r\n      scheduledFor: {\r\n        type: 'string',\r\n        format: 'date-time'\r\n      },\r\n      assignedTo: baseSchemas.id\r\n    },\r\n    required: ['machineId', 'type', 'description'],\r\n    additionalProperties: false\r\n  },\r\n  \r\n  update: {\r\n    type: 'object',\r\n    properties: {\r\n      type: {\r\n        type: 'string',\r\n        enum: ['MAINTENANCE', 'REFILL', 'REPAIR', 'INSPECTION', 'CLEANING']\r\n      },\r\n      priority: {\r\n        type: 'string',\r\n        enum: ['LOW', 'MEDIUM', 'HIGH', 'URGENT']\r\n      },\r\n      status: {\r\n        type: 'string',\r\n        enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED']\r\n      },\r\n      description: {\r\n        type: 'string',\r\n        minLength: 10,\r\n        maxLength: 1000\r\n      },\r\n      scheduledFor: {\r\n        type: 'string',\r\n        format: 'date-time'\r\n      },\r\n      assignedTo: baseSchemas.id,\r\n      completedAt: {\r\n        type: 'string',\r\n        format: 'date-time'\r\n      },\r\n      notes: {\r\n        type: 'string',\r\n        maxLength: 2000\r\n      }\r\n    },\r\n    additionalProperties: false\r\n  },\r\n  \r\n  list: {\r\n    type: 'object',\r\n    properties: {\r\n      ...baseSchemas.pagination.properties,\r\n      machineId: baseSchemas.id,\r\n      type: {\r\n        type: 'string',\r\n        enum: ['MAINTENANCE', 'REFILL', 'REPAIR', 'INSPECTION', 'CLEANING']\r\n      },\r\n      status: {\r\n        type: 'string',\r\n        enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED']\r\n      },\r\n      priority: {\r\n        type: 'string',\r\n        enum: ['LOW', 'MEDIUM', 'HIGH', 'URGENT']\r\n      },\r\n      assignedTo: baseSchemas.id\r\n    },\r\n    additionalProperties: false\r\n  }\r\n};\r\n\r\n/**\r\n * Все схемы в одном объекте\r\n */\r\nconst schemas = {\r\n  auth: authSchemas,\r\n  machine: machineSchemas,\r\n  inventory: inventorySchemas,\r\n  task: taskSchemas,\r\n  base: baseSchemas\r\n};\r\n\r\n/**\r\n * Компилируем все схемы\r\n */\r\nconst compiledSchemas = {};\r\nObject.keys(schemas).forEach(category => {\r\n  compiledSchemas[category] = {};\r\n  Object.keys(schemas[category]).forEach(schemaName => {\r\n    const schemaKey = `${category}.${schemaName}`;\r\n    compiledSchemas[category][schemaName] = ajv.compile(schemas[category][schemaName]);\r\n  });\r\n});\r\n\r\n/**\r\n * Middleware для валидации body\r\n */\r\nconst validateBody = (category, schemaName) => {\r\n  return async (request, reply) => {\r\n    const validator = compiledSchemas[category]?.[schemaName];\r\n    \r\n    if (!validator) {\r\n      return reply.code(500).send({\r\n        error: 'Internal Server Error',\r\n        message: 'Validation schema not found',\r\n        statusCode: 500\r\n      });\r\n    }\r\n\r\n    // Санитизируем данные перед валидацией\r\n    if (request.body && typeof request.body === 'object') {\r\n      sanitizeRequestData(request.body);\r\n    }\r\n\r\n    const valid = validator(request.body);\r\n    \r\n    if (!valid) {\r\n      const errors = validator.errors.map(err => ({\r\n        field: err.instancePath.replace('/', '') || err.params?.missingProperty || 'root',\r\n        message: err.message,\r\n        value: err.data\r\n      }));\r\n\r\n      return reply.code(400).send({\r\n        error: 'Validation Error',\r\n        message: 'Invalid request data',\r\n        statusCode: 400,\r\n        details: errors\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Middleware для валидации query параметров\r\n */\r\nconst validateQuery = (category, schemaName) => {\r\n  return async (request, reply) => {\r\n    const validator = compiledSchemas[category]?.[schemaName];\r\n    \r\n    if (!validator) {\r\n      return reply.code(500).send({\r\n        error: 'Internal Server Error',\r\n        message: 'Validation schema not found',\r\n        statusCode: 500\r\n      });\r\n    }\r\n\r\n    // Санитизируем query параметры\r\n    if (request.query) {\r\n      sanitizeRequestData(request.query);\r\n    }\r\n\r\n    const valid = validator(request.query);\r\n    \r\n    if (!valid) {\r\n      const errors = validator.errors.map(err => ({\r\n        field: err.instancePath.replace('/', '') || err.params?.missingProperty || 'root',\r\n        message: err.message,\r\n        value: err.data\r\n      }));\r\n\r\n      return reply.code(400).send({\r\n        error: 'Validation Error',\r\n        message: 'Invalid query parameters',\r\n        statusCode: 400,\r\n        details: errors\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Middleware для валидации params (URL параметров)\r\n */\r\nconst validateParams = (paramsSchema) => {\r\n  const validator = ajv.compile(paramsSchema);\r\n  \r\n  return async (request, reply) => {\r\n    const valid = validator(request.params);\r\n    \r\n    if (!valid) {\r\n      const errors = validator.errors.map(err => ({\r\n        field: err.instancePath.replace('/', '') || err.params?.missingProperty || 'root',\r\n        message: err.message,\r\n        value: err.data\r\n      }));\r\n\r\n      return reply.code(400).send({\r\n        error: 'Validation Error',\r\n        message: 'Invalid URL parameters',\r\n        statusCode: 400,\r\n        details: errors\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Универсальный валидатор ID параметра\r\n */\r\nconst validateId = validateParams({\r\n  type: 'object',\r\n  properties: {\r\n    id: baseSchemas.id\r\n  },\r\n  required: ['id'],\r\n  additionalProperties: false\r\n});\r\n\r\n/**\r\n * Санитизация данных запроса\r\n */\r\nfunction sanitizeRequestData(data) {\r\n  if (typeof data !== 'object' || data === null) return;\r\n  \r\n  for (const [key, value] of Object.entries(data)) {\r\n    if (typeof value === 'string') {\r\n      data[key] = sanitizeInput(value);\r\n    } else if (typeof value === 'object' && value !== null) {\r\n      sanitizeRequestData(value);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Создание кастомного валидатора\r\n */\r\nconst createValidator = (schema) => {\r\n  const validator = ajv.compile(schema);\r\n  \r\n  return async (request, reply) => {\r\n    const dataToValidate = {\r\n      ...request.body,\r\n      ...request.query,\r\n      ...request.params\r\n    };\r\n\r\n    // Санитизируем данные\r\n    sanitizeRequestData(dataToValidate);\r\n\r\n    const valid = validator(dataToValidate);\r\n    \r\n    if (!valid) {\r\n      const errors = validator.errors.map(err => ({\r\n        field: err.instancePath.replace('/', '') || err.params?.missingProperty || 'root',\r\n        message: err.message,\r\n        value: err.data\r\n      }));\r\n\r\n      return reply.code(400).send({\r\n        error: 'Validation Error',\r\n        message: 'Invalid request data',\r\n        statusCode: 400,\r\n        details: errors\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Валидация файлов\r\n */\r\nconst validateFile = (options = {}) => {\r\n  const {\r\n    required = false,\r\n    maxSize = 5 * 1024 * 1024, // 5MB по умолчанию\r\n    allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf']\r\n  } = options;\r\n\r\n  return async (request, reply) => {\r\n    const file = request.file;\r\n\r\n    if (required && !file) {\r\n      return reply.code(400).send({\r\n        error: 'Validation Error',\r\n        message: 'File is required',\r\n        statusCode: 400\r\n      });\r\n    }\r\n\r\n    if (file) {\r\n      // Проверяем размер файла\r\n      if (file.size > maxSize) {\r\n        return reply.code(400).send({\r\n          error: 'Validation Error',\r\n          message: `File size exceeds limit of ${Math.round(maxSize / 1024 / 1024)}MB`,\r\n          statusCode: 400\r\n        });\r\n      }\r\n\r\n      // Проверяем тип файла\r\n      if (!allowedTypes.includes(file.mimetype)) {\r\n        return reply.code(400).send({\r\n          error: 'Validation Error',\r\n          message: `File type ${file.mimetype} is not allowed`,\r\n          statusCode: 400,\r\n          allowedTypes\r\n        });\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\nmodule.exports = {\r\n  schemas,\r\n  validateBody,\r\n  validateQuery,\r\n  validateParams,\r\n  validateId,\r\n  validateFile,\r\n  createValidator,\r\n  compiledSchemas\r\n};\r\n",
  "railway-start-monolith.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Railway Monolith Start Script\r\n * Запускает все сервисы в одном процессе для Railway\r\n */\r\n\r\nconst { spawn } = require('child_process');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\nconst Fastify = require('fastify');\r\n\r\n// Загружаем переменные окружения\r\ntry {\r\n  require('dotenv').config();\r\n} catch (error) {\r\n  console.log('⚠️ dotenv not available, using environment variables');\r\n}\r\n\r\nconsole.log('🚂 VHM24 Railway Monolith Start...');\r\nconsole.log(`📍 Environment: ${process.env.NODE_ENV || 'production'}`);\r\nconsole.log(`🔌 Port: ${process.env.PORT || 8000}`);\r\n\r\n// Устанавливаем переменные окружения\r\nprocess.env.NODE_ENV = process.env.NODE_ENV || 'production';\r\nprocess.env.PORT = process.env.PORT || '8000';\r\n\r\n// Проверяем обязательные переменные\r\nif (!process.env.DATABASE_URL) {\r\n  console.error('❌ DATABASE_URL is required for Railway deployment');\r\n  process.exit(1);\r\n}\r\n\r\n// Функция для запуска команды\r\nfunction runCommand(command, args = [], options = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    console.log(`🔧 Running: ${command} ${args.join(' ')}`);\r\n    \r\n    const child = spawn(command, args, {\r\n      stdio: 'inherit',\r\n      shell: true,\r\n      ...options\r\n    });\r\n\r\n    child.on('close', (code) => {\r\n      if (code === 0) {\r\n        resolve();\r\n      } else {\r\n        reject(new Error(`Command failed with code ${code}`));\r\n      }\r\n    });\r\n\r\n    child.on('error', reject);\r\n  });\r\n}\r\n\r\n// Основная функция\r\nasync function startRailwayApp() {\r\n  try {\r\n    console.log('🗄️ === DATABASE MIGRATION PHASE ===');\r\n    \r\n    // Проверяем наличие schema.prisma\r\n    const schemaPath = path.join(__dirname, 'packages/database/prisma/schema.prisma');\r\n    if (!fs.existsSync(schemaPath)) {\r\n      throw new Error('Prisma schema not found at packages/database/prisma/schema.prisma');\r\n    }\r\n    \r\n    console.log('✅ Prisma schema found');\r\n    \r\n    // Генерируем Prisma клиент\r\n    console.log('🔧 Generating Prisma client...');\r\n    await runCommand('npx', ['prisma', 'generate'], {\r\n      cwd: path.join(__dirname, 'packages/database')\r\n    });\r\n    console.log('✅ Prisma client generated');\r\n    \r\n    // Запускаем миграции\r\n    console.log('🔧 Running database migrations...');\r\n    await runCommand('npx', ['prisma', 'migrate', 'deploy'], {\r\n      cwd: path.join(__dirname, 'packages/database')\r\n    });\r\n    console.log('✅ Database migrations completed');\r\n    \r\n    // Проверяем подключение к базе данных\r\n    console.log('🔧 Testing database connection...');\r\n    const { getPrismaClient } = require('./packages/database');\r\n    let prisma;\r\n    \r\n    try {\r\n      prisma = getPrismaClient();\r\n      await prisma.$connect();\r\n      console.log('✅ Database connection successful');\r\n      \r\n      // Проверяем наличие пользователей\r\n      const userCount = await prisma.user.count();\r\n      console.log(`📊 Users in database: ${userCount}`);\r\n      \r\n      // Создаем администратора если нет пользователей\r\n      if (userCount === 0) {\r\n        console.log('🔧 Creating default admin user...');\r\n        const bcrypt = require('bcrypt');\r\n        \r\n        const adminUser = await prisma.user.create({\r\n          data: {\r\n            email: 'admin@vhm24.ru',\r\n            name: 'System Administrator',\r\n            passwordHash: await bcrypt.hash('admin123', 10),\r\n            telegramId: process.env.ADMIN_IDS || '42283329',\r\n            roles: ['ADMIN'],\r\n            isActive: true\r\n          }\r\n        });\r\n        \r\n        console.log('✅ Default admin user created');\r\n        console.log(`📧 Email: admin@vhm24.ru`);\r\n        console.log(`🔑 Password: admin123`);\r\n        console.log(`📱 Telegram ID: ${adminUser.telegramId}`);\r\n      }\r\n      \r\n      await prisma.$disconnect();\r\n      console.log('🎉 Database migration completed successfully!');\r\n    } catch (error) {\r\n      console.error('❌ Database connection failed:', error.message);\r\n      console.log('⚠️ Continuing without database setup...');\r\n    }\r\n    \r\n    console.log('\\n🚂 === MONOLITH APPLICATION START ===');\r\n    \r\n    // Создаем единый Fastify сервер\r\n    const fastify = Fastify({\r\n      logger: true,\r\n      bodyLimit: 10485760 // 10MB\r\n    });\r\n\r\n    // Регистрируем CORS\r\n    await fastify.register(require('@fastify/cors'), {\r\n      origin: true,\r\n      credentials: true\r\n    });\r\n\r\n    // Регистрируем multipart для загрузки файлов\r\n    await fastify.register(require('@fastify/multipart'), {\r\n      limits: {\r\n        fileSize: 10 * 1024 * 1024 // 10MB\r\n      }\r\n    });\r\n\r\n    // Health check endpoint\r\n    fastify.get('/health', async (request, reply) => {\r\n      return { \r\n        status: 'ok', \r\n        service: 'vhm24-monolith',\r\n        timestamp: new Date().toISOString(),\r\n        database: 'connected'\r\n      };\r\n    });\r\n\r\n    // API Documentation\r\n    fastify.get('/docs', async (request, reply) => {\r\n      reply.type('text/html');\r\n      return `\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <title>VHM24 API Documentation</title>\r\n          <style>\r\n            body { font-family: Arial, sans-serif; margin: 40px; }\r\n            .endpoint { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }\r\n            .method { font-weight: bold; color: #007bff; }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <h1>🤖 VHM24 API Documentation</h1>\r\n          <p>VendHub Manager 24/7 - Production API</p>\r\n          \r\n          <div class=\"endpoint\">\r\n            <div class=\"method\">GET /health</div>\r\n            <p>Health check endpoint</p>\r\n          </div>\r\n          \r\n          <div class=\"endpoint\">\r\n            <div class=\"method\">GET /docs</div>\r\n            <p>This documentation page</p>\r\n          </div>\r\n          \r\n          <div class=\"endpoint\">\r\n            <div class=\"method\">POST /api/v1/auth/login</div>\r\n            <p>User authentication</p>\r\n          </div>\r\n          \r\n          <div class=\"endpoint\">\r\n            <div class=\"method\">GET /api/v1/dashboard/stats</div>\r\n            <p>Dashboard statistics</p>\r\n          </div>\r\n          \r\n          <div class=\"endpoint\">\r\n            <div class=\"method\">GET /api/v1/machines</div>\r\n            <p>List all machines</p>\r\n          </div>\r\n          \r\n          <div class=\"endpoint\">\r\n            <div class=\"method\">GET /api/v1/inventory</div>\r\n            <p>Inventory management</p>\r\n          </div>\r\n          \r\n          <div class=\"endpoint\">\r\n            <div class=\"method\">GET /api/v1/tasks</div>\r\n            <p>Task management</p>\r\n          </div>\r\n          \r\n          <p><strong>Environment:</strong> ${process.env.NODE_ENV}</p>\r\n          <p><strong>Version:</strong> 1.0.0</p>\r\n        </body>\r\n        </html>\r\n      `;\r\n    });\r\n\r\n    // Получаем prisma клиент для API endpoints\r\n    let apiPrisma;\r\n    try {\r\n      apiPrisma = getPrismaClient();\r\n    } catch (error) {\r\n      console.error('❌ Failed to initialize Prisma client for API:', error.message);\r\n      apiPrisma = null;\r\n    }\r\n\r\n    // Встраиваем основные API endpoints прямо в монолит\r\n    \r\n    // Auth endpoints\r\n    fastify.post('/api/v1/auth/login', async (request, reply) => {\r\n      try {\r\n        if (!apiPrisma) {\r\n          return reply.code(503).send({\r\n            success: false,\r\n            error: 'Database not available'\r\n          });\r\n        }\r\n\r\n        const { email, password } = request.body;\r\n        \r\n        if (!email || !password) {\r\n          return reply.code(400).send({\r\n            success: false,\r\n            error: 'Email and password are required'\r\n          });\r\n        }\r\n\r\n        const bcrypt = require('bcrypt');\r\n        const jwt = require('jsonwebtoken');\r\n        \r\n        const user = await apiPrisma.user.findUnique({\r\n          where: { email }\r\n        });\r\n\r\n        if (!user || !await bcrypt.compare(password, user.passwordHash)) {\r\n          return reply.code(401).send({\r\n            success: false,\r\n            error: 'Invalid credentials'\r\n          });\r\n        }\r\n\r\n        const token = jwt.sign(\r\n          { \r\n            id: user.id, \r\n            email: user.email, \r\n            roles: user.roles \r\n          },\r\n          process.env.JWT_SECRET || 'vhm24-secret-key',\r\n          { expiresIn: '24h' }\r\n        );\r\n\r\n        return {\r\n          success: true,\r\n          data: {\r\n            token,\r\n            user: {\r\n              id: user.id,\r\n              email: user.email,\r\n              name: user.name,\r\n              roles: user.roles\r\n            }\r\n          }\r\n        };\r\n      } catch (error) {\r\n        console.error('Login error:', error);\r\n        return reply.code(500).send({\r\n          success: false,\r\n          error: 'Internal server error'\r\n        });\r\n      }\r\n    });\r\n\r\n    // Dashboard stats\r\n    fastify.get('/api/v1/dashboard/stats', async (request, reply) => {\r\n      try {\r\n        if (!apiPrisma) {\r\n          return reply.code(503).send({\r\n            success: false,\r\n            error: 'Database not available'\r\n          });\r\n        }\r\n\r\n        const [\r\n          totalMachines,\r\n          onlineMachines,\r\n          totalTasks,\r\n          pendingTasks,\r\n          totalUsers,\r\n          activeUsers\r\n        ] = await Promise.all([\r\n          apiPrisma.machine.count(),\r\n          apiPrisma.machine.count({ where: { status: 'ONLINE' } }),\r\n          apiPrisma.task.count(),\r\n          apiPrisma.task.count({ where: { status: { in: ['CREATED', 'ASSIGNED'] } } }),\r\n          apiPrisma.user.count(),\r\n          apiPrisma.user.count({ where: { isActive: true } })\r\n        ]);\r\n\r\n        return {\r\n          success: true,\r\n          data: {\r\n            totalMachines,\r\n            onlineMachines,\r\n            totalTasks,\r\n            pendingTasks,\r\n            totalUsers,\r\n            activeUsers,\r\n            todayRevenue: 0,\r\n            totalRevenue: 0\r\n          }\r\n        };\r\n      } catch (error) {\r\n        console.error('Dashboard stats error:', error);\r\n        return reply.code(500).send({\r\n          success: false,\r\n          error: 'Failed to fetch dashboard stats'\r\n        });\r\n      }\r\n    });\r\n\r\n    // Machines endpoints\r\n    fastify.get('/api/v1/machines', async (request, reply) => {\r\n      try {\r\n        if (!apiPrisma) {\r\n          return reply.code(503).send({\r\n            success: false,\r\n            error: 'Database not available'\r\n          });\r\n        }\r\n\r\n        const machines = await apiPrisma.machine.findMany({\r\n          include: {\r\n            location: true\r\n          }\r\n        });\r\n\r\n        return {\r\n          success: true,\r\n          data: machines\r\n        };\r\n      } catch (error) {\r\n        console.error('Machines error:', error);\r\n        return reply.code(500).send({\r\n          success: false,\r\n          error: 'Failed to fetch machines'\r\n        });\r\n      }\r\n    });\r\n\r\n    // Inventory endpoints\r\n    fastify.get('/api/v1/inventory', async (request, reply) => {\r\n      try {\r\n        if (!apiPrisma) {\r\n          return reply.code(503).send({\r\n            success: false,\r\n            error: 'Database not available'\r\n          });\r\n        }\r\n\r\n        const inventory = await apiPrisma.inventoryItem.findMany();\r\n\r\n        return {\r\n          success: true,\r\n          data: inventory\r\n        };\r\n      } catch (error) {\r\n        console.error('Inventory error:', error);\r\n        return reply.code(500).send({\r\n          success: false,\r\n          error: 'Failed to fetch inventory'\r\n        });\r\n      }\r\n    });\r\n\r\n    // Tasks endpoints\r\n    fastify.get('/api/v1/tasks', async (request, reply) => {\r\n      try {\r\n        if (!apiPrisma) {\r\n          return reply.code(503).send({\r\n            success: false,\r\n            error: 'Database not available'\r\n          });\r\n        }\r\n\r\n        const tasks = await apiPrisma.task.findMany({\r\n          include: {\r\n            assignedTo: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                email: true\r\n              }\r\n            },\r\n            machine: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                code: true\r\n              }\r\n            }\r\n          }\r\n        });\r\n\r\n        return {\r\n          success: true,\r\n          data: tasks\r\n        };\r\n      } catch (error) {\r\n        console.error('Tasks error:', error);\r\n        return reply.code(500).send({\r\n          success: false,\r\n          error: 'Failed to fetch tasks'\r\n        });\r\n      }\r\n    });\r\n\r\n    // Запускаем Telegram Bot в фоне (если токен есть)\r\n    if (process.env.TELEGRAM_BOT_TOKEN) {\r\n      setTimeout(() => {\r\n        console.log('🤖 Starting Telegram Bot...');\r\n        try {\r\n          require('./services/telegram-bot/src/index.js');\r\n          console.log('✅ Telegram Bot started successfully');\r\n        } catch (error) {\r\n          console.error('❌ Telegram Bot failed to start:', error.message);\r\n        }\r\n      }, 3000);\r\n    }\r\n\r\n    // Запускаем сервер\r\n    const port = process.env.PORT || 8000;\r\n    await fastify.listen({ \r\n      port: port,\r\n      host: '0.0.0.0'\r\n    });\r\n    \r\n    console.log(`🎉 VHM24 Monolith is running on port ${port}`);\r\n    console.log(`🌐 Health check: http://localhost:${port}/health`);\r\n    console.log(`📚 Documentation: http://localhost:${port}/docs`);\r\n    \r\n    // Railway specific logging\r\n    if (process.env.RAILWAY_ENVIRONMENT) {\r\n      console.log('🚂 Running on Railway:', process.env.RAILWAY_STATIC_URL);\r\n      console.log('🔗 Public URL:', `https://${process.env.RAILWAY_STATIC_URL}`);\r\n    }\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Railway deployment failed:', error.message);\r\n    console.error('Stack trace:', error.stack);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Обработка сигналов\r\nprocess.on('SIGTERM', () => {\r\n  console.log('🛑 Received SIGTERM, shutting down...');\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('SIGINT', () => {\r\n  console.log('🛑 Received SIGINT, shutting down...');\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('uncaughtException', (error) => {\r\n  console.error('❌ Uncaught Exception:', error);\r\n  process.exit(1);\r\n});\r\n\r\nprocess.on('unhandledRejection', (reason, promise) => {\r\n  console.error('❌ Unhandled Rejection:', reason);\r\n  process.exit(1);\r\n});\r\n\r\n// Запускаем приложение\r\nstartRailwayApp();\r\n",
  "railway-start-unified.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Railway Unified Start Script\r\n * Объединяет миграцию базы данных и запуск приложения в одном скрипте\r\n * Решает проблемы с деплоем на Railway\r\n */\r\n\r\nconst { spawn } = require('child_process');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\nconst Fastify = require('fastify');\r\n\r\n// Загружаем переменные окружения\r\ntry {\r\n  require('dotenv').config();\r\n} catch (error) {\r\n  console.log('⚠️ dotenv not available, using environment variables');\r\n}\r\n\r\nconsole.log('🚂 VHM24 Railway Unified Start...');\r\nconsole.log(`📍 Environment: ${process.env.NODE_ENV || 'production'}`);\r\nconsole.log(`🔌 Port: ${process.env.PORT || 8000}`);\r\n\r\n// Устанавливаем переменные окружения\r\nprocess.env.NODE_ENV = process.env.NODE_ENV || 'production';\r\nprocess.env.PORT = process.env.PORT || '8000';\r\n\r\n// Проверяем обязательные переменные\r\nif (!process.env.DATABASE_URL) {\r\n  console.error('❌ DATABASE_URL is required for Railway deployment');\r\n  process.exit(1);\r\n}\r\n\r\n// Функция для запуска команды\r\nfunction runCommand(command, args = [], options = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    console.log(`🔧 Running: ${command} ${args.join(' ')}`);\r\n    \r\n    const child = spawn(command, args, {\r\n      stdio: 'inherit',\r\n      shell: true,\r\n      ...options\r\n    });\r\n\r\n    child.on('close', (code) => {\r\n      if (code === 0) {\r\n        resolve();\r\n      } else {\r\n        reject(new Error(`Command failed with code ${code}`));\r\n      }\r\n    });\r\n\r\n    child.on('error', reject);\r\n  });\r\n}\r\n\r\n// Основная функция\r\nasync function startRailwayApp() {\r\n  try {\r\n    console.log('🗄️ === DATABASE MIGRATION PHASE ===');\r\n    \r\n    // Проверяем наличие schema.prisma\r\n    const schemaPath = path.join(__dirname, 'packages/database/prisma/schema.prisma');\r\n    if (!fs.existsSync(schemaPath)) {\r\n      console.warn('⚠️ Prisma schema not found at packages/database/prisma/schema.prisma');\r\n      console.warn('⚠️ Skipping database migration phase');\r\n    } else {\r\n      console.log('✅ Prisma schema found');\r\n      \r\n      // Генерируем Prisma клиент\r\n      console.log('🔧 Generating Prisma client...');\r\n      try {\r\n        await runCommand('npx', ['prisma', 'generate'], {\r\n          cwd: path.join(__dirname, 'packages/database')\r\n        });\r\n        console.log('✅ Prisma client generated');\r\n      } catch (error) {\r\n        console.error('⚠️ Failed to generate Prisma client:', error.message);\r\n        console.log('⚠️ Continuing without Prisma client generation');\r\n      }\r\n      \r\n      // Запускаем миграции\r\n      console.log('🔧 Running database migrations...');\r\n      try {\r\n        await runCommand('npx', ['prisma', 'migrate', 'deploy'], {\r\n          cwd: path.join(__dirname, 'packages/database')\r\n        });\r\n        console.log('✅ Database migrations completed');\r\n      } catch (error) {\r\n        console.error('⚠️ Failed to run database migrations:', error.message);\r\n        console.log('⚠️ Continuing without database migrations');\r\n      }\r\n      \r\n      // Проверяем подключение к базе данных\r\n      console.log('🔧 Testing database connection...');\r\n      let prisma;\r\n      \r\n      try {\r\n        const { getPrismaClient } = require('./packages/database');\r\n        prisma = getPrismaClient();\r\n        await prisma.$connect();\r\n        console.log('✅ Database connection successful');\r\n        \r\n        // Проверяем наличие пользователей\r\n        const userCount = await prisma.user.count();\r\n        console.log(`📊 Users in database: ${userCount}`);\r\n        \r\n        // Создаем администратора если нет пользователей\r\n        if (userCount === 0) {\r\n          console.log('🔧 Creating default admin user...');\r\n          try {\r\n            const bcrypt = require('bcrypt');\r\n            \r\n            const adminUser = await prisma.user.create({\r\n              data: {\r\n                email: 'admin@vhm24.ru',\r\n                name: 'System Administrator',\r\n                passwordHash: await bcrypt.hash('admin123', 10),\r\n                telegramId: process.env.ADMIN_IDS || '42283329',\r\n                roles: ['ADMIN'],\r\n                isActive: true\r\n              }\r\n            });\r\n            \r\n            console.log('✅ Default admin user created');\r\n            console.log(`📧 Email: admin@vhm24.ru`);\r\n            console.log(`🔑 Password: admin123`);\r\n            console.log(`📱 Telegram ID: ${adminUser.telegramId}`);\r\n          } catch (error) {\r\n            console.error('⚠️ Failed to create admin user:', error.message);\r\n            console.log('⚠️ Continuing without admin user creation');\r\n          }\r\n        }\r\n        \r\n        await prisma.$disconnect();\r\n        console.log('🎉 Database migration completed successfully!');\r\n      } catch (error) {\r\n        console.error('⚠️ Database connection failed:', error.message);\r\n        console.log('⚠️ Continuing without database setup...');\r\n      }\r\n    }\r\n    \r\n    console.log('\\n🚂 === MONOLITH APPLICATION START ===');\r\n    \r\n    // Создаем единый Fastify сервер\r\n    const fastify = Fastify({\r\n      logger: true,\r\n      bodyLimit: 10485760 // 10MB\r\n    });\r\n\r\n    // Регистрируем CORS\r\n    try {\r\n      await fastify.register(require('@fastify/cors'), {\r\n        origin: true,\r\n        credentials: true\r\n      });\r\n    } catch (error) {\r\n      console.error('⚠️ Failed to register CORS:', error.message);\r\n    }\r\n\r\n    // Регистрируем multipart для загрузки файлов\r\n    try {\r\n      await fastify.register(require('@fastify/multipart'), {\r\n        limits: {\r\n          fileSize: 10 * 1024 * 1024 // 10MB\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.error('⚠️ Failed to register multipart:', error.message);\r\n    }\r\n\r\n    // Health check endpoint\r\n    fastify.get('/health', async (request, reply) => {\r\n      const healthData = {\r\n        status: 'ok',\r\n        service: 'vhm24-unified',\r\n        timestamp: new Date().toISOString(),\r\n        environment: process.env.NODE_ENV || 'production',\r\n        port: process.env.PORT || 8000,\r\n        uptime: process.uptime(),\r\n        memory: process.memoryUsage(),\r\n        version: '1.0.0'\r\n      };\r\n\r\n      // Проверяем подключение к базе данных если доступно\r\n      if (process.env.DATABASE_URL) {\r\n        try {\r\n          const { PrismaClient } = require('@prisma/client');\r\n          const prisma = new PrismaClient();\r\n          await prisma.$queryRaw`SELECT 1`;\r\n          await prisma.$disconnect();\r\n          healthData.database = 'connected';\r\n        } catch (error) {\r\n          healthData.database = 'disconnected';\r\n          healthData.database_error = error.message;\r\n        }\r\n      }\r\n\r\n      return healthData;\r\n    });\r\n\r\n    // Root endpoint\r\n    fastify.get('/', async (request, reply) => {\r\n      reply.type('text/html');\r\n      return `\r\n        <!DOCTYPE html>\r\n        <html lang=\"ru\">\r\n        <head>\r\n          <meta charset=\"UTF-8\">\r\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n          <title>VHM24 - Railway Deployment</title>\r\n          <style>\r\n            * { margin: 0; padding: 0; box-sizing: border-box; }\r\n            body { \r\n              font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n              color: white;\r\n              min-height: 100vh;\r\n              display: flex;\r\n              align-items: center;\r\n              justify-content: center;\r\n            }\r\n            .container { \r\n              max-width: 900px; \r\n              margin: 0 auto; \r\n              padding: 40px;\r\n              background: rgba(255,255,255,0.1);\r\n              border-radius: 20px;\r\n              backdrop-filter: blur(10px);\r\n              box-shadow: 0 8px 32px rgba(0,0,0,0.1);\r\n              text-align: center;\r\n            }\r\n            .success { \r\n              color: #4CAF50; \r\n              font-size: 2.5em; \r\n              margin: 20px 0;\r\n              text-shadow: 2px 2px 4px rgba(0,0,0,0.3);\r\n            }\r\n            .info-grid {\r\n              display: grid;\r\n              grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\r\n              gap: 15px;\r\n              margin: 30px 0;\r\n            }\r\n            .info-card { \r\n              padding: 15px; \r\n              background: rgba(255,255,255,0.2); \r\n              border-radius: 10px;\r\n              border: 1px solid rgba(255,255,255,0.3);\r\n            }\r\n            .endpoint-list {\r\n              display: grid;\r\n              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\r\n              gap: 10px;\r\n              margin: 20px 0;\r\n            }\r\n            .endpoint { \r\n              padding: 12px; \r\n              background: rgba(255,255,255,0.15); \r\n              border-radius: 8px;\r\n              font-family: 'Courier New', monospace;\r\n              font-size: 0.9em;\r\n            }\r\n            .status-indicator {\r\n              display: inline-block;\r\n              width: 12px;\r\n              height: 12px;\r\n              border-radius: 50%;\r\n              background: #4CAF50;\r\n              margin-right: 8px;\r\n              animation: pulse 2s infinite;\r\n            }\r\n            @keyframes pulse {\r\n              0% { opacity: 1; }\r\n              50% { opacity: 0.5; }\r\n              100% { opacity: 1; }\r\n            }\r\n            .footer {\r\n              margin-top: 40px;\r\n              font-size: 0.9em;\r\n              opacity: 0.8;\r\n              border-top: 1px solid rgba(255,255,255,0.2);\r\n              padding-top: 20px;\r\n            }\r\n            .btn {\r\n              display: inline-block;\r\n              padding: 12px 24px;\r\n              margin: 10px;\r\n              background: rgba(255,255,255,0.2);\r\n              border: 1px solid rgba(255,255,255,0.3);\r\n              border-radius: 8px;\r\n              color: white;\r\n              text-decoration: none;\r\n              transition: all 0.3s ease;\r\n            }\r\n            .btn:hover {\r\n              background: rgba(255,255,255,0.3);\r\n              transform: translateY(-2px);\r\n            }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <div class=\"container\">\r\n            <h1>🎉 VHM24 Railway Deployment</h1>\r\n            <div class=\"success\">\r\n              <span class=\"status-indicator\"></span>\r\n              УСПЕШНО РАЗВЕРНУТО!\r\n            </div>\r\n            \r\n            <div class=\"info-grid\">\r\n              <div class=\"info-card\">\r\n                <strong>🌍 Environment</strong><br>\r\n                ${process.env.NODE_ENV || 'production'}\r\n              </div>\r\n              <div class=\"info-card\">\r\n                <strong>🔌 Port</strong><br>\r\n                ${process.env.PORT || 8000}\r\n              </div>\r\n              <div class=\"info-card\">\r\n                <strong>🚂 Railway URL</strong><br>\r\n                ${process.env.RAILWAY_STATIC_URL || 'N/A'}\r\n              </div>\r\n              <div class=\"info-card\">\r\n                <strong>⏰ Deployed</strong><br>\r\n                ${new Date().toLocaleString('ru-RU')}\r\n              </div>\r\n            </div>\r\n            \r\n            <h2>🔗 Доступные API endpoints:</h2>\r\n            <div class=\"endpoint-list\">\r\n              <div class=\"endpoint\">GET /health</div>\r\n              <div class=\"endpoint\">GET /</div>\r\n              <div class=\"endpoint\">GET /docs</div>\r\n              <div class=\"endpoint\">GET /api/status</div>\r\n            </div>\r\n            \r\n            <div style=\"margin: 30px 0;\">\r\n              <a href=\"/health\" class=\"btn\">🏥 Health Check</a>\r\n              <a href=\"/docs\" class=\"btn\">📚 Documentation</a>\r\n              <a href=\"/api/status\" class=\"btn\">📊 System Status</a>\r\n            </div>\r\n            \r\n            <h2>🎯 Статус системы:</h2>\r\n            <div class=\"info-grid\">\r\n              <div class=\"info-card\">\r\n                <strong>✅ Сервер</strong><br>\r\n                Запущен и работает\r\n              </div>\r\n              <div class=\"info-card\">\r\n                <strong>🗄️ База данных</strong><br>\r\n                ${process.env.DATABASE_URL ? 'Настроена' : 'Не настроена'}\r\n              </div>\r\n              <div class=\"info-card\">\r\n                <strong>🔐 Аутентификация</strong><br>\r\n                ${process.env.JWT_SECRET ? 'Настроена' : 'Не настроена'}\r\n              </div>\r\n              <div class=\"info-card\">\r\n                <strong>🤖 Telegram Bot</strong><br>\r\n                ${process.env.TELEGRAM_BOT_TOKEN ? 'Настроен' : 'Не настроен'}\r\n              </div>\r\n            </div>\r\n            \r\n            <div class=\"footer\">\r\n              <strong>VHM24 - VendHub Manager 24/7</strong><br>\r\n              Railway Deployment - Version 1.0.0<br>\r\n              Uptime: ${Math.floor(process.uptime())} seconds\r\n            </div>\r\n          </div>\r\n        </body>\r\n        </html>\r\n      `;\r\n    });\r\n\r\n    // API Documentation endpoint\r\n    fastify.get('/docs', async (request, reply) => {\r\n      reply.type('text/html');\r\n      return `\r\n        <!DOCTYPE html>\r\n        <html lang=\"ru\">\r\n        <head>\r\n          <meta charset=\"UTF-8\">\r\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n          <title>VHM24 API Documentation</title>\r\n          <style>\r\n            body { \r\n              font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n              margin: 40px; \r\n              background: #f5f5f5;\r\n              color: #333;\r\n            }\r\n            .container { max-width: 1000px; margin: 0 auto; background: white; padding: 40px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }\r\n            .endpoint { \r\n              margin: 20px 0; \r\n              padding: 20px; \r\n              border: 1px solid #ddd; \r\n              border-radius: 8px;\r\n              background: #fafafa;\r\n            }\r\n            .method { \r\n              font-weight: bold; \r\n              color: #007bff; \r\n              font-family: 'Courier New', monospace;\r\n              background: #e3f2fd;\r\n              padding: 4px 8px;\r\n              border-radius: 4px;\r\n              display: inline-block;\r\n              margin-bottom: 10px;\r\n            }\r\n            .description { margin: 10px 0; }\r\n            .response { \r\n              background: #f8f9fa; \r\n              padding: 15px; \r\n              border-radius: 5px; \r\n              font-family: 'Courier New', monospace;\r\n              font-size: 0.9em;\r\n              margin-top: 10px;\r\n            }\r\n            h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }\r\n            h2 { color: #34495e; margin-top: 30px; }\r\n            .status { color: #27ae60; font-weight: bold; }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <div class=\"container\">\r\n            <h1>🤖 VHM24 API Documentation</h1>\r\n            <p><strong>VendHub Manager 24/7 - Railway API</strong></p>\r\n            \r\n            <h2>📋 Основные endpoints</h2>\r\n            \r\n            <div class=\"endpoint\">\r\n              <div class=\"method\">GET /</div>\r\n              <div class=\"description\">Главная страница с информацией о развертывании</div>\r\n              <div class=\"response\">Возвращает: HTML страницу с системной информацией</div>\r\n            </div>\r\n            \r\n            <div class=\"endpoint\">\r\n              <div class=\"method\">GET /health</div>\r\n              <div class=\"description\">Health check endpoint для мониторинга состояния сервиса</div>\r\n              <div class=\"response\">\r\n    Возвращает: JSON объект<br>\r\n    {<br>\r\n    &nbsp;&nbsp;\"status\": \"ok\",<br>\r\n    &nbsp;&nbsp;\"service\": \"vhm24-unified\",<br>\r\n    &nbsp;&nbsp;\"timestamp\": \"2025-07-10T02:10:00.000Z\",<br>\r\n    &nbsp;&nbsp;\"environment\": \"production\",<br>\r\n    &nbsp;&nbsp;\"port\": 8000,<br>\r\n    &nbsp;&nbsp;\"uptime\": 123.45,<br>\r\n    &nbsp;&nbsp;\"memory\": {...},<br>\r\n    &nbsp;&nbsp;\"database\": \"connected\"<br>\r\n    }\r\n              </div>\r\n            </div>\r\n            \r\n            <div class=\"endpoint\">\r\n              <div class=\"method\">GET /docs</div>\r\n              <div class=\"description\">Эта страница документации API</div>\r\n              <div class=\"response\">Возвращает: HTML страницу с документацией</div>\r\n            </div>\r\n            \r\n            <div class=\"endpoint\">\r\n              <div class=\"method\">GET /api/status</div>\r\n              <div class=\"description\">Расширенная информация о статусе системы</div>\r\n              <div class=\"response\">Возвращает: JSON с детальной информацией о системе</div>\r\n            </div>\r\n            \r\n            <h2>📊 Системная информация</h2>\r\n            <div class=\"endpoint\">\r\n              <p><strong>Статус:</strong> <span class=\"status\">Railway deployment успешен</span></p>\r\n              <p><strong>Environment:</strong> ${process.env.NODE_ENV || 'production'}</p>\r\n              <p><strong>Version:</strong> 1.0.0</p>\r\n              <p><strong>Port:</strong> ${process.env.PORT || 8000}</p>\r\n              <p><strong>Uptime:</strong> ${Math.floor(process.uptime())} секунд</p>\r\n            </div>\r\n            \r\n            <h2>🔧 Конфигурация</h2>\r\n            <div class=\"endpoint\">\r\n              <p><strong>База данных:</strong> ${process.env.DATABASE_URL ? '✅ Настроена' : '❌ Не настроена'}</p>\r\n              <p><strong>JWT Secret:</strong> ${process.env.JWT_SECRET ? '✅ Настроен' : '❌ Не настроен'}</p>\r\n              <p><strong>Telegram Bot:</strong> ${process.env.TELEGRAM_BOT_TOKEN ? '✅ Настроен' : '❌ Не настроен'}</p>\r\n              <p><strong>Redis:</strong> ${process.env.REDIS_URL ? '✅ Настроен' : '❌ Не настроен'}</p>\r\n            </div>\r\n            \r\n            <div style=\"margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; text-align: center; color: #666;\">\r\n              <p>VHM24 - VendHub Manager 24/7 | Railway API</p>\r\n            </div>\r\n          </div>\r\n        </body>\r\n        </html>\r\n      `;\r\n    });\r\n\r\n    // System status API endpoint\r\n    fastify.get('/api/status', async (request, reply) => {\r\n      const status = {\r\n        service: 'vhm24-unified',\r\n        status: 'running',\r\n        timestamp: new Date().toISOString(),\r\n        environment: process.env.NODE_ENV || 'production',\r\n        port: process.env.PORT || 8000,\r\n        uptime: process.uptime(),\r\n        memory: process.memoryUsage(),\r\n        version: '1.0.0',\r\n        railway: {\r\n          environment: process.env.RAILWAY_ENVIRONMENT || null,\r\n          static_url: process.env.RAILWAY_STATIC_URL || null,\r\n          deployment_id: process.env.RAILWAY_DEPLOYMENT_ID || null\r\n        },\r\n        configuration: {\r\n          database: !!process.env.DATABASE_URL,\r\n          jwt_secret: !!process.env.JWT_SECRET,\r\n          telegram_bot: !!process.env.TELEGRAM_BOT_TOKEN,\r\n          redis: !!process.env.REDIS_URL,\r\n          admin_ids: !!process.env.ADMIN_IDS\r\n        }\r\n      };\r\n\r\n      // Проверяем подключение к базе данных\r\n      if (process.env.DATABASE_URL) {\r\n        try {\r\n          const { PrismaClient } = require('@prisma/client');\r\n          const prisma = new PrismaClient();\r\n          await prisma.$queryRaw`SELECT 1`;\r\n          await prisma.$disconnect();\r\n          status.database = { status: 'connected', error: null };\r\n        } catch (error) {\r\n          status.database = { status: 'error', error: error.message };\r\n        }\r\n      } else {\r\n        status.database = { status: 'not_configured', error: null };\r\n      }\r\n\r\n      return status;\r\n    });\r\n\r\n    // Получаем prisma клиент для API endpoints\r\n    let apiPrisma;\r\n    try {\r\n      const { getPrismaClient } = require('./packages/database');\r\n      apiPrisma = getPrismaClient();\r\n    } catch (error) {\r\n      console.error('⚠️ Failed to initialize Prisma client for API:', error.message);\r\n      apiPrisma = null;\r\n    }\r\n\r\n    // Встраиваем основные API endpoints прямо в монолит\r\n    \r\n    // Auth endpoints\r\n    fastify.post('/api/v1/auth/login', async (request, reply) => {\r\n      try {\r\n        if (!apiPrisma) {\r\n          return reply.code(503).send({\r\n            success: false,\r\n            error: 'Database not available'\r\n          });\r\n        }\r\n\r\n        const { email, password } = request.body;\r\n        \r\n        if (!email || !password) {\r\n          return reply.code(400).send({\r\n            success: false,\r\n            error: 'Email and password are required'\r\n          });\r\n        }\r\n\r\n        const bcrypt = require('bcrypt');\r\n        const jwt = require('jsonwebtoken');\r\n        \r\n        const user = await apiPrisma.user.findUnique({\r\n          where: { email }\r\n        });\r\n\r\n        if (!user || !await bcrypt.compare(password, user.passwordHash)) {\r\n          return reply.code(401).send({\r\n            success: false,\r\n            error: 'Invalid credentials'\r\n          });\r\n        }\r\n\r\n        const token = jwt.sign(\r\n          { \r\n            id: user.id, \r\n            email: user.email, \r\n            roles: user.roles \r\n          },\r\n          process.env.JWT_SECRET || 'vhm24-secret-key',\r\n          { expiresIn: '24h' }\r\n        );\r\n\r\n        return {\r\n          success: true,\r\n          data: {\r\n            token,\r\n            user: {\r\n              id: user.id,\r\n              email: user.email,\r\n              name: user.name,\r\n              roles: user.roles\r\n            }\r\n          }\r\n        };\r\n      } catch (error) {\r\n        console.error('Login error:', error);\r\n        return reply.code(500).send({\r\n          success: false,\r\n          error: 'Internal server error'\r\n        });\r\n      }\r\n    });\r\n\r\n    // Dashboard stats\r\n    fastify.get('/api/v1/dashboard/stats', async (request, reply) => {\r\n      try {\r\n        if (!apiPrisma) {\r\n          return reply.code(503).send({\r\n            success: false,\r\n            error: 'Database not available'\r\n          });\r\n        }\r\n\r\n        const [\r\n          totalMachines,\r\n          onlineMachines,\r\n          totalTasks,\r\n          pendingTasks,\r\n          totalUsers,\r\n          activeUsers\r\n        ] = await Promise.all([\r\n          apiPrisma.machine.count(),\r\n          apiPrisma.machine.count({ where: { status: 'ONLINE' } }),\r\n          apiPrisma.task.count(),\r\n          apiPrisma.task.count({ where: { status: { in: ['CREATED', 'ASSIGNED'] } } }),\r\n          apiPrisma.user.count(),\r\n          apiPrisma.user.count({ where: { isActive: true } })\r\n        ]);\r\n\r\n        return {\r\n          success: true,\r\n          data: {\r\n            totalMachines,\r\n            onlineMachines,\r\n            totalTasks,\r\n            pendingTasks,\r\n            totalUsers,\r\n            activeUsers,\r\n            todayRevenue: 0,\r\n            totalRevenue: 0\r\n          }\r\n        };\r\n      } catch (error) {\r\n        console.error('Dashboard stats error:', error);\r\n        return reply.code(500).send({\r\n          success: false,\r\n          error: 'Failed to fetch dashboard stats'\r\n        });\r\n      }\r\n    });\r\n\r\n    // Machines endpoints\r\n    fastify.get('/api/v1/machines', async (request, reply) => {\r\n      try {\r\n        if (!apiPrisma) {\r\n          return reply.code(503).send({\r\n            success: false,\r\n            error: 'Database not available'\r\n          });\r\n        }\r\n\r\n        const machines = await apiPrisma.machine.findMany({\r\n          include: {\r\n            location: true\r\n          }\r\n        });\r\n\r\n        return {\r\n          success: true,\r\n          data: machines\r\n        };\r\n      } catch (error) {\r\n        console.error('Machines error:', error);\r\n        return reply.code(500).send({\r\n          success: false,\r\n          error: 'Failed to fetch machines'\r\n        });\r\n      }\r\n    });\r\n\r\n    // Inventory endpoints\r\n    fastify.get('/api/v1/inventory', async (request, reply) => {\r\n      try {\r\n        if (!apiPrisma) {\r\n          return reply.code(503).send({\r\n            success: false,\r\n            error: 'Database not available'\r\n          });\r\n        }\r\n\r\n        const inventory = await apiPrisma.inventoryItem.findMany();\r\n\r\n        return {\r\n          success: true,\r\n          data: inventory\r\n        };\r\n      } catch (error) {\r\n        console.error('Inventory error:', error);\r\n        return reply.code(500).send({\r\n          success: false,\r\n          error: 'Failed to fetch inventory'\r\n        });\r\n      }\r\n    });\r\n\r\n    // Tasks endpoints\r\n    fastify.get('/api/v1/tasks', async (request, reply) => {\r\n      try {\r\n        if (!apiPrisma) {\r\n          return reply.code(503).send({\r\n            success: false,\r\n            error: 'Database not available'\r\n          });\r\n        }\r\n\r\n        const tasks = await apiPrisma.task.findMany({\r\n          include: {\r\n            assignedTo: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                email: true\r\n              }\r\n            },\r\n            machine: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                code: true\r\n              }\r\n            }\r\n          }\r\n        });\r\n\r\n        return {\r\n          success: true,\r\n          data: tasks\r\n        };\r\n      } catch (error) {\r\n        console.error('Tasks error:', error);\r\n        return reply.code(500).send({\r\n          success: false,\r\n          error: 'Failed to fetch tasks'\r\n        });\r\n      }\r\n    });\r\n\r\n    // 404 handler\r\n    fastify.setNotFoundHandler(async (request, reply) => {\r\n      reply.code(404).type('application/json');\r\n      return {\r\n        error: 'Not Found',\r\n        message: `Route ${request.method}:${request.url} not found`,\r\n        statusCode: 404,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    });\r\n\r\n    // Error handler\r\n    fastify.setErrorHandler(async (error, request, reply) => {\r\n      fastify.log.error(error);\r\n      reply.code(500).type('application/json');\r\n      return {\r\n        error: 'Internal Server Error',\r\n        message: error.message,\r\n        statusCode: 500,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    });\r\n\r\n    // Запускаем Telegram Bot в фоне (если токен есть)\r\n    if (process.env.TELEGRAM_BOT_TOKEN && fs.existsSync('./services/telegram-bot/src/index.js')) {\r\n      setTimeout(() => {\r\n        console.log('🤖 Starting Telegram Bot...');\r\n        try {\r\n          require('./services/telegram-bot/src/index.js');\r\n          console.log('✅ Telegram Bot started successfully');\r\n        } catch (error) {\r\n          console.error('⚠️ Telegram Bot failed to start:', error.message);\r\n          console.log('⚠️ Continuing without Telegram Bot');\r\n        }\r\n      }, 3000);\r\n    }\r\n\r\n    // Запускаем сервер\r\n    const port = process.env.PORT || 8000;\r\n    await fastify.listen({ \r\n      port: port,\r\n      host: '0.0.0.0'\r\n    });\r\n    \r\n    console.log(`🎉 VHM24 Unified is running on port ${port}`);\r\n    console.log(`🌐 Health check: http://localhost:${port}/health`);\r\n    console.log(`📚 Documentation: http://localhost:${port}/docs`);\r\n    console.log(`📊 System status: http://localhost:${port}/api/status`);\r\n    \r\n    // Railway specific logging\r\n    if (process.env.RAILWAY_ENVIRONMENT) {\r\n      console.log('🚂 Running on Railway:', process.env.RAILWAY_STATIC_URL);\r\n      console.log('🔗 Public URL:', `https://${process.env.RAILWAY_STATIC_URL}`);\r\n    }\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Railway deployment failed:', error.message);\r\n    console.error('Stack trace:', error.stack);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Обработка сигналов\r\nprocess.on('SIGTERM', async () => {\r\n  console.log('🛑 Received SIGTERM, shutting down gracefully...');\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('SIGINT', async () => {\r\n  console.log('🛑 Received SIGINT, shutting down gracefully...');\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('uncaughtException', (error) => {\r\n  console.error('❌ Uncaught Exception:', error);\r\n  process.exit(1);\r\n});\r\n\r\nprocess.on('unhandledRejection', (reason, promise) => {\r\n  console.error('❌ Unhandled Rejection at:', promise, 'reason:', reason);\r\n  process.exit(1);\r\n});\r\n\r\n// Запускаем приложение\r\nstartRailwayApp();\r\n",
  "services/bunkers/src/index.js": "/**\r\n * VHM24 - VendHub Manager 24/7\r\n * Bunkers Service\r\n * Manages coffee bunkers (machine inventory) for 24/7 vending operations\r\n */\r\n\r\nrequire('dotenv').config({ path: require('path').join(__dirname, '../../../.env') });\r\nconst Fastify = require('fastify');\r\nconst cors = require('@fastify/cors');\r\nconst { getSharedClient } = require('@vhm24/database');\r\n\r\nconst fastify = Fastify({ logger: true });\r\nconst prisma = getSharedClient();\r\n\r\n// Register plugins\r\nfastify.register(cors, { origin: true });\r\n\r\n// Health check\r\nfastify.get('/health', async () => {\r\n  return { \r\n    status: 'ok', \r\n    service: 'bunkers',\r\n    description: 'VHM24 Bunkers Service - 24/7 Operation',\r\n    uptime: process.uptime()\r\n  };\r\n});\r\n\r\n// Get all machine inventory (bunkers) with filters\r\nfastify.get('/api/v1/bunkers', async (request, reply) => {\r\n  try {\r\n    const { machineId, itemId, needsRefill, page = 1, limit = 10 } = request.query;\r\n    \r\n    const where = {};\r\n    if (machineId) where.machineId = machineId;\r\n    if (itemId) where.itemId = itemId;\r\n    \r\n    // Get total count\r\n    const total = await prisma.machineInventory.count({ where });\r\n    \r\n    // Get paginated data\r\n    let bunkers = await prisma.machineInventory.findMany({\r\n      where,\r\n      include: {\r\n        machine: {\r\n          include: {\r\n            location: true\r\n          }\r\n        },\r\n        item: true\r\n      },\r\n      skip: (page - 1) * limit,\r\n      take: parseInt(limit),\r\n      orderBy: [\r\n        { machine: { code: 'asc' } },\r\n        { item: { name: 'asc' } }\r\n      ]\r\n    });\r\n\r\n    // Calculate fill percentage and filter if needed\r\n    bunkers = bunkers.map(bunker => {\r\n      const fillPercentage = bunker.maxQuantity > 0 \r\n        ? (bunker.quantity / bunker.maxQuantity) * 100 \r\n        : 0;\r\n      \r\n      return {\r\n        ...bunker,\r\n        fillPercentage,\r\n        needsRefill: fillPercentage < 20,\r\n        critical: fillPercentage < 10\r\n      };\r\n    });\r\n\r\n    // Filter for bunkers needing refill (для 24/7 мониторинга)\r\n    if (needsRefill === 'true') {\r\n      bunkers = bunkers.filter(bunker => bunker.needsRefill);\r\n    }\r\n\r\n    const criticalCount = bunkers.filter(b => b.critical).length;\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        items: bunkers,\r\n        total,\r\n        page: parseInt(page),\r\n        limit: parseInt(limit),\r\n        totalPages: Math.ceil(total / limit),\r\n        criticalCount,\r\n        message: criticalCount > 0 \r\n          ? `⚠️ ${criticalCount} bunkers critically low - 24/7 monitoring active!`\r\n          : '✅ All bunkers operational for 24/7 service'\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    return reply.code(500).send({ error: 'Failed to fetch bunkers' });\r\n  }\r\n});\r\n\r\n// Get bunker details\r\nfastify.get('/api/v1/bunkers/:machineId/:itemId', async (request, reply) => {\r\n  try {\r\n    const { machineId, itemId } = request.params;\r\n    \r\n    const bunker = await prisma.machineInventory.findUnique({\r\n      where: {\r\n        machineId_itemId: {\r\n          machineId,\r\n          itemId\r\n        }\r\n      },\r\n      include: {\r\n        machine: {\r\n          include: {\r\n            location: true\r\n          }\r\n        },\r\n        item: true\r\n      }\r\n    });\r\n\r\n    if (!bunker) {\r\n      return reply.code(404).send({ error: 'Bunker not found' });\r\n    }\r\n\r\n    // Get recent movements\r\n    const recentMovements = await prisma.stockMovement.findMany({\r\n      where: {\r\n        machineId,\r\n        itemId\r\n      },\r\n      orderBy: { createdAt: 'desc' },\r\n      take: 10,\r\n      include: {\r\n        user: {\r\n          select: {\r\n            name: true,\r\n            email: true\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    const fillPercentage = bunker.maxQuantity > 0 \r\n      ? (bunker.quantity / bunker.maxQuantity) * 100 \r\n      : 0;\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        ...bunker,\r\n        fillPercentage,\r\n        needsRefill: fillPercentage < 20,\r\n        critical: fillPercentage < 10,\r\n        recentMovements,\r\n        status: fillPercentage < 10 ? 'CRITICAL' : \r\n                fillPercentage < 20 ? 'LOW' : \r\n                fillPercentage < 50 ? 'MEDIUM' : 'GOOD'\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    return reply.code(500).send({ error: 'Failed to fetch bunker details' });\r\n  }\r\n});\r\n\r\n// Refill bunker\r\nfastify.post('/api/v1/bunkers/:machineId/:itemId/refill', async (request, reply) => {\r\n  try {\r\n    const { machineId, itemId } = request.params;\r\n    const { quantity, userId, notes } = request.body;\r\n    \r\n    // Get current bunker state\r\n    const bunker = await prisma.machineInventory.findUnique({\r\n      where: {\r\n        machineId_itemId: {\r\n          machineId,\r\n          itemId\r\n        }\r\n      },\r\n      include: {\r\n        item: true\r\n      }\r\n    });\r\n\r\n    if (!bunker) {\r\n      return reply.code(404).send({ error: 'Bunker not found' });\r\n    }\r\n\r\n    const quantityBefore = bunker.quantity;\r\n    const quantityAfter = Math.min(bunker.quantity + quantity, bunker.maxQuantity || quantity);\r\n    const actualQuantity = quantityAfter - quantityBefore;\r\n\r\n    // Update bunker\r\n    const updatedBunker = await prisma.machineInventory.update({\r\n      where: {\r\n        machineId_itemId: {\r\n          machineId,\r\n          itemId\r\n        }\r\n      },\r\n      data: {\r\n        quantity: quantityAfter,\r\n        lastRefill: new Date()\r\n      }\r\n    });\r\n\r\n    // Record stock movement\r\n    await prisma.stockMovement.create({\r\n      data: {\r\n        itemId,\r\n        userId,\r\n        type: 'IN',\r\n        quantity: actualQuantity,\r\n        quantityBefore,\r\n        quantityAfter,\r\n        reason: `Bunker refill - ${notes || 'Regular 24/7 maintenance'}`,\r\n        machineId\r\n      }\r\n    });\r\n\r\n    // Create service history\r\n    await prisma.serviceHistory.create({\r\n      data: {\r\n        machineId,\r\n        serviceType: 'REFILL',\r\n        description: `Refilled ${bunker.item?.name || 'Item'} - Added ${actualQuantity} ${bunker.item?.unit || 'units'}`,\r\n        performedById: userId,\r\n        performedAt: new Date(),\r\n        metadata: {\r\n          itemId,\r\n          quantityAdded: actualQuantity,\r\n          notes\r\n        }\r\n      }\r\n    });\r\n\r\n    fastify.log.info(`Bunker refilled - Machine: ${machineId}, Item: ${itemId}, Quantity: ${actualQuantity}`);\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        bunker: updatedBunker,\r\n        refillAmount: actualQuantity,\r\n        message: `✅ Bunker refilled successfully - Ready for 24/7 operation`\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    return reply.code(500).send({ error: 'Failed to refill bunker' });\r\n  }\r\n});\r\n\r\n// Get critical bunkers (low level)\r\nfastify.get('/api/v1/bunkers/critical', async (request, reply) => {\r\n  try {\r\n    const bunkers = await prisma.machineInventory.findMany({\r\n      include: {\r\n        machine: {\r\n          include: {\r\n            location: true\r\n          }\r\n        },\r\n        item: true\r\n      }\r\n    });\r\n\r\n    // Filter critical bunkers\r\n    const criticalBunkers = bunkers\r\n      .map(bunker => {\r\n        const fillPercentage = bunker.maxQuantity > 0 \r\n          ? (bunker.quantity / bunker.maxQuantity) * 100 \r\n          : 0;\r\n        \r\n        return {\r\n          ...bunker,\r\n          fillPercentage,\r\n          hoursRemaining: fillPercentage < 20 \r\n            ? Math.round((bunker.quantity / 10) * 24) // Estimate based on average consumption\r\n            : null\r\n        };\r\n      })\r\n      .filter(bunker => bunker.fillPercentage < 20)\r\n      .sort((a, b) => a.fillPercentage - b.fillPercentage);\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        critical: criticalBunkers.filter(b => b.fillPercentage < 10),\r\n        low: criticalBunkers.filter(b => b.fillPercentage >= 10 && b.fillPercentage < 20),\r\n        totalCritical: criticalBunkers.length,\r\n        message: criticalBunkers.length > 0 \r\n          ? `⚠️ ${criticalBunkers.length} bunkers need urgent attention for 24/7 operation!`\r\n          : '✅ All bunkers have sufficient levels for 24/7 operation'\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    return reply.code(500).send({ error: 'Failed to fetch critical bunkers' });\r\n  }\r\n});\r\n\r\n// Bunker consumption report\r\nfastify.get('/api/v1/bunkers/consumption-report', async (request, reply) => {\r\n  try {\r\n    const { machineId, itemId, days = 7 } = request.query;\r\n    \r\n    const startDate = new Date();\r\n    startDate.setDate(startDate.getDate() - days);\r\n    \r\n    const where = {\r\n      type: 'OUT',\r\n      createdAt: { gte: startDate }\r\n    };\r\n    \r\n    if (machineId) where.machineId = machineId;\r\n    if (itemId) where.itemId = itemId;\r\n    \r\n    const movements = await prisma.stockMovement.findMany({\r\n      where,\r\n      include: {\r\n        machine: true,\r\n        item: true\r\n      },\r\n      orderBy: { createdAt: 'desc' }\r\n    });\r\n    \r\n    // Group by machine and item\r\n    const consumption = {};\r\n    movements.forEach(movement => {\r\n      const key = `${movement.machineId}-${movement.itemId}`;\r\n      if (!consumption[key]) {\r\n        consumption[key] = {\r\n          machine: movement.machine,\r\n          item: movement.item,\r\n          totalConsumed: 0,\r\n          movements: []\r\n        };\r\n      }\r\n      consumption[key].totalConsumed += movement.quantity;\r\n      consumption[key].movements.push(movement);\r\n    });\r\n    \r\n    return {\r\n      success: true,\r\n      data: {\r\n        period: `Last ${days} days`,\r\n        startDate,\r\n        endDate: new Date(),\r\n        consumption: Object.values(consumption),\r\n        totalMovements: movements.length\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    return reply.code(500).send({ error: 'Failed to generate consumption report' });\r\n  }\r\n});\r\n\r\n// Start server\r\nconst start = async () => {\r\n  try {\r\n    await fastify.listen({ \r\n      port: process.env.BUNKERS_PORT || 3005,\r\n      host: '0.0.0.0'\r\n    });\r\n    console.log('VHM24 Bunkers Service running 24/7 on port', process.env.BUNKERS_PORT || 3005);\r\n  } catch (err) {\r\n    fastify.log.error(err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\nstart();\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGTERM', async () => {\r\n  await fastify.close();\r\n  await prisma.$disconnect();\r\n  process.exit(0);\r\n});\r\n",
  "services/data-import/src/index.js": "const fastify = require('fastify')({ logger: true });\r\nconst path = require('path');\r\nconst fs = require('fs');\r\nconst csv = require('csv-parser');\r\nconst XLSX = require('xlsx');\r\nconst moment = require('moment');\r\n\r\n// Регистрация плагинов\r\nfastify.register(require('@fastify/cors'), {\r\n  origin: true,\r\n  credentials: true\r\n});\r\n\r\nfastify.register(require('@fastify/multipart'), {\r\n  limits: {\r\n    fileSize: 100 * 1024 * 1024, // 100MB\r\n  }\r\n});\r\n\r\nfastify.register(require('@fastify/static'), {\r\n  root: path.join(__dirname, '../templates'),\r\n  prefix: '/templates/',\r\n});\r\n\r\n// Хранилище для задач импорта (в production использовать Redis/Database)\r\nconst importJobs = new Map();\r\nlet jobIdCounter = 1;\r\n\r\n// Схемы данных для валидации\r\nconst dataSchemas = {\r\n  SALES: {\r\n    required: ['date', 'time', 'machine_id', 'product_id', 'quantity', 'amount'],\r\n    optional: ['customer_id', 'payment_method', 'discount']\r\n  },\r\n  INVENTORY: {\r\n    required: ['date', 'time', 'item_id', 'quantity', 'location'],\r\n    optional: ['batch_number', 'expiry_date', 'supplier_id']\r\n  },\r\n  MAINTENANCE: {\r\n    required: ['date', 'time', 'machine_id', 'type', 'description', 'technician_id'],\r\n    optional: ['parts_used', 'cost', 'duration', 'next_maintenance']\r\n  },\r\n  ROUTES: {\r\n    required: ['date', 'time', 'driver_id', 'route_name', 'start_location', 'end_location'],\r\n    optional: ['distance', 'duration', 'fuel_consumption', 'stops']\r\n  },\r\n  USERS: {\r\n    required: ['username', 'first_name', 'last_name', 'role', 'created_date'],\r\n    optional: ['email', 'phone', 'telegram_username', 'status']\r\n  },\r\n  TASKS: {\r\n    required: ['date', 'time', 'title', 'type', 'assigned_to', 'status', 'description'],\r\n    optional: ['priority', 'machine_id', 'estimated_duration', 'actual_duration']\r\n  }\r\n};\r\n\r\n// Генерация шаблонов CSV\r\nconst generateTemplate = (dataType) => {\r\n  const schema = dataSchemas[dataType];\r\n  if (!schema) {\r\n    throw new Error(`Unknown data type: ${dataType}`);\r\n  }\r\n\r\n  const headers = [...schema.required, ...schema.optional];\r\n  const sampleData = generateSampleData(dataType);\r\n  \r\n  let csv = headers.join(',') + '\\n';\r\n  csv += sampleData.map(row => headers.map(header => row[header] || '').join(',')).join('\\n');\r\n  \r\n  return csv;\r\n};\r\n\r\n// Генерация примеров данных\r\nconst generateSampleData = (dataType) => {\r\n  const baseDate = moment().subtract(30, 'days');\r\n  \r\n  switch (dataType) {\r\n    case 'SALES':\r\n      return [\r\n        {\r\n          date: baseDate.format('YYYY-MM-DD'),\r\n          time: '10:30:00',\r\n          machine_id: 'VM001',\r\n          product_id: 'PROD001',\r\n          quantity: '2',\r\n          amount: '150.00',\r\n          customer_id: 'CUST001',\r\n          payment_method: 'CARD'\r\n        },\r\n        {\r\n          date: baseDate.add(1, 'day').format('YYYY-MM-DD'),\r\n          time: '14:15:00',\r\n          machine_id: 'VM002',\r\n          product_id: 'PROD002',\r\n          quantity: '1',\r\n          amount: '85.00',\r\n          payment_method: 'CASH'\r\n        }\r\n      ];\r\n    \r\n    case 'INVENTORY':\r\n      return [\r\n        {\r\n          date: baseDate.format('YYYY-MM-DD'),\r\n          time: '09:00:00',\r\n          item_id: 'ITEM001',\r\n          quantity: '50',\r\n          location: 'WAREHOUSE_A',\r\n          batch_number: 'BATCH001',\r\n          supplier_id: 'SUP001'\r\n        },\r\n        {\r\n          date: baseDate.add(1, 'day').format('YYYY-MM-DD'),\r\n          time: '16:30:00',\r\n          item_id: 'ITEM002',\r\n          quantity: '25',\r\n          location: 'WAREHOUSE_B',\r\n          batch_number: 'BATCH002'\r\n        }\r\n      ];\r\n    \r\n    case 'MAINTENANCE':\r\n      return [\r\n        {\r\n          date: baseDate.format('YYYY-MM-DD'),\r\n          time: '08:00:00',\r\n          machine_id: 'VM001',\r\n          type: 'PREVENTIVE',\r\n          description: 'Routine maintenance check',\r\n          technician_id: 'TECH001',\r\n          duration: '120',\r\n          cost: '500.00'\r\n        }\r\n      ];\r\n    \r\n    case 'ROUTES':\r\n      return [\r\n        {\r\n          date: baseDate.format('YYYY-MM-DD'),\r\n          time: '07:00:00',\r\n          driver_id: 'DRV001',\r\n          route_name: 'Route A',\r\n          start_location: 'Warehouse',\r\n          end_location: 'Mall District',\r\n          distance: '25.5',\r\n          duration: '180'\r\n        }\r\n      ];\r\n    \r\n    case 'USERS':\r\n      return [\r\n        {\r\n          username: 'john.doe',\r\n          first_name: 'John',\r\n          last_name: 'Doe',\r\n          role: 'OPERATOR',\r\n          created_date: baseDate.format('YYYY-MM-DD'),\r\n          email: 'john.doe@example.com',\r\n          status: 'ACTIVE'\r\n        }\r\n      ];\r\n    \r\n    case 'TASKS':\r\n      return [\r\n        {\r\n          date: baseDate.format('YYYY-MM-DD'),\r\n          time: '09:00:00',\r\n          title: 'Refill Machine VM001',\r\n          type: 'REFILL',\r\n          assigned_to: 'TECH001',\r\n          status: 'COMPLETED',\r\n          description: 'Refill products in machine VM001',\r\n          priority: 'HIGH',\r\n          estimated_duration: '60'\r\n        }\r\n      ];\r\n    \r\n    default:\r\n      return [];\r\n  }\r\n};\r\n\r\n// Парсинг файлов\r\nconst parseFile = async (filePath, dataType) => {\r\n  const ext = path.extname(filePath).toLowerCase();\r\n  let data = [];\r\n\r\n  try {\r\n    if (ext === '.csv') {\r\n      data = await parseCSV(filePath);\r\n    } else if (ext === '.xlsx' || ext === '.xls') {\r\n      data = await parseExcel(filePath);\r\n    } else if (ext === '.json') {\r\n      data = await parseJSON(filePath);\r\n    } else {\r\n      throw new Error(`Unsupported file format: ${ext}`);\r\n    }\r\n\r\n    // Валидация данных\r\n    const validationResult = validateData(data, dataType);\r\n    return validationResult;\r\n  } catch (error) {\r\n    throw new Error(`Error parsing file: ${error.message}`);\r\n  }\r\n};\r\n\r\nconst parseCSV = (filePath) => {\r\n  return new Promise((resolve, reject) => {\r\n    const results = [];\r\n    fs.createReadStream(filePath)\r\n      .pipe(csv())\r\n      .on('data', (data) => results.push(data))\r\n      .on('end', () => resolve(results))\r\n      .on('error', reject);\r\n  });\r\n};\r\n\r\nconst parseExcel = (filePath) => {\r\n  const workbook = XLSX.readFile(filePath);\r\n  const sheetName = workbook.SheetNames[0];\r\n  const worksheet = workbook.Sheets[sheetName];\r\n  return XLSX.utils.sheet_to_json(worksheet);\r\n};\r\n\r\nconst parseJSON = (filePath) => {\r\n  const content = fs.readFileSync(filePath, 'utf8');\r\n  return JSON.parse(content);\r\n};\r\n\r\n// Валидация данных\r\nconst validateData = (data, dataType) => {\r\n  const schema = dataSchemas[dataType];\r\n  const errors = [];\r\n  const validRecords = [];\r\n\r\n  data.forEach((record, index) => {\r\n    const recordErrors = [];\r\n    \r\n    // Проверка обязательных полей\r\n    schema.required.forEach(field => {\r\n      if (!record[field] || record[field].toString().trim() === '') {\r\n        recordErrors.push(`Missing required field: ${field}`);\r\n      }\r\n    });\r\n\r\n    // Валидация даты и времени\r\n    if (record.date && !moment(record.date, 'YYYY-MM-DD', true).isValid()) {\r\n      recordErrors.push(`Invalid date format: ${record.date}. Expected: YYYY-MM-DD`);\r\n    }\r\n    \r\n    if (record.time && !moment(record.time, 'HH:mm:ss', true).isValid()) {\r\n      recordErrors.push(`Invalid time format: ${record.time}. Expected: HH:mm:ss`);\r\n    }\r\n\r\n    // Специфичная валидация по типу данных\r\n    if (dataType === 'SALES') {\r\n      if (record.amount && isNaN(parseFloat(record.amount))) {\r\n        recordErrors.push(`Invalid amount: ${record.amount}`);\r\n      }\r\n      if (record.quantity && isNaN(parseInt(record.quantity))) {\r\n        recordErrors.push(`Invalid quantity: ${record.quantity}`);\r\n      }\r\n    }\r\n\r\n    if (recordErrors.length > 0) {\r\n      errors.push(`Row ${index + 1}: ${recordErrors.join(', ')}`);\r\n    } else {\r\n      validRecords.push({\r\n        ...record,\r\n        originalIndex: index + 1,\r\n        importedAt: new Date().toISOString()\r\n      });\r\n    }\r\n  });\r\n\r\n  return {\r\n    totalRecords: data.length,\r\n    validRecords,\r\n    errorRecords: errors.length,\r\n    errors\r\n  };\r\n};\r\n\r\n// Обработка импорта\r\nconst processImport = async (jobId) => {\r\n  const job = importJobs.get(jobId);\r\n  if (!job) return;\r\n\r\n  try {\r\n    job.status = 'PROCESSING';\r\n    job.startedAt = new Date().toISOString();\r\n\r\n    const result = await parseFile(job.filePath, job.dataType);\r\n    \r\n    // Симуляция обработки записей\r\n    for (let i = 0; i < result.validRecords.length; i++) {\r\n      // Здесь будет сохранение в базу данных\r\n      await new Promise(resolve => setTimeout(resolve, 100)); // Симуляция задержки\r\n      job.processedRecords = i + 1;\r\n    }\r\n\r\n    job.status = 'COMPLETED';\r\n    job.completedAt = new Date().toISOString();\r\n    job.totalRecords = result.totalRecords;\r\n    job.errorRecords = result.errorRecords;\r\n    job.errors = result.errors;\r\n\r\n    // Удаление временного файла\r\n    fs.unlinkSync(job.filePath);\r\n    \r\n  } catch (error) {\r\n    job.status = 'FAILED';\r\n    job.errors = [error.message];\r\n    job.completedAt = new Date().toISOString();\r\n  }\r\n};\r\n\r\n// API Routes\r\n\r\n// Получение списка задач импорта\r\nfastify.get('/api/v1/data-import/jobs', async (request, reply) => {\r\n  const jobs = Array.from(importJobs.values()).sort((a, b) => \r\n    new Date(b.createdAt) - new Date(a.createdAt)\r\n  );\r\n  \r\n  return {\r\n    success: true,\r\n    data: jobs\r\n  };\r\n});\r\n\r\n// Получение исторических данных\r\nfastify.get('/api/v1/data-import/historical', async (request, reply) => {\r\n  // В production здесь будет запрос к базе данных\r\n  return {\r\n    success: true,\r\n    data: []\r\n  };\r\n});\r\n\r\n// Предварительный просмотр файла\r\nfastify.post('/api/v1/data-import/preview', async (request, reply) => {\r\n  try {\r\n    const data = await request.file();\r\n    const dataType = request.body?.dataType || 'SALES';\r\n    \r\n    if (!data) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'No file uploaded'\r\n      });\r\n    }\r\n\r\n    // Сохранение временного файла\r\n    const tempPath = path.join(__dirname, '../temp', `preview_${Date.now()}_${data.filename}`);\r\n    await data.file.pipe(fs.createWriteStream(tempPath));\r\n\r\n    // Парсинг первых 10 записей для предварительного просмотра\r\n    const result = await parseFile(tempPath, dataType);\r\n    const preview = result.validRecords.slice(0, 10);\r\n\r\n    // Удаление временного файла\r\n    fs.unlinkSync(tempPath);\r\n\r\n    return {\r\n      success: true,\r\n      preview,\r\n      totalRecords: result.totalRecords,\r\n      errors: result.errors.slice(0, 5) // Показать только первые 5 ошибок\r\n    };\r\n  } catch (error) {\r\n    return reply.code(500).send({\r\n      success: false,\r\n      error: error.message\r\n    });\r\n  }\r\n});\r\n\r\n// Загрузка файла для импорта\r\nfastify.post('/api/v1/data-import/upload', async (request, reply) => {\r\n  try {\r\n    const data = await request.file();\r\n    const { dataType, startDate, endDate } = request.body;\r\n    \r\n    if (!data) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'No file uploaded'\r\n      });\r\n    }\r\n\r\n    // Создание задачи импорта\r\n    const jobId = jobIdCounter++;\r\n    const tempPath = path.join(__dirname, '../temp', `import_${jobId}_${data.filename}`);\r\n    \r\n    // Создание директории temp если не существует\r\n    const tempDir = path.dirname(tempPath);\r\n    if (!fs.existsSync(tempDir)) {\r\n      fs.mkdirSync(tempDir, { recursive: true });\r\n    }\r\n\r\n    await data.file.pipe(fs.createWriteStream(tempPath));\r\n\r\n    const job = {\r\n      id: jobId,\r\n      fileName: data.filename,\r\n      fileSize: fs.statSync(tempPath).size,\r\n      dataType,\r\n      status: 'PENDING',\r\n      totalRecords: 0,\r\n      processedRecords: 0,\r\n      errorRecords: 0,\r\n      startDate,\r\n      endDate,\r\n      createdAt: new Date().toISOString(),\r\n      filePath: tempPath,\r\n      errors: []\r\n    };\r\n\r\n    importJobs.set(jobId, job);\r\n\r\n    // Запуск обработки в фоне\r\n    setImmediate(() => processImport(jobId));\r\n\r\n    return {\r\n      success: true,\r\n      job: {\r\n        id: job.id,\r\n        fileName: job.fileName,\r\n        fileSize: job.fileSize,\r\n        dataType: job.dataType,\r\n        status: job.status,\r\n        createdAt: job.createdAt\r\n      }\r\n    };\r\n  } catch (error) {\r\n    return reply.code(500).send({\r\n      success: false,\r\n      error: error.message\r\n    });\r\n  }\r\n});\r\n\r\n// Скачивание шаблона\r\nfastify.get('/api/v1/data-import/template/:dataType', async (request, reply) => {\r\n  try {\r\n    const { dataType } = request.params;\r\n    \r\n    if (!dataSchemas[dataType]) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: `Unknown data type: ${dataType}`\r\n      });\r\n    }\r\n\r\n    const template = generateTemplate(dataType);\r\n    \r\n    reply\r\n      .header('Content-Type', 'text/csv')\r\n      .header('Content-Disposition', `attachment; filename=\"${dataType.toLowerCase()}_template.csv\"`)\r\n      .send(template);\r\n  } catch (error) {\r\n    return reply.code(500).send({\r\n      success: false,\r\n      error: error.message\r\n    });\r\n  }\r\n});\r\n\r\n// Получение деталей задачи\r\nfastify.get('/api/v1/data-import/jobs/:jobId', async (request, reply) => {\r\n  const { jobId } = request.params;\r\n  const job = importJobs.get(parseInt(jobId));\r\n  \r\n  if (!job) {\r\n    return reply.code(404).send({\r\n      success: false,\r\n      error: 'Job not found'\r\n    });\r\n  }\r\n\r\n  return {\r\n    success: true,\r\n    data: job\r\n  };\r\n});\r\n\r\n// Health check\r\nfastify.get('/health', async (request, reply) => {\r\n  return { status: 'ok', service: 'data-import', timestamp: new Date().toISOString() };\r\n});\r\n\r\n// Запуск сервера\r\nconst start = async () => {\r\n  try {\r\n    const port = process.env.PORT || 3009;\r\n    const host = process.env.HOST || '0.0.0.0';\r\n    \r\n    await fastify.listen({ port, host });\r\n    console.log(`🚀 Data Import Service running on http://${host}:${port}`);\r\n  } catch (err) {\r\n    fastify.log.error(err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\nstart();\r\n",
  "fix-prisma-imports.js": "/**\r\n * VHM24 - Fix Prisma Imports Script\r\n * Replaces direct @prisma/client imports with centralized database clients\r\n */\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n// Service to client mapping\r\nconst serviceClientMap = {\r\n  'auth': 'getAuthClient',\r\n  'machines': 'getMachinesClient',\r\n  'inventory': 'getInventoryClient',\r\n  'tasks': 'getTasksClient',\r\n  'bunkers': 'getSharedClient', // Bunkers uses shared client\r\n  'gateway': 'getPrismaClient', // Gateway uses main client\r\n  'telegram-bot': 'getPrismaClient' // Bot uses main client\r\n};\r\n\r\n// Files to check and fix\r\nconst servicePaths = [\r\n  'services/machines/src/index.js',\r\n  'services/inventory/src/index.js',\r\n  'services/tasks/src/index.js',\r\n  'services/bunkers/src/index.js',\r\n  'services/telegram-bot/src/index.js',\r\n  'services/telegram-bot/src/handlers/inventoryHandler.js',\r\n  'services/telegram-bot/src/handlers/machinesHandler.js',\r\n  'services/telegram-bot/src/handlers/tasksHandler.js',\r\n  'services/telegram-bot/src/handlers/reportsHandler.js',\r\n  'services/telegram-bot/src/utils/auth.js'\r\n];\r\n\r\nconsole.log('🔧 Fixing Prisma imports in VHM24 services...\\n');\r\n\r\nlet fixedCount = 0;\r\nlet errorCount = 0;\r\n\r\nservicePaths.forEach(filePath => {\r\n  if (!fs.existsSync(filePath)) {\r\n    console.log(`⏭️  Skipped (not found): ${filePath}`);\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    let content = fs.readFileSync(filePath, 'utf8');\r\n    const originalContent = content;\r\n    \r\n    // Determine which client to use based on service\r\n    const serviceName = filePath.split('/')[1];\r\n    const clientFunction = serviceClientMap[serviceName] || 'getPrismaClient';\r\n    \r\n    // Pattern to match Prisma imports\r\n    const prismaImportPattern = /const\\s*{\\s*PrismaClient\\s*}\\s*=\\s*require\\s*\\(\\s*['\"]@prisma\\/client['\"]\\s*\\)\\s*;?\\s*\\n\\s*const\\s+(\\w+)\\s*=\\s*new\\s+PrismaClient\\s*\\(\\s*\\)\\s*;?/g;\r\n    const simplePrismaPattern = /const\\s+(\\w+)\\s*=\\s*new\\s+PrismaClient\\s*\\(\\s*\\)\\s*;?/g;\r\n    \r\n    // Check if file has direct Prisma import\r\n    if (content.includes('@prisma/client') || content.includes('new PrismaClient')) {\r\n      // Replace the import and instantiation\r\n      content = content.replace(prismaImportPattern, (match, varName) => {\r\n        return `const { ${clientFunction} } = require('@vhm24/database');\\nconst ${varName} = ${clientFunction}();`;\r\n      });\r\n      \r\n      // Also handle cases where PrismaClient might be imported elsewhere\r\n      if (content.includes(\"require('@prisma/client')\")) {\r\n        content = content.replace(\r\n          /const\\s*{\\s*PrismaClient\\s*}\\s*=\\s*require\\s*\\(\\s*['\"]@prisma\\/client['\"]\\s*\\)\\s*;?/g,\r\n          `const { ${clientFunction} } = require('@vhm24/database');`\r\n        );\r\n        \r\n        content = content.replace(simplePrismaPattern, (match, varName) => {\r\n          return `const ${varName} = ${clientFunction}();`;\r\n        });\r\n      }\r\n      \r\n      // If content changed, write it back\r\n      if (content !== originalContent) {\r\n        fs.writeFileSync(filePath, content, 'utf8');\r\n        console.log(`✅ Fixed: ${filePath} (using ${clientFunction})`);\r\n        fixedCount++;\r\n      } else {\r\n        console.log(`ℹ️  Already fixed or no changes needed: ${filePath}`);\r\n      }\r\n    } else {\r\n      console.log(`✓ No Prisma imports found: ${filePath}`);\r\n    }\r\n  } catch (error) {\r\n    console.error(`❌ Error processing ${filePath}: ${error.message}`);\r\n    errorCount++;\r\n  }\r\n});\r\n\r\nconsole.log('\\n📊 Summary:');\r\nconsole.log(`- Files fixed: ${fixedCount}`);\r\nconsole.log(`- Errors: ${errorCount}`);\r\nconsole.log(`- Total files checked: ${servicePaths.length}`);\r\n\r\nif (fixedCount > 0) {\r\n  console.log('\\n⚠️  Important: Make sure to run \"npm install\" in the root directory to ensure all dependencies are installed.');\r\n}\r\n\r\nconsole.log('\\n✨ Prisma import fix complete!');\r\n",
  "services/inventory/src/index.js": "require('dotenv').config({ path: require('path').join(__dirname, '../../../.env') });\r\nconst Fastify = require('fastify');\r\nconst cors = require('@fastify/cors');\r\nconst jwt = require('@fastify/jwt');\r\nconst { getInventoryClient } = require('@vhm24/database');\nconst prisma = getInventoryClient();\r\nconst fastify = Fastify({ logger: true });\r\n\r\n// Plugins\r\nfastify.register(cors, {\r\n  origin: true,\r\n  credentials: true\r\n});\r\n\r\nfastify.register(jwt, {\r\n  secret: process.env.JWT_SECRET || 'your-secret-key'\r\n});\r\n\r\n// Декоратор для проверки авторизации\r\nfastify.decorate('authenticate', async function(request, reply) {\r\n  try {\r\n    await request.jwtVerify();\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: request.user.id },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        roles: true,\r\n        isActive: true\r\n      }\r\n    });\r\n    \r\n    if (!user || !user.isActive) {\r\n      throw new Error('User not found or inactive');\r\n    }\r\n    \r\n    request.user = user;\r\n  } catch (err) {\r\n    reply.code(401).send({ \r\n      success: false,\r\n      error: 'Unauthorized',\r\n      message: err.message || 'Invalid or expired token'\r\n    });\r\n  }\r\n});\r\n\r\n// Health check\r\nfastify.get('/health', async (request, reply) => {\r\n  return { status: 'ok', service: 'inventory' };\r\n});\r\n\r\n// Получить все товары/ингредиенты\r\nfastify.get('/api/v1/inventory/items', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    querystring: {\r\n      type: 'object',\r\n      properties: {\r\n        category: { type: 'string' },\r\n        search: { type: 'string' },\r\n        inStock: { type: 'boolean' },\r\n        skip: { type: 'integer', minimum: 0, default: 0 },\r\n        take: { type: 'integer', minimum: 1, maximum: 100, default: 20 }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { category, search, inStock, skip, take } = request.query;\r\n  \r\n  try {\r\n    const where = {};\r\n    \r\n    if (category) where.category = category;\r\n    if (search) {\r\n      where.OR = [\r\n        { name: { contains: search, mode: 'insensitive' } },\r\n        { sku: { contains: search, mode: 'insensitive' } }\r\n      ];\r\n    }\r\n    if (inStock !== undefined) {\r\n      where.quantity = inStock ? { gt: 0 } : { lte: 0 };\r\n    }\r\n\r\n    const [items, total] = await Promise.all([\r\n      prisma.inventoryItem.findMany({\r\n        where,\r\n        skip,\r\n        take,\r\n        orderBy: { name: 'asc' },\r\n        include: {\r\n          stockMovements: {\r\n            take: 5,\r\n            orderBy: { createdAt: 'desc' }\r\n          }\r\n        }\r\n      }),\r\n      prisma.inventoryItem.count({ where })\r\n    ]);\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        items,\r\n        total,\r\n        skip,\r\n        take\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch inventory items'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить товар по ID\r\nfastify.get('/api/v1/inventory/items/:id', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  const { id } = request.params;\r\n  \r\n  try {\r\n    const item = await prisma.inventoryItem.findUnique({\r\n      where: { id },\r\n      include: {\r\n        stockMovements: {\r\n          orderBy: { createdAt: 'desc' },\r\n          include: {\r\n            user: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                email: true\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (!item) {\r\n      return reply.code(404).send({\r\n        success: false,\r\n        error: 'Item not found'\r\n      });\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      data: item\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch item'\r\n    });\r\n  }\r\n});\r\n\r\n// Создать новый товар\r\nfastify.post('/api/v1/inventory/items', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['name', 'sku', 'unit', 'category'],\r\n      properties: {\r\n        name: { type: 'string', minLength: 1 },\r\n        sku: { type: 'string', minLength: 1 },\r\n        unit: { type: 'string', enum: ['KG', 'L', 'PCS', 'PACK'] },\r\n        category: { type: 'string' },\r\n        description: { type: 'string' },\r\n        minQuantity: { type: 'number', minimum: 0 },\r\n        maxQuantity: { type: 'number', minimum: 0 },\r\n        price: { type: 'number', minimum: 0 }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const data = request.body;\r\n  \r\n  try {\r\n    // Проверяем уникальность SKU\r\n    const existing = await prisma.inventoryItem.findUnique({\r\n      where: { sku: data.sku }\r\n    });\r\n\r\n    if (existing) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'SKU already exists'\r\n      });\r\n    }\r\n\r\n    const item = await prisma.inventoryItem.create({\r\n      data: {\r\n        ...data,\r\n        quantity: 0, // Начальное количество всегда 0\r\n        lastUpdated: new Date()\r\n      }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: item\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to create item'\r\n    });\r\n  }\r\n});\r\n\r\n// Обновить товар\r\nfastify.patch('/api/v1/inventory/items/:id', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    params: {\r\n      type: 'object',\r\n      properties: {\r\n        id: { type: 'string' }\r\n      }\r\n    },\r\n    body: {\r\n      type: 'object',\r\n      properties: {\r\n        name: { type: 'string', minLength: 1 },\r\n        description: { type: 'string' },\r\n        minQuantity: { type: 'number', minimum: 0 },\r\n        maxQuantity: { type: 'number', minimum: 0 },\r\n        price: { type: 'number', minimum: 0 }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { id } = request.params;\r\n  const updates = request.body;\r\n  \r\n  try {\r\n    const item = await prisma.inventoryItem.update({\r\n      where: { id },\r\n      data: {\r\n        ...updates,\r\n        lastUpdated: new Date()\r\n      }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: item\r\n    };\r\n  } catch (error) {\r\n    if (error.code === 'P2025') {\r\n      return reply.code(404).send({\r\n        success: false,\r\n        error: 'Item not found'\r\n      });\r\n    }\r\n    \r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to update item'\r\n    });\r\n  }\r\n});\r\n\r\n// Движение товара (приход/расход)\r\nfastify.post('/api/v1/inventory/stock-movement', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['itemId', 'type', 'quantity', 'reason'],\r\n      properties: {\r\n        itemId: { type: 'string' },\r\n        type: { type: 'string', enum: ['IN', 'OUT', 'ADJUSTMENT', 'TRANSFER'] },\r\n        quantity: { type: 'number', minimum: 0.01 },\r\n        reason: { type: 'string', minLength: 1 },\r\n        reference: { type: 'string' },\r\n        fromLocation: { type: 'string' },\r\n        toLocation: { type: 'string' },\r\n        machineId: { type: 'string' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { itemId, type, quantity, reason, reference, fromLocation, toLocation, machineId } = request.body;\r\n  const userId = request.user.id;\r\n  \r\n  try {\r\n    // Получаем текущий товар\r\n    const item = await prisma.inventoryItem.findUnique({\r\n      where: { id: itemId }\r\n    });\r\n\r\n    if (!item) {\r\n      return reply.code(404).send({\r\n        success: false,\r\n        error: 'Item not found'\r\n      });\r\n    }\r\n\r\n    // Вычисляем новое количество\r\n    let newQuantity = item.quantity;\r\n    if (type === 'IN') {\r\n      newQuantity += quantity;\r\n    } else if (type === 'OUT') {\r\n      newQuantity -= quantity;\r\n      if (newQuantity < 0) {\r\n        return reply.code(400).send({\r\n          success: false,\r\n          error: 'Insufficient stock'\r\n        });\r\n      }\r\n    }\r\n\r\n    // Создаем транзакцию\r\n    const [movement, updatedItem] = await prisma.$transaction([\r\n      prisma.stockMovement.create({\r\n        data: {\r\n          itemId,\r\n          userId,\r\n          type,\r\n          quantity,\r\n          quantityBefore: item.quantity,\r\n          quantityAfter: newQuantity,\r\n          reason,\r\n          reference,\r\n          fromLocation,\r\n          toLocation,\r\n          machineId\r\n        }\r\n      }),\r\n      prisma.inventoryItem.update({\r\n        where: { id: itemId },\r\n        data: {\r\n          quantity: newQuantity,\r\n          lastUpdated: new Date()\r\n        }\r\n      })\r\n    ]);\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        movement,\r\n        item: updatedItem\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to process stock movement'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить историю движений\r\nfastify.get('/api/v1/inventory/movements', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    querystring: {\r\n      type: 'object',\r\n      properties: {\r\n        itemId: { type: 'string' },\r\n        type: { type: 'string', enum: ['IN', 'OUT', 'ADJUSTMENT', 'TRANSFER'] },\r\n        machineId: { type: 'string' },\r\n        dateFrom: { type: 'string', format: 'date' },\r\n        dateTo: { type: 'string', format: 'date' },\r\n        skip: { type: 'integer', minimum: 0, default: 0 },\r\n        take: { type: 'integer', minimum: 1, maximum: 100, default: 20 }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { itemId, type, machineId, dateFrom, dateTo, skip, take } = request.query;\r\n  \r\n  try {\r\n    const where = {};\r\n    \r\n    if (itemId) where.itemId = itemId;\r\n    if (type) where.type = type;\r\n    if (machineId) where.machineId = machineId;\r\n    \r\n    if (dateFrom || dateTo) {\r\n      where.createdAt = {};\r\n      if (dateFrom) where.createdAt.gte = new Date(dateFrom);\r\n      if (dateTo) where.createdAt.lte = new Date(dateTo);\r\n    }\r\n\r\n    const [movements, total] = await Promise.all([\r\n      prisma.stockMovement.findMany({\r\n        where,\r\n        skip,\r\n        take,\r\n        orderBy: { createdAt: 'desc' },\r\n        include: {\r\n          item: true,\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true\r\n            }\r\n          },\r\n          machine: {\r\n            select: {\r\n              id: true,\r\n              code: true,\r\n              name: true\r\n            }\r\n          }\r\n        }\r\n      }),\r\n      prisma.stockMovement.count({ where })\r\n    ]);\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        movements,\r\n        total,\r\n        skip,\r\n        take\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch movements'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить товары с низким остатком\r\nfastify.get('/api/v1/inventory/low-stock', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const items = await prisma.inventoryItem.findMany({\r\n      where: {\r\n        OR: [\r\n          {\r\n            AND: [\r\n              { minQuantity: { not: null } },\r\n              { quantity: { lte: prisma.inventoryItem.fields.minQuantity } }\r\n            ]\r\n          }\r\n        ]\r\n      },\r\n      orderBy: { quantity: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: items\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch low stock items'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить статистику инвентаря\r\nfastify.get('/api/v1/inventory/stats', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const [\r\n      totalItems,\r\n      totalValue,\r\n      lowStockCount,\r\n      outOfStockCount,\r\n      categories\r\n    ] = await Promise.all([\r\n      prisma.inventoryItem.count(),\r\n      prisma.inventoryItem.aggregate({\r\n        _sum: {\r\n          quantity: true,\r\n          price: true\r\n        }\r\n      }),\r\n      prisma.inventoryItem.count({\r\n        where: {\r\n          AND: [\r\n            { minQuantity: { not: null } },\r\n            { quantity: { lte: prisma.inventoryItem.fields.minQuantity } }\r\n          ]\r\n        }\r\n      }),\r\n      prisma.inventoryItem.count({\r\n        where: { quantity: 0 }\r\n      }),\r\n      prisma.inventoryItem.groupBy({\r\n        by: ['category'],\r\n        _count: true\r\n      })\r\n    ]);\r\n\r\n    // Вычисляем общую стоимость\r\n    const totalValueAmount = totalValue._sum.quantity * (totalValue._sum.price || 0);\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        totalItems,\r\n        totalValue: totalValueAmount,\r\n        lowStockCount,\r\n        outOfStockCount,\r\n        categoriesCount: categories.length,\r\n        categories: categories.map(c => ({\r\n          name: c.category,\r\n          count: c._count\r\n        }))\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch statistics'\r\n    });\r\n  }\r\n});\r\n\r\n// Массовая загрузка товаров (для импорта)\r\nfastify.post('/api/v1/inventory/bulk-import', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['items'],\r\n      properties: {\r\n        items: {\r\n          type: 'array',\r\n          items: {\r\n            type: 'object',\r\n            required: ['name', 'sku', 'unit', 'category'],\r\n            properties: {\r\n              name: { type: 'string' },\r\n              sku: { type: 'string' },\r\n              unit: { type: 'string', enum: ['KG', 'L', 'PCS', 'PACK'] },\r\n              category: { type: 'string' },\r\n              quantity: { type: 'number', minimum: 0 },\r\n              price: { type: 'number', minimum: 0 }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { items } = request.body;\r\n  \r\n  try {\r\n    // Проверяем дубликаты SKU\r\n    const skus = items.map(item => item.sku);\r\n    const existingItems = await prisma.inventoryItem.findMany({\r\n      where: { sku: { in: skus } },\r\n      select: { sku: true }\r\n    });\r\n\r\n    if (existingItems.length > 0) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'Duplicate SKUs found',\r\n        duplicates: existingItems.map(i => i.sku)\r\n      });\r\n    }\r\n\r\n    // Создаем все товары\r\n    const createdItems = await prisma.inventoryItem.createMany({\r\n      data: items.map(item => ({\r\n        ...item,\r\n        quantity: item.quantity || 0,\r\n        lastUpdated: new Date()\r\n      }))\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        created: createdItems.count\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to import items'\r\n    });\r\n  }\r\n});\r\n\r\n// Start server\r\nconst start = async () => {\r\n  try {\r\n    await fastify.listen({ \r\n      port: process.env.PORT || 3003,\r\n      host: '0.0.0.0'\r\n    });\r\n    console.log('Inventory service is running on port', process.env.PORT || 3003);\r\n  } catch (err) {\r\n    fastify.log.error(err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\nstart();\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGTERM', async () => {\r\n  await fastify.close();\r\n  await prisma.$disconnect();\r\n  process.exit(0);\r\n});\r\n",
  "services/backup/src/index.js": "/**\r\n * VHM24 - VendHub Manager 24/7\r\n * Backup Service\r\n * Автоматическое резервное копирование данных\r\n */\r\n\r\nrequire('dotenv').config({ path: require('path').join(__dirname, '../../../.env') });\r\nconst Fastify = require('fastify');\r\nconst cors = require('@fastify/cors');\r\nconst jwt = require('@fastify/jwt');\r\nconst cron = require('node-cron');\r\nconst { exec } = require('child_process');\r\nconst { promisify } = require('util');\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\nconst archiver = require('archiver');\r\nconst AWS = require('aws-sdk');\r\n\r\nconst execAsync = promisify(exec);\r\nconst fastify = Fastify({ \r\n  logger: true,\r\n  trustProxy: true\r\n});\r\n\r\n// Проверка обязательных переменных окружения\r\nif (!process.env.JWT_SECRET) {\r\n  throw new Error('JWT_SECRET must be set in environment variables');\r\n}\r\n\r\n// Настройка S3 для хранения бэкапов\r\nlet s3 = null;\r\nif (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {\r\n  s3 = new AWS.S3({\r\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\r\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\r\n    region: process.env.AWS_REGION || 'us-east-1'\r\n  });\r\n}\r\n\r\n// CORS\r\nfastify.register(cors, {\r\n  origin: (origin, cb) => {\r\n    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'];\r\n    if (!origin || allowedOrigins.includes(origin)) {\r\n      cb(null, true);\r\n    } else {\r\n      cb(new Error('Not allowed by CORS'));\r\n    }\r\n  },\r\n  credentials: true\r\n});\r\n\r\n// JWT\r\nfastify.register(jwt, {\r\n  secret: process.env.JWT_SECRET,\r\n  verify: {\r\n    issuer: ['vhm24-gateway', 'vhm24-auth']\r\n  }\r\n});\r\n\r\n// Декоратор для проверки авторизации\r\nfastify.decorate('authenticate', async function(request, reply) {\r\n  try {\r\n    await request.jwtVerify();\r\n    // Проверяем, что пользователь - администратор\r\n    if (!request.user.roles || !request.user.roles.includes('ADMIN')) {\r\n      throw new Error('Admin access required');\r\n    }\r\n  } catch (err) {\r\n    reply.code(401).send({ \r\n      success: false,\r\n      error: 'Unauthorized',\r\n      message: err.message || 'Invalid or expired token'\r\n    });\r\n  }\r\n});\r\n\r\n// Health check\r\nfastify.get('/health', async (request, reply) => {\r\n  return { \r\n    status: 'ok', \r\n    service: 'backup',\r\n    storage: {\r\n      s3: s3 ? 'configured' : 'not configured',\r\n      local: 'available'\r\n    },\r\n    schedule: process.env.BACKUP_SCHEDULE || '0 2 * * *'\r\n  };\r\n});\r\n\r\n// Функция создания бэкапа базы данных\r\nasync function createDatabaseBackup() {\r\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\r\n  const backupDir = path.join(process.cwd(), 'backups');\r\n  const backupFile = `vhm24-db-backup-${timestamp}.sql`;\r\n  const backupPath = path.join(backupDir, backupFile);\r\n  \r\n  try {\r\n    // Создаем директорию для бэкапов\r\n    await fs.mkdir(backupDir, { recursive: true });\r\n    \r\n    // Парсим DATABASE_URL\r\n    const dbUrl = new URL(process.env.DATABASE_URL);\r\n    const [username, password] = dbUrl.username ? [dbUrl.username, dbUrl.password] : ['', ''];\r\n    const hostname = dbUrl.hostname;\r\n    const port = dbUrl.port || 5432;\r\n    const database = dbUrl.pathname.slice(1);\r\n    \r\n    // Создаем дамп базы данных\r\n    const pgDumpCommand = `PGPASSWORD=\"${password}\" pg_dump -h ${hostname} -p ${port} -U ${username} -d ${database} -f ${backupPath}`;\r\n    \r\n    await execAsync(pgDumpCommand);\r\n    \r\n    // Сжимаем бэкап\r\n    const zipPath = `${backupPath}.zip`;\r\n    const output = await fs.open(zipPath, 'w');\r\n    const archive = archiver('zip', { zlib: { level: 9 } });\r\n    \r\n    archive.pipe(output);\r\n    archive.file(backupPath, { name: backupFile });\r\n    await archive.finalize();\r\n    \r\n    // Удаляем несжатый файл\r\n    await fs.unlink(backupPath);\r\n    \r\n    // Загружаем в S3 если настроено\r\n    if (s3 && process.env.BACKUP_S3_BUCKET) {\r\n      const fileContent = await fs.readFile(zipPath);\r\n      \r\n      await s3.putObject({\r\n        Bucket: process.env.BACKUP_S3_BUCKET,\r\n        Key: `database/${backupFile}.zip`,\r\n        Body: fileContent,\r\n        ContentType: 'application/zip'\r\n      }).promise();\r\n      \r\n      fastify.log.info(`Database backup uploaded to S3: ${backupFile}.zip`);\r\n    }\r\n    \r\n    // Очистка старых локальных бэкапов\r\n    await cleanupOldBackups(backupDir);\r\n    \r\n    return {\r\n      success: true,\r\n      filename: `${backupFile}.zip`,\r\n      size: (await fs.stat(zipPath)).size,\r\n      path: zipPath,\r\n      s3: s3 && process.env.BACKUP_S3_BUCKET ? true : false\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error('Database backup failed:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Функция создания бэкапа файлов\r\nasync function createFilesBackup() {\r\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\r\n  const backupDir = path.join(process.cwd(), 'backups');\r\n  const backupFile = `vhm24-files-backup-${timestamp}.zip`;\r\n  const backupPath = path.join(backupDir, backupFile);\r\n  \r\n  try {\r\n    // Создаем директорию для бэкапов\r\n    await fs.mkdir(backupDir, { recursive: true });\r\n    \r\n    // Создаем архив\r\n    const output = await fs.open(backupPath, 'w');\r\n    const archive = archiver('zip', { zlib: { level: 9 } });\r\n    \r\n    archive.pipe(output);\r\n    \r\n    // Добавляем директории для бэкапа\r\n    const dirsToBackup = ['uploads', 'logs'];\r\n    \r\n    for (const dir of dirsToBackup) {\r\n      const dirPath = path.join(process.cwd(), dir);\r\n      try {\r\n        await fs.access(dirPath);\r\n        archive.directory(dirPath, dir);\r\n      } catch (error) {\r\n        fastify.log.warn(`Directory ${dir} not found, skipping`);\r\n      }\r\n    }\r\n    \r\n    await archive.finalize();\r\n    \r\n    // Загружаем в S3 если настроено\r\n    if (s3 && process.env.BACKUP_S3_BUCKET) {\r\n      const fileContent = await fs.readFile(backupPath);\r\n      \r\n      await s3.putObject({\r\n        Bucket: process.env.BACKUP_S3_BUCKET,\r\n        Key: `files/${backupFile}`,\r\n        Body: fileContent,\r\n        ContentType: 'application/zip'\r\n      }).promise();\r\n      \r\n      fastify.log.info(`Files backup uploaded to S3: ${backupFile}`);\r\n    }\r\n    \r\n    return {\r\n      success: true,\r\n      filename: backupFile,\r\n      size: (await fs.stat(backupPath)).size,\r\n      path: backupPath,\r\n      s3: s3 && process.env.BACKUP_S3_BUCKET ? true : false\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error('Files backup failed:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Очистка старых бэкапов\r\nasync function cleanupOldBackups(backupDir) {\r\n  const retentionDays = parseInt(process.env.BACKUP_RETENTION_DAYS) || 30;\r\n  const cutoffDate = new Date();\r\n  cutoffDate.setDate(cutoffDate.getDate() - retentionDays);\r\n  \r\n  try {\r\n    const files = await fs.readdir(backupDir);\r\n    \r\n    for (const file of files) {\r\n      const filePath = path.join(backupDir, file);\r\n      const stats = await fs.stat(filePath);\r\n      \r\n      if (stats.mtime < cutoffDate) {\r\n        await fs.unlink(filePath);\r\n        fastify.log.info(`Deleted old backup: ${file}`);\r\n      }\r\n    }\r\n  } catch (error) {\r\n    fastify.log.error('Cleanup failed:', error);\r\n  }\r\n}\r\n\r\n// Создать бэкап вручную\r\nfastify.post('/api/v1/backup/create', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      properties: {\r\n        type: { \r\n          type: 'string', \r\n          enum: ['database', 'files', 'full'],\r\n          default: 'full'\r\n        }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { type } = request.body;\r\n  \r\n  try {\r\n    const results = {};\r\n    \r\n    if (type === 'database' || type === 'full') {\r\n      results.database = await createDatabaseBackup();\r\n    }\r\n    \r\n    if (type === 'files' || type === 'full') {\r\n      results.files = await createFilesBackup();\r\n    }\r\n    \r\n    return {\r\n      success: true,\r\n      data: results,\r\n      message: 'Backup created successfully'\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Backup failed',\r\n      message: error.message\r\n    });\r\n  }\r\n});\r\n\r\n// Получить список бэкапов\r\nfastify.get('/api/v1/backup/list', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const backupDir = path.join(process.cwd(), 'backups');\r\n    const backups = [];\r\n    \r\n    try {\r\n      const files = await fs.readdir(backupDir);\r\n      \r\n      for (const file of files) {\r\n        const filePath = path.join(backupDir, file);\r\n        const stats = await fs.stat(filePath);\r\n        \r\n        backups.push({\r\n          filename: file,\r\n          size: stats.size,\r\n          created: stats.mtime,\r\n          type: file.includes('db-backup') ? 'database' : 'files'\r\n        });\r\n      }\r\n    } catch (error) {\r\n      // Директория не существует\r\n    }\r\n    \r\n    // Получаем список из S3\r\n    let s3Backups = [];\r\n    if (s3 && process.env.BACKUP_S3_BUCKET) {\r\n      try {\r\n        const s3Data = await s3.listObjectsV2({\r\n          Bucket: process.env.BACKUP_S3_BUCKET,\r\n          MaxKeys: 100\r\n        }).promise();\r\n        \r\n        s3Backups = s3Data.Contents.map(item => ({\r\n          filename: item.Key.split('/').pop(),\r\n          size: item.Size,\r\n          created: item.LastModified,\r\n          type: item.Key.startsWith('database/') ? 'database' : 'files',\r\n          s3: true,\r\n          key: item.Key\r\n        }));\r\n      } catch (error) {\r\n        fastify.log.error('Failed to list S3 backups:', error);\r\n      }\r\n    }\r\n    \r\n    return {\r\n      success: true,\r\n      data: {\r\n        local: backups.sort((a, b) => b.created - a.created),\r\n        s3: s3Backups.sort((a, b) => b.created - a.created)\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to list backups'\r\n    });\r\n  }\r\n});\r\n\r\n// Скачать бэкап\r\nfastify.get('/api/v1/backup/download/:filename', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  const { filename } = request.params;\r\n  \r\n  try {\r\n    const backupDir = path.join(process.cwd(), 'backups');\r\n    const filePath = path.join(backupDir, filename);\r\n    \r\n    // Проверяем безопасность пути\r\n    if (!filePath.startsWith(backupDir)) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'Invalid filename'\r\n      });\r\n    }\r\n    \r\n    // Проверяем существование файла\r\n    await fs.access(filePath);\r\n    \r\n    // Отправляем файл\r\n    return reply.sendFile(filename, backupDir);\r\n  } catch (error) {\r\n    reply.code(404).send({\r\n      success: false,\r\n      error: 'Backup not found'\r\n    });\r\n  }\r\n});\r\n\r\n// Восстановить из бэкапа\r\nfastify.post('/api/v1/backup/restore', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['filename'],\r\n      properties: {\r\n        filename: { type: 'string' },\r\n        source: { type: 'string', enum: ['local', 's3'], default: 'local' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { filename, source } = request.body;\r\n  \r\n  try {\r\n    // Только для database бэкапов\r\n    if (!filename.includes('db-backup')) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'Only database backups can be restored'\r\n      });\r\n    }\r\n    \r\n    let backupPath;\r\n    \r\n    if (source === 's3' && s3 && process.env.BACKUP_S3_BUCKET) {\r\n      // Скачиваем из S3\r\n      const tempPath = path.join(process.cwd(), 'temp', filename);\r\n      await fs.mkdir(path.dirname(tempPath), { recursive: true });\r\n      \r\n      const s3Object = await s3.getObject({\r\n        Bucket: process.env.BACKUP_S3_BUCKET,\r\n        Key: `database/${filename}`\r\n      }).promise();\r\n      \r\n      await fs.writeFile(tempPath, s3Object.Body);\r\n      backupPath = tempPath;\r\n    } else {\r\n      backupPath = path.join(process.cwd(), 'backups', filename);\r\n    }\r\n    \r\n    // TODO: Реализовать восстановление базы данных\r\n    // Это требует остановки всех сервисов и выполнения pg_restore\r\n    \r\n    return {\r\n      success: false,\r\n      error: 'Restore functionality not implemented yet',\r\n      message: 'Please restore manually using pg_restore'\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Restore failed',\r\n      message: error.message\r\n    });\r\n  }\r\n});\r\n\r\n// Настройка расписания автоматических бэкапов\r\nif (process.env.BACKUP_ENABLED === 'true') {\r\n  const schedule = process.env.BACKUP_SCHEDULE || '0 2 * * *'; // По умолчанию в 2 ночи\r\n  \r\n  cron.schedule(schedule, async () => {\r\n    fastify.log.info('Starting scheduled backup...');\r\n    \r\n    try {\r\n      const dbBackup = await createDatabaseBackup();\r\n      const filesBackup = await createFilesBackup();\r\n      \r\n      fastify.log.info('Scheduled backup completed successfully', {\r\n        database: dbBackup,\r\n        files: filesBackup\r\n      });\r\n    } catch (error) {\r\n      fastify.log.error('Scheduled backup failed:', error);\r\n    }\r\n  });\r\n  \r\n  fastify.log.info(`Backup schedule configured: ${schedule}`);\r\n}\r\n\r\n// Start server\r\nconst start = async () => {\r\n  try {\r\n    await fastify.listen({ \r\n      port: process.env.BACKUP_PORT || 3007,\r\n      host: '0.0.0.0'\r\n    });\r\n    console.log('VHM24 Backup Service running 24/7 on port', process.env.BACKUP_PORT || 3007);\r\n  } catch (err) {\r\n    fastify.log.error(err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\nstart();\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGTERM', async () => {\r\n  await fastify.close();\r\n  process.exit(0);\r\n});\r\n",
  "migrate-from-supabase.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * Migration script from Supabase to new database architecture\r\n * This script will:\r\n * 1. Export data from Supabase\r\n * 2. Transform data for new schema structure\r\n * 3. Import data into new databases\r\n */\r\n\r\nconst { PrismaClient } = require('@prisma/client');\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\n\r\n// Old Supabase client\r\nconst supabaseClient = new PrismaClient({\r\n  datasources: {\r\n    db: {\r\n      url: process.env.SUPABASE_DATABASE_URL || process.env.DATABASE_URL\r\n    }\r\n  }\r\n});\r\n\r\n// New database clients (will be imported after generation)\r\nlet authClient, machinesClient, inventoryClient, tasksClient, sharedClient;\r\n\r\nasync function loadNewClients() {\r\n  try {\r\n    const { getAuthClient } = require('./packages/database/dist/clients/auth.client');\r\n    const { getMachinesClient } = require('./packages/database/dist/clients/machines.client');\r\n    const { getInventoryClient } = require('./packages/database/dist/clients/inventory.client');\r\n    const { getTasksClient } = require('./packages/database/dist/clients/tasks.client');\r\n    const { getSharedClient } = require('./packages/database/dist/clients/shared.client');\r\n\r\n    authClient = getAuthClient();\r\n    machinesClient = getMachinesClient();\r\n    inventoryClient = getInventoryClient();\r\n    tasksClient = getTasksClient();\r\n    sharedClient = getSharedClient();\r\n  } catch (error) {\r\n    console.error('Error loading new clients. Make sure to run \"npm run generate\" first.');\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function exportData() {\r\n  console.log('📤 Exporting data from Supabase...');\r\n  \r\n  const data = {\r\n    users: await supabaseClient.user.findMany(),\r\n    locations: await supabaseClient.location.findMany(),\r\n    machines: await supabaseClient.machine.findMany(),\r\n    tasks: await supabaseClient.task.findMany(),\r\n    taskActions: await supabaseClient.taskAction.findMany(),\r\n    inventoryItems: await supabaseClient.inventoryItem.findMany(),\r\n    stockMovements: await supabaseClient.stockMovement.findMany(),\r\n    machineTelemetry: await supabaseClient.machineTelemetry.findMany(),\r\n    auditLogs: await supabaseClient.auditLog.findMany(),\r\n    transactions: await supabaseClient.transaction.findMany(),\r\n    machineInventory: await supabaseClient.machineInventory.findMany(),\r\n    serviceHistory: await supabaseClient.serviceHistory.findMany(),\r\n  };\r\n\r\n  // Save backup\r\n  const backupPath = path.join(__dirname, 'supabase-backup.json');\r\n  await fs.writeFile(backupPath, JSON.stringify(data, null, 2));\r\n  console.log(`✅ Data exported to ${backupPath}`);\r\n\r\n  return data;\r\n}\r\n\r\nasync function migrateAuthData(data) {\r\n  console.log('🔐 Migrating auth data...');\r\n  \r\n  // Migrate users\r\n  for (const user of data.users) {\r\n    await authClient.user.create({\r\n      data: {\r\n        id: user.id,\r\n        email: user.email,\r\n        name: user.name,\r\n        passwordHash: user.passwordHash,\r\n        roles: user.roles,\r\n        phoneNumber: user.phoneNumber,\r\n        telegramId: user.telegramId,\r\n        isActive: user.isActive,\r\n        lastLogin: user.lastLogin,\r\n        createdAt: user.createdAt,\r\n        updatedAt: user.updatedAt,\r\n      }\r\n    });\r\n  }\r\n\r\n  // Migrate audit logs (only auth-related)\r\n  const authAuditLogs = data.auditLogs.filter(log => \r\n    log.entity === 'User' || log.action.includes('auth') || log.action.includes('login')\r\n  );\r\n  \r\n  for (const log of authAuditLogs) {\r\n    await authClient.auditLog.create({\r\n      data: {\r\n        id: log.id,\r\n        userId: log.userId,\r\n        action: log.action,\r\n        entity: log.entity,\r\n        entityId: log.entityId,\r\n        changes: log.changes,\r\n        ipAddress: log.ipAddress,\r\n        userAgent: log.userAgent,\r\n        createdAt: log.createdAt,\r\n      }\r\n    });\r\n  }\r\n\r\n  console.log(`✅ Migrated ${data.users.length} users and ${authAuditLogs.length} audit logs`);\r\n}\r\n\r\nasync function migrateMachinesData(data) {\r\n  console.log('🤖 Migrating machines data...');\r\n  \r\n  // Migrate locations\r\n  for (const location of data.locations) {\r\n    await machinesClient.location.create({\r\n      data: {\r\n        id: location.id,\r\n        name: location.name,\r\n        address: location.address,\r\n        latitude: location.latitude,\r\n        longitude: location.longitude,\r\n        isActive: location.isActive,\r\n        createdAt: location.createdAt,\r\n        updatedAt: location.updatedAt,\r\n      }\r\n    });\r\n  }\r\n\r\n  // Migrate machines\r\n  for (const machine of data.machines) {\r\n    await machinesClient.machine.create({\r\n      data: {\r\n        id: machine.id,\r\n        code: machine.code,\r\n        serialNumber: machine.serialNumber,\r\n        type: machine.type,\r\n        name: machine.name,\r\n        status: machine.status,\r\n        locationId: machine.locationId,\r\n        lastPing: machine.lastPing,\r\n        metadata: machine.metadata,\r\n        createdAt: machine.createdAt,\r\n        updatedAt: machine.updatedAt,\r\n      }\r\n    });\r\n  }\r\n\r\n  // Migrate telemetry\r\n  for (const telemetry of data.machineTelemetry) {\r\n    await machinesClient.machineTelemetry.create({\r\n      data: {\r\n        id: telemetry.id,\r\n        machineId: telemetry.machineId,\r\n        temperature: telemetry.temperature,\r\n        humidity: telemetry.humidity,\r\n        sales: telemetry.sales,\r\n        errors: telemetry.errors,\r\n        rawData: telemetry.rawData,\r\n        createdAt: telemetry.createdAt,\r\n      }\r\n    });\r\n  }\r\n\r\n  // Migrate service history\r\n  for (const service of data.serviceHistory) {\r\n    await machinesClient.serviceHistory.create({\r\n      data: {\r\n        id: service.id,\r\n        machineId: service.machineId,\r\n        serviceType: service.serviceType,\r\n        description: service.description,\r\n        performedById: service.performedById,\r\n        performedAt: service.performedAt,\r\n        nextServiceDate: service.nextServiceDate,\r\n        photos: service.photos,\r\n        location: service.location,\r\n        metadata: service.metadata,\r\n      }\r\n    });\r\n  }\r\n\r\n  console.log(`✅ Migrated ${data.locations.length} locations, ${data.machines.length} machines`);\r\n}\r\n\r\nasync function migrateInventoryData(data) {\r\n  console.log('📦 Migrating inventory data...');\r\n  \r\n  // Migrate inventory items\r\n  for (const item of data.inventoryItems) {\r\n    await inventoryClient.inventoryItem.create({\r\n      data: {\r\n        id: item.id,\r\n        name: item.name,\r\n        sku: item.sku,\r\n        unit: item.unit,\r\n        category: item.category,\r\n        description: item.description,\r\n        quantity: item.quantity,\r\n        minQuantity: item.minQuantity,\r\n        maxQuantity: item.maxQuantity,\r\n        price: item.price,\r\n        isActive: item.isActive,\r\n        lastUpdated: item.lastUpdated,\r\n        createdAt: item.createdAt,\r\n        updatedAt: item.updatedAt,\r\n      }\r\n    });\r\n  }\r\n\r\n  // Migrate stock movements\r\n  for (const movement of data.stockMovements) {\r\n    await inventoryClient.stockMovement.create({\r\n      data: {\r\n        id: movement.id,\r\n        itemId: movement.itemId,\r\n        userId: movement.userId,\r\n        type: movement.type,\r\n        quantity: movement.quantity,\r\n        quantityBefore: movement.quantityBefore,\r\n        quantityAfter: movement.quantityAfter,\r\n        reason: movement.reason,\r\n        reference: movement.reference,\r\n        fromLocation: movement.fromLocation,\r\n        toLocation: movement.toLocation,\r\n        machineId: movement.machineId,\r\n        metadata: movement.metadata,\r\n        createdAt: movement.createdAt,\r\n      }\r\n    });\r\n  }\r\n\r\n  // Migrate machine inventory\r\n  for (const inv of data.machineInventory) {\r\n    await inventoryClient.machineInventory.create({\r\n      data: {\r\n        id: inv.id,\r\n        machineId: inv.machineId,\r\n        itemId: inv.itemId,\r\n        quantity: inv.quantity,\r\n        minQuantity: inv.minQuantity,\r\n        maxQuantity: inv.maxQuantity,\r\n        lastRefill: inv.lastRefill,\r\n        createdAt: inv.createdAt,\r\n        updatedAt: inv.updatedAt,\r\n      }\r\n    });\r\n  }\r\n\r\n  console.log(`✅ Migrated ${data.inventoryItems.length} items, ${data.stockMovements.length} movements`);\r\n}\r\n\r\nasync function migrateTasksData(data) {\r\n  console.log('📋 Migrating tasks data...');\r\n  \r\n  // Migrate tasks\r\n  for (const task of data.tasks) {\r\n    await tasksClient.task.create({\r\n      data: {\r\n        id: task.id,\r\n        title: task.title,\r\n        description: task.description,\r\n        status: task.status,\r\n        priority: task.priority,\r\n        dueDate: task.dueDate,\r\n        completedAt: task.completedAt,\r\n        machineId: task.machineId,\r\n        assignedToId: task.assignedToId,\r\n        createdById: task.createdById,\r\n        createdAt: task.createdAt,\r\n        updatedAt: task.updatedAt,\r\n      }\r\n    });\r\n  }\r\n\r\n  // Migrate task actions\r\n  for (const action of data.taskActions) {\r\n    await tasksClient.taskAction.create({\r\n      data: {\r\n        id: action.id,\r\n        taskId: action.taskId,\r\n        userId: action.userId,\r\n        action: action.action,\r\n        comment: action.comment,\r\n        location: action.location,\r\n        photoUrls: action.photoUrls,\r\n        metadata: action.metadata,\r\n        createdAt: action.createdAt,\r\n      }\r\n    });\r\n  }\r\n\r\n  console.log(`✅ Migrated ${data.tasks.length} tasks and ${data.taskActions.length} actions`);\r\n}\r\n\r\nasync function migrateSharedData(data) {\r\n  console.log('🌐 Migrating shared data...');\r\n  \r\n  // Migrate transactions\r\n  for (const transaction of data.transactions) {\r\n    await sharedClient.transaction.create({\r\n      data: {\r\n        id: transaction.id,\r\n        machineId: transaction.machineId,\r\n        amount: transaction.amount,\r\n        currency: transaction.currency,\r\n        paymentType: transaction.paymentType,\r\n        status: transaction.status,\r\n        reference: transaction.reference,\r\n        metadata: transaction.metadata,\r\n        createdAt: transaction.createdAt,\r\n      }\r\n    });\r\n  }\r\n\r\n  console.log(`✅ Migrated ${data.transactions.length} transactions`);\r\n}\r\n\r\nasync function main() {\r\n  try {\r\n    console.log('🚀 Starting migration from Supabase...\\n');\r\n\r\n    // Check environment\r\n    if (!process.env.DATABASE_URL && !process.env.SUPABASE_DATABASE_URL) {\r\n      throw new Error('Please set SUPABASE_DATABASE_URL or DATABASE_URL for the source database');\r\n    }\r\n\r\n    // Load new clients\r\n    await loadNewClients();\r\n\r\n    // Export data from Supabase\r\n    const data = await exportData();\r\n\r\n    // Migrate data to new databases\r\n    await migrateAuthData(data);\r\n    await migrateMachinesData(data);\r\n    await migrateInventoryData(data);\r\n    await migrateTasksData(data);\r\n    await migrateSharedData(data);\r\n\r\n    console.log('\\n✅ Migration completed successfully!');\r\n    console.log('📝 Next steps:');\r\n    console.log('1. Update your services to use the new database clients');\r\n    console.log('2. Test all functionality');\r\n    console.log('3. Remove Supabase dependencies');\r\n\r\n  } catch (error) {\r\n    console.error('❌ Migration failed:', error);\r\n    process.exit(1);\r\n  } finally {\r\n    await supabaseClient.$disconnect();\r\n    if (authClient) await authClient.$disconnect();\r\n    if (machinesClient) await machinesClient.$disconnect();\r\n    if (inventoryClient) await inventoryClient.$disconnect();\r\n    if (tasksClient) await tasksClient.$disconnect();\r\n    if (sharedClient) await sharedClient.$disconnect();\r\n  }\r\n}\r\n\r\n// Run migration\r\nmain();\r\n",
  "packages/database/src/clients/index.js": "// Simplified database clients for JavaScript usage\r\nconst { PrismaClient } = require('@prisma/client');\r\n\r\n// Single database mode (default)\r\nlet prismaClient = null;\r\n\r\nfunction getPrismaClient() {\r\n  if (!prismaClient) {\r\n    prismaClient = new PrismaClient({\r\n      datasources: {\r\n        db: {\r\n          url: process.env.DATABASE_URL,\r\n        },\r\n      },\r\n      log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\r\n    });\r\n  }\r\n  return prismaClient;\r\n}\r\n\r\n// Multi-database mode clients\r\nlet authClient = null;\r\nlet machinesClient = null;\r\nlet inventoryClient = null;\r\nlet tasksClient = null;\r\nlet sharedClient = null;\r\n\r\nfunction getAuthClient() {\r\n  if (process.env.USE_MULTIPLE_DATABASES !== 'true') {\r\n    return getPrismaClient();\r\n  }\r\n  \r\n  if (!authClient) {\r\n    authClient = new PrismaClient({\r\n      datasources: {\r\n        db: {\r\n          url: process.env.AUTH_DATABASE_URL || process.env.DATABASE_URL,\r\n        },\r\n      },\r\n      log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\r\n    });\r\n  }\r\n  return authClient;\r\n}\r\n\r\nfunction getMachinesClient() {\r\n  if (process.env.USE_MULTIPLE_DATABASES !== 'true') {\r\n    return getPrismaClient();\r\n  }\r\n  \r\n  if (!machinesClient) {\r\n    machinesClient = new PrismaClient({\r\n      datasources: {\r\n        db: {\r\n          url: process.env.MACHINES_DATABASE_URL || process.env.DATABASE_URL,\r\n        },\r\n      },\r\n      log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\r\n    });\r\n  }\r\n  return machinesClient;\r\n}\r\n\r\nfunction getInventoryClient() {\r\n  if (process.env.USE_MULTIPLE_DATABASES !== 'true') {\r\n    return getPrismaClient();\r\n  }\r\n  \r\n  if (!inventoryClient) {\r\n    inventoryClient = new PrismaClient({\r\n      datasources: {\r\n        db: {\r\n          url: process.env.INVENTORY_DATABASE_URL || process.env.DATABASE_URL,\r\n        },\r\n      },\r\n      log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\r\n    });\r\n  }\r\n  return inventoryClient;\r\n}\r\n\r\nfunction getTasksClient() {\r\n  if (process.env.USE_MULTIPLE_DATABASES !== 'true') {\r\n    return getPrismaClient();\r\n  }\r\n  \r\n  if (!tasksClient) {\r\n    tasksClient = new PrismaClient({\r\n      datasources: {\r\n        db: {\r\n          url: process.env.TASKS_DATABASE_URL || process.env.DATABASE_URL,\r\n        },\r\n      },\r\n      log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\r\n    });\r\n  }\r\n  return tasksClient;\r\n}\r\n\r\nfunction getSharedClient() {\r\n  if (process.env.USE_MULTIPLE_DATABASES !== 'true') {\r\n    return getPrismaClient();\r\n  }\r\n  \r\n  if (!sharedClient) {\r\n    sharedClient = new PrismaClient({\r\n      datasources: {\r\n        db: {\r\n          url: process.env.SHARED_DATABASE_URL || process.env.DATABASE_URL,\r\n        },\r\n      },\r\n      log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\r\n    });\r\n  }\r\n  return sharedClient;\r\n}\r\n\r\n// Disconnect functions\r\nasync function disconnectAllClients() {\r\n  const clients = [\r\n    prismaClient,\r\n    authClient,\r\n    machinesClient,\r\n    inventoryClient,\r\n    tasksClient,\r\n    sharedClient\r\n  ].filter(Boolean);\r\n\r\n  await Promise.all(clients.map(client => client.$disconnect()));\r\n  \r\n  // Reset all clients\r\n  prismaClient = null;\r\n  authClient = null;\r\n  machinesClient = null;\r\n  inventoryClient = null;\r\n  tasksClient = null;\r\n  sharedClient = null;\r\n}\r\n\r\nmodule.exports = {\r\n  getPrismaClient,\r\n  getAuthClient,\r\n  getMachinesClient,\r\n  getInventoryClient,\r\n  getTasksClient,\r\n  getSharedClient,\r\n  disconnectAllClients,\r\n  // For backward compatibility\r\n  PrismaClient\r\n};\r\n",
  "scripts/comprehensive-test.js": "const { execSync } = require('child_process');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nclass ProjectTester {\r\n  constructor() {\r\n    this.results = {\r\n      timestamp: new Date().toISOString(),\r\n      environment: process.env.NODE_ENV || 'development',\r\n      tests: {\r\n        dependencies: {},\r\n        services: {},\r\n        api: {},\r\n        database: {},\r\n        infrastructure: {},\r\n        security: {}\r\n      }\r\n    };\r\n  }\r\n\r\n  async runAllTests() {\r\n    console.log('🧪 Запуск комплексного тестирования VHM24...\\n');\r\n    \r\n    try {\r\n      // 1. Проверка зависимостей\r\n      await this.testDependencies();\r\n      \r\n      // 2. Проверка инфраструктуры\r\n      await this.testInfrastructure();\r\n      \r\n      // 3. Проверка базы данных\r\n      await this.testDatabase();\r\n      \r\n      // 4. Проверка сервисов\r\n      await this.testServices();\r\n      \r\n      // 5. Проверка безопасности\r\n      await this.testSecurity();\r\n      \r\n      // 6. Сохранение результатов\r\n      this.saveResults();\r\n      \r\n    } catch (error) {\r\n      console.error('❌ Error during testing:', error.message);\r\n      this.results.error = error.message;\r\n      this.saveResults();\r\n    }\r\n  }\r\n\r\n  async testDependencies() {\r\n    console.log('📦 Проверка зависимостей...');\r\n    \r\n    try {\r\n      // Проверка npm\r\n      const npmVersion = execSync('npm --version', { stdio: 'pipe' }).toString().trim();\r\n      this.results.tests.dependencies.npm = { version: npmVersion, status: 'OK' };\r\n      \r\n      // Проверка Node.js\r\n      const nodeVersion = execSync('node --version', { stdio: 'pipe' }).toString().trim();\r\n      this.results.tests.dependencies.node = { version: nodeVersion, status: 'OK' };\r\n      \r\n      // Проверка уязвимостей\r\n      try {\r\n        const audit = execSync('npm audit --json', { stdio: 'pipe' });\r\n        const auditData = JSON.parse(audit.toString());\r\n        this.results.tests.dependencies.vulnerabilities = {\r\n          total: auditData.metadata?.vulnerabilities?.total || 0,\r\n          high: auditData.metadata?.vulnerabilities?.high || 0,\r\n          critical: auditData.metadata?.vulnerabilities?.critical || 0\r\n        };\r\n      } catch (e) {\r\n        this.results.tests.dependencies.vulnerabilities = 'Audit check failed';\r\n      }\r\n      \r\n      // Проверка outdated пакетов\r\n      try {\r\n        const outdated = execSync('npm outdated --json', { stdio: 'pipe' });\r\n        this.results.tests.dependencies.outdated = JSON.parse(outdated.toString());\r\n      } catch (e) {\r\n        this.results.tests.dependencies.outdated = {};\r\n      }\r\n      \r\n      // Проверка package.json в сервисах\r\n      const services = fs.readdirSync('services');\r\n      this.results.tests.dependencies.services = {};\r\n      \r\n      services.forEach(service => {\r\n        const pkgPath = path.join('services', service, 'package.json');\r\n        if (fs.existsSync(pkgPath)) {\r\n          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));\r\n          this.results.tests.dependencies.services[service] = {\r\n            hasPackageJson: true,\r\n            hasStartScript: !!(pkg.scripts && (pkg.scripts.start || pkg.scripts.dev)),\r\n            dependencies: Object.keys(pkg.dependencies || {}),\r\n            devDependencies: Object.keys(pkg.devDependencies || {})\r\n          };\r\n        } else {\r\n          this.results.tests.dependencies.services[service] = {\r\n            hasPackageJson: false\r\n          };\r\n        }\r\n      });\r\n      \r\n    } catch (error) {\r\n      this.results.tests.dependencies.error = error.message;\r\n    }\r\n  }\r\n\r\n  async testInfrastructure() {\r\n    console.log('🏗️ Проверка инфраструктуры...');\r\n    \r\n    // Docker\r\n    try {\r\n      const dockerVersion = execSync('docker --version', { stdio: 'pipe' }).toString().trim();\r\n      this.results.tests.infrastructure.docker = { \r\n        version: dockerVersion, \r\n        status: 'Installed' \r\n      };\r\n      \r\n      // Проверка контейнеров\r\n      try {\r\n        const containers = execSync('docker ps --format \"{{.Names}}\"', { stdio: 'pipe' })\r\n          .toString().split('\\n').filter(Boolean);\r\n        this.results.tests.infrastructure.containers = containers;\r\n      } catch (e) {\r\n        this.results.tests.infrastructure.containers = [];\r\n      }\r\n    } catch (e) {\r\n      this.results.tests.infrastructure.docker = { status: 'Not installed' };\r\n    }\r\n    \r\n    // Проверка файловой структуры\r\n    const requiredDirs = ['services', 'packages', 'apps'];\r\n    this.results.tests.infrastructure.directories = {};\r\n    \r\n    requiredDirs.forEach(dir => {\r\n      this.results.tests.infrastructure.directories[dir] = fs.existsSync(dir);\r\n    });\r\n    \r\n    // Проверка конфигурационных файлов\r\n    const configFiles = [\r\n      'package.json',\r\n      'docker-compose.yml',\r\n      '.env',\r\n      'nixpacks.toml',\r\n      'railway.json'\r\n    ];\r\n    \r\n    this.results.tests.infrastructure.configFiles = {};\r\n    configFiles.forEach(file => {\r\n      this.results.tests.infrastructure.configFiles[file] = fs.existsSync(file);\r\n    });\r\n  }\r\n\r\n  async testDatabase() {\r\n    console.log('🗄️ Проверка базы данных...');\r\n    \r\n    try {\r\n      // Проверка Prisma\r\n      const prismaSchemaPath = 'packages/database/prisma/schema.prisma';\r\n      this.results.tests.database.prismaSchema = fs.existsSync(prismaSchemaPath);\r\n      \r\n      if (this.results.tests.database.prismaSchema) {\r\n        const schema = fs.readFileSync(prismaSchemaPath, 'utf8');\r\n        const models = schema.match(/model\\s+(\\w+)/g) || [];\r\n        this.results.tests.database.models = models.map(m => m.replace('model ', ''));\r\n      }\r\n      \r\n      // Проверка переменных окружения для БД\r\n      if (fs.existsSync('.env')) {\r\n        const env = fs.readFileSync('.env', 'utf8');\r\n        this.results.tests.database.hasConnectionString = env.includes('DATABASE_URL');\r\n        this.results.tests.database.hasRedisUrl = env.includes('REDIS_URL');\r\n      }\r\n      \r\n      // Попытка подключения к БД (если возможно)\r\n      try {\r\n        const { PrismaClient } = require('@prisma/client');\r\n        const prisma = new PrismaClient();\r\n        \r\n        await prisma.$connect();\r\n        this.results.tests.database.connection = 'OK';\r\n        \r\n        // Проверка таблиц\r\n        const tables = await prisma.$queryRaw`\r\n          SELECT table_name \r\n          FROM information_schema.tables \r\n          WHERE table_schema = 'public'\r\n        `;\r\n        this.results.tests.database.tables = tables.map(t => t.table_name);\r\n        \r\n        await prisma.$disconnect();\r\n      } catch (error) {\r\n        this.results.tests.database.connection = `Failed: ${error.message}`;\r\n      }\r\n      \r\n    } catch (error) {\r\n      this.results.tests.database.error = error.message;\r\n    }\r\n  }\r\n\r\n  async testServices() {\r\n    console.log('🔧 Проверка сервисов...');\r\n    \r\n    const services = [\r\n      { name: 'Gateway', port: 8000, path: 'services/gateway' },\r\n      { name: 'Auth', port: 3001, path: 'services/auth' },\r\n      { name: 'Machines', port: 3002, path: 'services/machines' },\r\n      { name: 'Inventory', port: 3003, path: 'services/inventory' },\r\n      { name: 'Tasks', port: 3004, path: 'services/tasks' },\r\n      { name: 'Telegram Bot', port: 3005, path: 'services/telegram-bot' },\r\n      { name: 'Notifications', port: 3006, path: 'services/notifications' }\r\n    ];\r\n    \r\n    this.results.tests.services = {};\r\n    \r\n    for (const service of services) {\r\n      const serviceResult = {\r\n        exists: fs.existsSync(service.path),\r\n        hasPackageJson: fs.existsSync(path.join(service.path, 'package.json')),\r\n        hasIndex: fs.existsSync(path.join(service.path, 'src', 'index.js')),\r\n        port: service.port,\r\n        status: 'Unknown'\r\n      };\r\n      \r\n      // Проверка содержимого index.js\r\n      const indexPath = path.join(service.path, 'src', 'index.js');\r\n      if (fs.existsSync(indexPath)) {\r\n        const content = fs.readFileSync(indexPath, 'utf8');\r\n        serviceResult.hasHealthCheck = content.includes('/health');\r\n        serviceResult.hasPortConfig = content.includes('process.env.PORT');\r\n        serviceResult.usesFastify = content.includes('fastify');\r\n        serviceResult.usesPrisma = content.includes('prisma');\r\n      }\r\n      \r\n      // Попытка проверки доступности (без запуска)\r\n      try {\r\n        const response = await this.checkPort(service.port);\r\n        serviceResult.status = response ? 'Running' : 'Down';\r\n      } catch (error) {\r\n        serviceResult.status = 'Down';\r\n      }\r\n      \r\n      this.results.tests.services[service.name] = serviceResult;\r\n    }\r\n  }\r\n\r\n  async checkPort(port) {\r\n    return new Promise((resolve) => {\r\n      const net = require('net');\r\n      const socket = new net.Socket();\r\n      \r\n      socket.setTimeout(1000);\r\n      socket.on('connect', () => {\r\n        socket.destroy();\r\n        resolve(true);\r\n      });\r\n      \r\n      socket.on('timeout', () => {\r\n        socket.destroy();\r\n        resolve(false);\r\n      });\r\n      \r\n      socket.on('error', () => {\r\n        resolve(false);\r\n      });\r\n      \r\n      socket.connect(port, 'localhost');\r\n    });\r\n  }\r\n\r\n  async testSecurity() {\r\n    console.log('🔒 Проверка безопасности...');\r\n    \r\n    try {\r\n      // Проверка .env файла\r\n      if (fs.existsSync('.env')) {\r\n        const env = fs.readFileSync('.env', 'utf8');\r\n        this.results.tests.security.hasJwtSecret = env.includes('JWT_SECRET');\r\n        this.results.tests.security.hasStrongJwtSecret = env.includes('JWT_SECRET') && \r\n          env.match(/JWT_SECRET=.{32,}/);\r\n      }\r\n      \r\n      // Проверка на hardcoded секреты в коде\r\n      const securityIssues = [];\r\n      const services = fs.readdirSync('services');\r\n      \r\n      services.forEach(service => {\r\n        const servicePath = path.join('services', service, 'src');\r\n        if (fs.existsSync(servicePath)) {\r\n          const files = this.getAllJsFiles(servicePath);\r\n          files.forEach(file => {\r\n            const content = fs.readFileSync(file, 'utf8');\r\n            \r\n            // Поиск потенциальных проблем безопасности\r\n            if (content.includes('password') && content.includes('=') && content.includes('\"')) {\r\n              securityIssues.push(`${file}: Potential hardcoded password`);\r\n            }\r\n            \r\n            if (content.includes('secret') && content.includes('=') && content.includes('\"')) {\r\n              securityIssues.push(`${file}: Potential hardcoded secret`);\r\n            }\r\n            \r\n            if (content.includes('api_key') && content.includes('=') && content.includes('\"')) {\r\n              securityIssues.push(`${file}: Potential hardcoded API key`);\r\n            }\r\n          });\r\n        }\r\n      });\r\n      \r\n      this.results.tests.security.issues = securityIssues;\r\n      \r\n      // Проверка CORS настроек\r\n      const gatewayPath = 'services/gateway/src/index.js';\r\n      if (fs.existsSync(gatewayPath)) {\r\n        const content = fs.readFileSync(gatewayPath, 'utf8');\r\n        this.results.tests.security.hasCors = content.includes('cors');\r\n        this.results.tests.security.corsWildcard = content.includes('origin: \"*\"');\r\n      }\r\n      \r\n    } catch (error) {\r\n      this.results.tests.security.error = error.message;\r\n    }\r\n  }\r\n\r\n  getAllJsFiles(dir) {\r\n    const files = [];\r\n    \r\n    function traverse(currentDir) {\r\n      const items = fs.readdirSync(currentDir);\r\n      items.forEach(item => {\r\n        const fullPath = path.join(currentDir, item);\r\n        const stat = fs.statSync(fullPath);\r\n        \r\n        if (stat.isDirectory()) {\r\n          traverse(fullPath);\r\n        } else if (item.endsWith('.js')) {\r\n          files.push(fullPath);\r\n        }\r\n      });\r\n    }\r\n    \r\n    traverse(dir);\r\n    return files;\r\n  }\r\n\r\n  saveResults() {\r\n    const filename = `test-results-${Date.now()}.json`;\r\n    fs.writeFileSync(filename, JSON.stringify(this.results, null, 2));\r\n    \r\n    console.log('\\n📊 Результаты тестирования:');\r\n    console.log(`✅ Сохранено в: ${filename}`);\r\n    \r\n    // Вывод summary\r\n    console.log('\\n📈 Summary:');\r\n    \r\n    // Сервисы\r\n    const servicesTotal = Object.keys(this.results.tests.services).length;\r\n    const servicesExist = Object.values(this.results.tests.services)\r\n      .filter(s => s.exists).length;\r\n    console.log(`- Сервисы: ${servicesExist}/${servicesTotal} существуют`);\r\n    \r\n    // Зависимости\r\n    if (this.results.tests.dependencies.vulnerabilities) {\r\n      const vuln = this.results.tests.dependencies.vulnerabilities;\r\n      if (typeof vuln === 'object') {\r\n        console.log(`- Уязвимости: ${vuln.total} (критических: ${vuln.critical})`);\r\n      }\r\n    }\r\n    \r\n    // База данных\r\n    if (this.results.tests.database.connection) {\r\n      console.log(`- База данных: ${this.results.tests.database.connection}`);\r\n    }\r\n    \r\n    // Безопасность\r\n    if (this.results.tests.security.issues) {\r\n      console.log(`- Проблемы безопасности: ${this.results.tests.security.issues.length}`);\r\n    }\r\n    \r\n    // Рекомендации\r\n    console.log('\\n💡 Рекомендации:');\r\n    this.generateRecommendations();\r\n  }\r\n\r\n  generateRecommendations() {\r\n    const recommendations = [];\r\n    \r\n    // Проверка сервисов\r\n    Object.entries(this.results.tests.services).forEach(([name, service]) => {\r\n      if (!service.exists) {\r\n        recommendations.push(`Сервис ${name} не найден`);\r\n      } else if (!service.hasPackageJson) {\r\n        recommendations.push(`Добавить package.json для сервиса ${name}`);\r\n      } else if (!service.hasHealthCheck) {\r\n        recommendations.push(`Добавить health check для сервиса ${name}`);\r\n      } else if (!service.hasPortConfig) {\r\n        recommendations.push(`Исправить конфигурацию портов для сервиса ${name}`);\r\n      }\r\n    });\r\n    \r\n    // Проверка безопасности\r\n    if (this.results.tests.security.issues && this.results.tests.security.issues.length > 0) {\r\n      recommendations.push('Исправить проблемы безопасности в коде');\r\n    }\r\n    \r\n    if (!this.results.tests.security.hasJwtSecret) {\r\n      recommendations.push('Добавить JWT_SECRET в переменные окружения');\r\n    }\r\n    \r\n    if (!this.results.tests.security.hasStrongJwtSecret) {\r\n      recommendations.push('Использовать более сильный JWT_SECRET (минимум 32 символа)');\r\n    }\r\n    \r\n    // Проверка базы данных\r\n    if (this.results.tests.database.connection && \r\n        this.results.tests.database.connection.includes('Failed')) {\r\n      recommendations.push('Исправить подключение к базе данных');\r\n    }\r\n    \r\n    // Проверка уязвимостей\r\n    if (this.results.tests.dependencies.vulnerabilities && \r\n        typeof this.results.tests.dependencies.vulnerabilities === 'object' &&\r\n        this.results.tests.dependencies.vulnerabilities.critical > 0) {\r\n      recommendations.push('Исправить критические уязвимости в зависимостях');\r\n    }\r\n    \r\n    recommendations.forEach((rec, index) => {\r\n      console.log(`  ${index + 1}. ${rec}`);\r\n    });\r\n    \r\n    if (recommendations.length === 0) {\r\n      console.log('  ✅ Критических проблем не обнаружено');\r\n    }\r\n  }\r\n}\r\n\r\n// Запуск тестов\r\nconst tester = new ProjectTester();\r\ntester.runAllTests().catch(console.error);\r\n",
  "services/audit/src/routes/reports.js": "const auditService = require('../services/auditService');\r\nconst incompleteDataService = require('../services/incompleteDataService');\r\n\r\nasync function reportsRoutes(fastify, options) {\r\n  // Общий отчет по активности системы\r\n  fastify.get('/system-activity', {\r\n    preHandler: [fastify.authenticate],\r\n    schema: {\r\n      querystring: {\r\n        type: 'object',\r\n        properties: {\r\n          dateFrom: { type: 'string', format: 'date-time' },\r\n          dateTo: { type: 'string', format: 'date-time' },\r\n          groupBy: { type: 'string', enum: ['hour', 'day', 'week', 'month'], default: 'day' }\r\n        },\r\n        required: ['dateFrom', 'dateTo']\r\n      }\r\n    }\r\n  }, async (request, reply) => {\r\n    try {\r\n      const { dateFrom, dateTo, groupBy } = request.query;\r\n      \r\n      // Получаем базовую статистику\r\n      const stats = await auditService.getUserActivityStats(dateFrom, dateTo);\r\n      \r\n      // Получаем статистику по незаполненным данным\r\n      const incompleteStats = await incompleteDataService.getIncompleteDataStats();\r\n      \r\n      return {\r\n        period: { dateFrom, dateTo, groupBy },\r\n        activity: stats,\r\n        incompleteData: incompleteStats,\r\n        generatedAt: new Date().toISOString()\r\n      };\r\n    } catch (error) {\r\n      reply.code(500).send({ error: error.message });\r\n    }\r\n  });\r\n\r\n  // Отчет по пользователям\r\n  fastify.get('/users', {\r\n    preHandler: [fastify.authenticate],\r\n    schema: {\r\n      querystring: {\r\n        type: 'object',\r\n        properties: {\r\n          dateFrom: { type: 'string', format: 'date-time' },\r\n          dateTo: { type: 'string', format: 'date-time' },\r\n          userId: { type: 'string' },\r\n          includeInactive: { type: 'boolean', default: false }\r\n        }\r\n      }\r\n    }\r\n  }, async (request, reply) => {\r\n    try {\r\n      const { dateFrom, dateTo, userId, includeInactive } = request.query;\r\n      \r\n      const filters = {};\r\n      if (dateFrom) filters.dateFrom = dateFrom;\r\n      if (dateTo) filters.dateTo = dateTo;\r\n      if (userId) filters.userId = userId;\r\n\r\n      // Получаем логи активности\r\n      const activityLogs = await auditService.getAuditLogs(filters, { page: 1, limit: 1000 });\r\n      \r\n      // Получаем незаполненные данные по пользователям\r\n      const incompleteData = await incompleteDataService.getIncompleteDataReport(\r\n        { userId, status: 'PENDING' },\r\n        { page: 1, limit: 100 }\r\n      );\r\n\r\n      // Группируем данные по пользователям\r\n      const userReport = {};\r\n      \r\n      for (const log of activityLogs.logs) {\r\n        if (!log.userId) continue;\r\n        \r\n        if (!userReport[log.userId]) {\r\n          userReport[log.userId] = {\r\n            user: log.user,\r\n            totalActions: 0,\r\n            actionsByType: {},\r\n            lastActivity: null,\r\n            incompleteDataCount: 0\r\n          };\r\n        }\r\n        \r\n        userReport[log.userId].totalActions++;\r\n        userReport[log.userId].actionsByType[log.action] = \r\n          (userReport[log.userId].actionsByType[log.action] || 0) + 1;\r\n        \r\n        if (!userReport[log.userId].lastActivity || \r\n            new Date(log.createdAt) > new Date(userReport[log.userId].lastActivity)) {\r\n          userReport[log.userId].lastActivity = log.createdAt;\r\n        }\r\n      }\r\n\r\n      // Добавляем информацию о незаполненных данных\r\n      for (const incomplete of incompleteData.incompleteData) {\r\n        if (incomplete.userId && userReport[incomplete.userId]) {\r\n          userReport[incomplete.userId].incompleteDataCount++;\r\n        }\r\n      }\r\n\r\n      return {\r\n        period: { dateFrom, dateTo },\r\n        users: Object.values(userReport),\r\n        summary: {\r\n          totalUsers: Object.keys(userReport).length,\r\n          totalActions: activityLogs.pagination.total,\r\n          totalIncompleteData: incompleteData.pagination.total\r\n        },\r\n        generatedAt: new Date().toISOString()\r\n      };\r\n    } catch (error) {\r\n      reply.code(500).send({ error: error.message });\r\n    }\r\n  });\r\n\r\n  // Отчет по сущностям\r\n  fastify.get('/entities', {\r\n    preHandler: [fastify.authenticate],\r\n    schema: {\r\n      querystring: {\r\n        type: 'object',\r\n        properties: {\r\n          dateFrom: { type: 'string', format: 'date-time' },\r\n          dateTo: { type: 'string', format: 'date-time' },\r\n          entity: { type: 'string' }\r\n        }\r\n      }\r\n    }\r\n  }, async (request, reply) => {\r\n    try {\r\n      const { dateFrom, dateTo, entity } = request.query;\r\n      \r\n      const filters = {};\r\n      if (dateFrom) filters.dateFrom = dateFrom;\r\n      if (dateTo) filters.dateTo = dateTo;\r\n      if (entity) filters.entity = entity;\r\n\r\n      // Получаем логи по сущностям\r\n      const entityLogs = await auditService.getAuditLogs(filters, { page: 1, limit: 1000 });\r\n      \r\n      // Группируем по сущностям\r\n      const entityReport = {};\r\n      \r\n      for (const log of entityLogs.logs) {\r\n        if (!entityReport[log.entity]) {\r\n          entityReport[log.entity] = {\r\n            entity: log.entity,\r\n            totalActions: 0,\r\n            actionsByType: {},\r\n            uniqueEntities: new Set(),\r\n            lastActivity: null\r\n          };\r\n        }\r\n        \r\n        entityReport[log.entity].totalActions++;\r\n        entityReport[log.entity].actionsByType[log.action] = \r\n          (entityReport[log.entity].actionsByType[log.action] || 0) + 1;\r\n        \r\n        if (log.entityId) {\r\n          entityReport[log.entity].uniqueEntities.add(log.entityId);\r\n        }\r\n        \r\n        if (!entityReport[log.entity].lastActivity || \r\n            new Date(log.createdAt) > new Date(entityReport[log.entity].lastActivity)) {\r\n          entityReport[log.entity].lastActivity = log.createdAt;\r\n        }\r\n      }\r\n\r\n      // Преобразуем Set в число\r\n      Object.values(entityReport).forEach(report => {\r\n        report.uniqueEntitiesCount = report.uniqueEntities.size;\r\n        delete report.uniqueEntities;\r\n      });\r\n\r\n      return {\r\n        period: { dateFrom, dateTo },\r\n        entities: Object.values(entityReport),\r\n        summary: {\r\n          totalEntities: Object.keys(entityReport).length,\r\n          totalActions: entityLogs.pagination.total\r\n        },\r\n        generatedAt: new Date().toISOString()\r\n      };\r\n    } catch (error) {\r\n      reply.code(500).send({ error: error.message });\r\n    }\r\n  });\r\n\r\n  // Отчет по ошибкам и проблемам\r\n  fastify.get('/errors', {\r\n    preHandler: [fastify.authenticate],\r\n    schema: {\r\n      querystring: {\r\n        type: 'object',\r\n        properties: {\r\n          dateFrom: { type: 'string', format: 'date-time' },\r\n          dateTo: { type: 'string', format: 'date-time' },\r\n          severity: { type: 'string', enum: ['INFO', 'WARNING', 'ERROR', 'CRITICAL'] }\r\n        }\r\n      }\r\n    }\r\n  }, async (request, reply) => {\r\n    try {\r\n      const { dateFrom, dateTo, severity } = request.query;\r\n      \r\n      const filters = {\r\n        action: 'ERROR'\r\n      };\r\n      if (dateFrom) filters.dateFrom = dateFrom;\r\n      if (dateTo) filters.dateTo = dateTo;\r\n\r\n      // Получаем логи ошибок\r\n      const errorLogs = await auditService.getAuditLogs(filters, { page: 1, limit: 500 });\r\n      \r\n      // Получаем логи валидации с ошибками\r\n      const { PrismaClient } = require('@prisma/client');\r\n      const prisma = new PrismaClient();\r\n      \r\n      const validationWhere = {\r\n        isValid: false\r\n      };\r\n      if (severity) validationWhere.severity = severity;\r\n      if (dateFrom) validationWhere.createdAt = { gte: new Date(dateFrom) };\r\n      if (dateTo) {\r\n        if (validationWhere.createdAt) {\r\n          validationWhere.createdAt.lte = new Date(dateTo);\r\n        } else {\r\n          validationWhere.createdAt = { lte: new Date(dateTo) };\r\n        }\r\n      }\r\n\r\n      const validationErrors = await prisma.dataValidationLog.findMany({\r\n        where: validationWhere,\r\n        include: {\r\n          user: {\r\n            select: { id: true, name: true, email: true }\r\n          }\r\n        },\r\n        orderBy: { createdAt: 'desc' },\r\n        take: 200\r\n      });\r\n\r\n      // Группируем ошибки\r\n      const errorsByType = {};\r\n      const errorsByEntity = {};\r\n      \r\n      for (const error of errorLogs.logs) {\r\n        const errorType = error.metadata?.errorType || 'SYSTEM_ERROR';\r\n        errorsByType[errorType] = (errorsByType[errorType] || 0) + 1;\r\n        errorsByEntity[error.entity] = (errorsByEntity[error.entity] || 0) + 1;\r\n      }\r\n\r\n      const validationErrorsByField = {};\r\n      const validationErrorsBySeverity = {};\r\n      \r\n      for (const error of validationErrors) {\r\n        const key = `${error.entity}.${error.fieldName}`;\r\n        validationErrorsByField[key] = (validationErrorsByField[key] || 0) + 1;\r\n        validationErrorsBySeverity[error.severity] = (validationErrorsBySeverity[error.severity] || 0) + 1;\r\n      }\r\n\r\n      return {\r\n        period: { dateFrom, dateTo },\r\n        systemErrors: {\r\n          total: errorLogs.pagination.total,\r\n          byType: errorsByType,\r\n          byEntity: errorsByEntity,\r\n          recent: errorLogs.logs.slice(0, 10)\r\n        },\r\n        validationErrors: {\r\n          total: validationErrors.length,\r\n          byField: validationErrorsByField,\r\n          bySeverity: validationErrorsBySeverity,\r\n          recent: validationErrors.slice(0, 10)\r\n        },\r\n        generatedAt: new Date().toISOString()\r\n      };\r\n    } catch (error) {\r\n      reply.code(500).send({ error: error.message });\r\n    }\r\n  });\r\n\r\n  // Экспорт отчета в CSV\r\n  fastify.get('/export/:reportType', {\r\n    preHandler: [fastify.authenticate],\r\n    schema: {\r\n      params: {\r\n        type: 'object',\r\n        properties: {\r\n          reportType: { type: 'string', enum: ['audit-logs', 'incomplete-data', 'user-activity'] }\r\n        },\r\n        required: ['reportType']\r\n      },\r\n      querystring: {\r\n        type: 'object',\r\n        properties: {\r\n          dateFrom: { type: 'string', format: 'date-time' },\r\n          dateTo: { type: 'string', format: 'date-time' },\r\n          format: { type: 'string', enum: ['csv', 'json'], default: 'csv' }\r\n        }\r\n      }\r\n    }\r\n  }, async (request, reply) => {\r\n    try {\r\n      const { reportType } = request.params;\r\n      const { dateFrom, dateTo, format } = request.query;\r\n      \r\n      let data;\r\n      let filename;\r\n      \r\n      switch (reportType) {\r\n        case 'audit-logs':\r\n          const auditData = await auditService.getAuditLogs(\r\n            { dateFrom, dateTo },\r\n            { page: 1, limit: 10000 }\r\n          );\r\n          data = auditData.logs;\r\n          filename = `audit-logs-${new Date().toISOString().split('T')[0]}`;\r\n          break;\r\n          \r\n        case 'incomplete-data':\r\n          const incompleteData = await incompleteDataService.getIncompleteDataReport(\r\n            { dateFrom, dateTo },\r\n            { page: 1, limit: 10000 }\r\n          );\r\n          data = incompleteData.incompleteData;\r\n          filename = `incomplete-data-${new Date().toISOString().split('T')[0]}`;\r\n          break;\r\n          \r\n        case 'user-activity':\r\n          const activityStats = await auditService.getUserActivityStats(\r\n            dateFrom || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),\r\n            dateTo || new Date().toISOString()\r\n          );\r\n          data = activityStats.userActions;\r\n          filename = `user-activity-${new Date().toISOString().split('T')[0]}`;\r\n          break;\r\n          \r\n        default:\r\n          return reply.code(400).send({ error: 'Неподдерживаемый тип отчета' });\r\n      }\r\n\r\n      if (format === 'json') {\r\n        reply.header('Content-Type', 'application/json');\r\n        reply.header('Content-Disposition', `attachment; filename=\"${filename}.json\"`);\r\n        return data;\r\n      } else {\r\n        // Простая CSV генерация\r\n        const csvData = convertToCSV(data);\r\n        reply.header('Content-Type', 'text/csv');\r\n        reply.header('Content-Disposition', `attachment; filename=\"${filename}.csv\"`);\r\n        return csvData;\r\n      }\r\n    } catch (error) {\r\n      reply.code(500).send({ error: error.message });\r\n    }\r\n  });\r\n}\r\n\r\n// Вспомогательная функция для конвертации в CSV\r\nfunction convertToCSV(data) {\r\n  if (!data || data.length === 0) {\r\n    return '';\r\n  }\r\n  \r\n  const headers = Object.keys(data[0]);\r\n  const csvRows = [];\r\n  \r\n  // Добавляем заголовки\r\n  csvRows.push(headers.join(','));\r\n  \r\n  // Добавляем данные\r\n  for (const row of data) {\r\n    const values = headers.map(header => {\r\n      const value = row[header];\r\n      if (value === null || value === undefined) {\r\n        return '';\r\n      }\r\n      if (typeof value === 'object') {\r\n        return `\"${JSON.stringify(value).replace(/\"/g, '\"\"')}\"`;\r\n      }\r\n      return `\"${String(value).replace(/\"/g, '\"\"')}\"`;\r\n    });\r\n    csvRows.push(values.join(','));\r\n  }\r\n  \r\n  return csvRows.join('\\n');\r\n}\r\n\r\nmodule.exports = reportsRoutes;\r\n",
  "services/audit/src/services/auditService.js": "const { PrismaClient } = require('@prisma/client');\r\nconst moment = require('moment');\r\nconst _ = require('lodash');\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nclass AuditService {\r\n  /**\r\n   * Логирование системного действия\r\n   */\r\n  async logSystemAction(data) {\r\n    try {\r\n      const auditLog = await prisma.systemAuditLog.create({\r\n        data: {\r\n          userId: data.userId,\r\n          sessionId: data.sessionId,\r\n          action: data.action,\r\n          entity: data.entity,\r\n          entityId: data.entityId,\r\n          description: data.description,\r\n          oldValues: data.oldValues,\r\n          newValues: data.newValues,\r\n          inputData: data.inputData,\r\n          ipAddress: data.ipAddress,\r\n          userAgent: data.userAgent,\r\n          endpoint: data.endpoint,\r\n          method: data.method,\r\n          statusCode: data.statusCode,\r\n          responseTime: data.responseTime,\r\n          errorMessage: data.errorMessage,\r\n          metadata: data.metadata\r\n        }\r\n      });\r\n\r\n      return auditLog;\r\n    } catch (error) {\r\n      console.error('Ошибка при логировании системного действия:', error);\r\n      // Не прерываем выполнение основной логики при ошибке логирования\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Логирование изменений данных\r\n   */\r\n  async logDataChange(userId, entity, entityId, oldData, newData, action = 'UPDATE') {\r\n    try {\r\n      const changes = this.calculateChanges(oldData, newData);\r\n      \r\n      await this.logSystemAction({\r\n        userId,\r\n        action,\r\n        entity,\r\n        entityId,\r\n        description: `${action} ${entity} ${entityId}`,\r\n        oldValues: oldData,\r\n        newValues: newData,\r\n        metadata: { changes }\r\n      });\r\n\r\n      // Проверяем на незаполненные поля\r\n      await this.checkIncompleteData(userId, entity, entityId, newData);\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при логировании изменений данных:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Вычисление изменений между старыми и новыми данными\r\n   */\r\n  calculateChanges(oldData, newData) {\r\n    const changes = {};\r\n    \r\n    if (!oldData && newData) {\r\n      return { type: 'CREATE', data: newData };\r\n    }\r\n    \r\n    if (oldData && !newData) {\r\n      return { type: 'DELETE', data: oldData };\r\n    }\r\n\r\n    const allKeys = new Set([...Object.keys(oldData || {}), ...Object.keys(newData || {})]);\r\n    \r\n    for (const key of allKeys) {\r\n      const oldValue = oldData?.[key];\r\n      const newValue = newData?.[key];\r\n      \r\n      if (!_.isEqual(oldValue, newValue)) {\r\n        changes[key] = {\r\n          from: oldValue,\r\n          to: newValue\r\n        };\r\n      }\r\n    }\r\n\r\n    return changes;\r\n  }\r\n\r\n  /**\r\n   * Проверка на незаполненные данные\r\n   */\r\n  async checkIncompleteData(userId, entity, entityId, data) {\r\n    try {\r\n      const requiredFields = this.getRequiredFields(entity);\r\n      const missingFields = [];\r\n      const partialData = {};\r\n\r\n      for (const field of requiredFields) {\r\n        const value = data?.[field];\r\n        if (!value || (typeof value === 'string' && value.trim() === '')) {\r\n          missingFields.push(field);\r\n        } else {\r\n          partialData[field] = value;\r\n        }\r\n      }\r\n\r\n      if (missingFields.length > 0) {\r\n        const completionRate = ((requiredFields.length - missingFields.length) / requiredFields.length) * 100;\r\n\r\n        await prisma.incompleteDataLog.upsert({\r\n          where: {\r\n            entity_entityId: {\r\n              entity,\r\n              entityId\r\n            }\r\n          },\r\n          update: {\r\n            userId,\r\n            requiredFields,\r\n            missingFields,\r\n            partialData,\r\n            completionRate,\r\n            status: completionRate === 100 ? 'COMPLETED' : 'PENDING',\r\n            completedAt: completionRate === 100 ? new Date() : null,\r\n            updatedAt: new Date()\r\n          },\r\n          create: {\r\n            userId,\r\n            entity,\r\n            entityId,\r\n            requiredFields,\r\n            missingFields,\r\n            partialData,\r\n            completionRate,\r\n            status: completionRate === 100 ? 'COMPLETED' : 'PENDING',\r\n            completedAt: completionRate === 100 ? new Date() : null\r\n          }\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error('Ошибка при проверке незаполненных данных:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение обязательных полей для сущности\r\n   */\r\n  getRequiredFields(entity) {\r\n    const requiredFieldsMap = {\r\n      'User': ['name', 'email', 'phoneNumber'],\r\n      'Machine': ['code', 'serialNumber', 'type', 'name', 'locationId'],\r\n      'Task': ['title', 'description', 'assignedToId', 'dueDate'],\r\n      'InventoryItem': ['name', 'sku', 'unit', 'category', 'minQuantity'],\r\n      'Location': ['name', 'address'],\r\n      'Route': ['name', 'driverId', 'startTime'],\r\n      'ServiceHistory': ['machineId', 'serviceType', 'description', 'performedById'],\r\n      'StockMovement': ['itemId', 'userId', 'type', 'quantity', 'reason'],\r\n      'Recipe': ['name', 'description'],\r\n      'DriverLog': ['driverId', 'type', 'description']\r\n    };\r\n\r\n    return requiredFieldsMap[entity] || [];\r\n  }\r\n\r\n  /**\r\n   * Логирование входа пользователя\r\n   */\r\n  async logUserLogin(userId, sessionId, ipAddress, userAgent) {\r\n    try {\r\n      // Создаем сессию пользователя\r\n      await prisma.userSession.create({\r\n        data: {\r\n          userId,\r\n          sessionId,\r\n          ipAddress,\r\n          userAgent,\r\n          loginAt: new Date(),\r\n          lastActivity: new Date(),\r\n          isActive: true\r\n        }\r\n      });\r\n\r\n      // Логируем действие\r\n      await this.logSystemAction({\r\n        userId,\r\n        sessionId,\r\n        action: 'LOGIN',\r\n        entity: 'USER_SESSION',\r\n        entityId: userId,\r\n        description: 'Пользователь вошел в систему',\r\n        ipAddress,\r\n        userAgent\r\n      });\r\n\r\n      // Обновляем время последнего входа\r\n      await prisma.user.update({\r\n        where: { id: userId },\r\n        data: { lastLogin: new Date() }\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при логировании входа пользователя:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Логирование выхода пользователя\r\n   */\r\n  async logUserLogout(userId, sessionId) {\r\n    try {\r\n      // Закрываем сессию\r\n      await prisma.userSession.updateMany({\r\n        where: {\r\n          userId,\r\n          sessionId,\r\n          isActive: true\r\n        },\r\n        data: {\r\n          logoutAt: new Date(),\r\n          isActive: false\r\n        }\r\n      });\r\n\r\n      // Логируем действие\r\n      await this.logSystemAction({\r\n        userId,\r\n        sessionId,\r\n        action: 'LOGOUT',\r\n        entity: 'USER_SESSION',\r\n        entityId: userId,\r\n        description: 'Пользователь вышел из системы'\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при логировании выхода пользователя:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Обновление активности пользователя\r\n   */\r\n  async updateUserActivity(userId, sessionId) {\r\n    try {\r\n      await prisma.userSession.updateMany({\r\n        where: {\r\n          userId,\r\n          sessionId,\r\n          isActive: true\r\n        },\r\n        data: {\r\n          lastActivity: new Date()\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.error('Ошибка при обновлении активности пользователя:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение логов аудита с фильтрацией\r\n   */\r\n  async getAuditLogs(filters = {}, pagination = {}) {\r\n    try {\r\n      const {\r\n        userId,\r\n        action,\r\n        entity,\r\n        dateFrom,\r\n        dateTo,\r\n        sessionId\r\n      } = filters;\r\n\r\n      const {\r\n        page = 1,\r\n        limit = 50\r\n      } = pagination;\r\n\r\n      const where = {};\r\n\r\n      if (userId) where.userId = userId;\r\n      if (action) where.action = action;\r\n      if (entity) where.entity = entity;\r\n      if (sessionId) where.sessionId = sessionId;\r\n      \r\n      if (dateFrom || dateTo) {\r\n        where.createdAt = {};\r\n        if (dateFrom) where.createdAt.gte = new Date(dateFrom);\r\n        if (dateTo) where.createdAt.lte = new Date(dateTo);\r\n      }\r\n\r\n      const [logs, total] = await Promise.all([\r\n        prisma.systemAuditLog.findMany({\r\n          where,\r\n          include: {\r\n            user: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                email: true\r\n              }\r\n            }\r\n          },\r\n          orderBy: {\r\n            createdAt: 'desc'\r\n          },\r\n          skip: (page - 1) * limit,\r\n          take: limit\r\n        }),\r\n        prisma.systemAuditLog.count({ where })\r\n      ]);\r\n\r\n      return {\r\n        logs,\r\n        pagination: {\r\n          page,\r\n          limit,\r\n          total,\r\n          pages: Math.ceil(total / limit)\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при получении логов аудита:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение статистики активности пользователей\r\n   */\r\n  async getUserActivityStats(dateFrom, dateTo) {\r\n    try {\r\n      const where = {\r\n        createdAt: {\r\n          gte: new Date(dateFrom),\r\n          lte: new Date(dateTo)\r\n        }\r\n      };\r\n\r\n      const [totalActions, userActions, topActions, topEntities] = await Promise.all([\r\n        // Общее количество действий\r\n        prisma.systemAuditLog.count({ where }),\r\n        \r\n        // Действия по пользователям\r\n        prisma.systemAuditLog.groupBy({\r\n          by: ['userId'],\r\n          where,\r\n          _count: {\r\n            id: true\r\n          },\r\n          orderBy: {\r\n            _count: {\r\n              id: 'desc'\r\n            }\r\n          },\r\n          take: 10\r\n        }),\r\n        \r\n        // Топ действий\r\n        prisma.systemAuditLog.groupBy({\r\n          by: ['action'],\r\n          where,\r\n          _count: {\r\n            id: true\r\n          },\r\n          orderBy: {\r\n            _count: {\r\n              id: 'desc'\r\n            }\r\n          },\r\n          take: 10\r\n        }),\r\n        \r\n        // Топ сущностей\r\n        prisma.systemAuditLog.groupBy({\r\n          by: ['entity'],\r\n          where,\r\n          _count: {\r\n            id: true\r\n          },\r\n          orderBy: {\r\n            _count: {\r\n              id: 'desc'\r\n            }\r\n          },\r\n          take: 10\r\n        })\r\n      ]);\r\n\r\n      // Получаем информацию о пользователях\r\n      const userIds = userActions.map(ua => ua.userId).filter(Boolean);\r\n      const users = await prisma.user.findMany({\r\n        where: { id: { in: userIds } },\r\n        select: { id: true, name: true, email: true }\r\n      });\r\n\r\n      const userMap = users.reduce((acc, user) => {\r\n        acc[user.id] = user;\r\n        return acc;\r\n      }, {});\r\n\r\n      const userActionsWithNames = userActions.map(ua => ({\r\n        ...ua,\r\n        user: ua.userId ? userMap[ua.userId] : null\r\n      }));\r\n\r\n      return {\r\n        totalActions,\r\n        userActions: userActionsWithNames,\r\n        topActions,\r\n        topEntities\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при получении статистики активности:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Очистка старых логов\r\n   */\r\n  async cleanupOldLogs() {\r\n    try {\r\n      const retentionDays = parseInt(process.env.AUDIT_RETENTION_DAYS) || 90;\r\n      const cutoffDate = moment().subtract(retentionDays, 'days').toDate();\r\n\r\n      const [deletedAuditLogs, deletedSystemLogs] = await Promise.all([\r\n        prisma.auditLog.deleteMany({\r\n          where: {\r\n            createdAt: {\r\n              lt: cutoffDate\r\n            }\r\n          }\r\n        }),\r\n        prisma.systemAuditLog.deleteMany({\r\n          where: {\r\n            createdAt: {\r\n              lt: cutoffDate\r\n            }\r\n          }\r\n        })\r\n      ]);\r\n\r\n      console.log(`Очищено ${deletedAuditLogs.count} старых audit логов и ${deletedSystemLogs.count} системных логов`);\r\n\r\n      return {\r\n        deletedAuditLogs: deletedAuditLogs.count,\r\n        deletedSystemLogs: deletedSystemLogs.count\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при очистке старых логов:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Валидация данных\r\n   */\r\n  async validateData(userId, entity, entityId, fieldName, fieldValue, validationType) {\r\n    try {\r\n      let isValid = true;\r\n      let errorMessage = null;\r\n\r\n      switch (validationType) {\r\n        case 'REQUIRED':\r\n          isValid = fieldValue !== null && fieldValue !== undefined && fieldValue !== '';\r\n          if (!isValid) errorMessage = 'Поле обязательно для заполнения';\r\n          break;\r\n          \r\n        case 'FORMAT':\r\n          // Проверка формата email\r\n          if (fieldName === 'email') {\r\n            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n            isValid = emailRegex.test(fieldValue);\r\n            if (!isValid) errorMessage = 'Неверный формат email';\r\n          }\r\n          break;\r\n          \r\n        case 'LENGTH':\r\n          if (typeof fieldValue === 'string') {\r\n            isValid = fieldValue.length >= 3 && fieldValue.length <= 255;\r\n            if (!isValid) errorMessage = 'Длина должна быть от 3 до 255 символов';\r\n          }\r\n          break;\r\n          \r\n        case 'UNIQUE':\r\n          // Проверка уникальности (упрощенная)\r\n          if (entity === 'User' && fieldName === 'email') {\r\n            const existingUser = await prisma.user.findFirst({\r\n              where: {\r\n                email: fieldValue,\r\n                id: { not: entityId }\r\n              }\r\n            });\r\n            isValid = !existingUser;\r\n            if (!isValid) errorMessage = 'Email уже используется';\r\n          }\r\n          break;\r\n      }\r\n\r\n      // Логируем результат валидации\r\n      await prisma.dataValidationLog.create({\r\n        data: {\r\n          userId,\r\n          entity,\r\n          entityId,\r\n          fieldName,\r\n          fieldValue: String(fieldValue),\r\n          validationType,\r\n          isValid,\r\n          errorMessage,\r\n          severity: isValid ? 'INFO' : 'ERROR'\r\n        }\r\n      });\r\n\r\n      return { isValid, errorMessage };\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при валидации данных:', error);\r\n      return { isValid: false, errorMessage: 'Ошибка валидации' };\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = new AuditService();\r\n",
  "services/audit/src/services/incompleteDataService.js": "const { PrismaClient } = require('@prisma/client');\r\nconst moment = require('moment');\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nclass IncompleteDataService {\r\n  /**\r\n   * Получение отчета по незаполненным данным\r\n   */\r\n  async getIncompleteDataReport(filters = {}, pagination = {}) {\r\n    try {\r\n      const {\r\n        userId,\r\n        entity,\r\n        status,\r\n        completionRateMin,\r\n        completionRateMax,\r\n        dateFrom,\r\n        dateTo\r\n      } = filters;\r\n\r\n      const {\r\n        page = 1,\r\n        limit = 50\r\n      } = pagination;\r\n\r\n      const where = {};\r\n\r\n      if (userId) where.userId = userId;\r\n      if (entity) where.entity = entity;\r\n      if (status) where.status = status;\r\n      \r\n      if (completionRateMin !== undefined || completionRateMax !== undefined) {\r\n        where.completionRate = {};\r\n        if (completionRateMin !== undefined) where.completionRate.gte = completionRateMin;\r\n        if (completionRateMax !== undefined) where.completionRate.lte = completionRateMax;\r\n      }\r\n      \r\n      if (dateFrom || dateTo) {\r\n        where.createdAt = {};\r\n        if (dateFrom) where.createdAt.gte = new Date(dateFrom);\r\n        if (dateTo) where.createdAt.lte = new Date(dateTo);\r\n      }\r\n\r\n      const [incompleteData, total] = await Promise.all([\r\n        prisma.incompleteDataLog.findMany({\r\n          where,\r\n          include: {\r\n            user: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                email: true\r\n              }\r\n            }\r\n          },\r\n          orderBy: [\r\n            { completionRate: 'asc' },\r\n            { createdAt: 'desc' }\r\n          ],\r\n          skip: (page - 1) * limit,\r\n          take: limit\r\n        }),\r\n        prisma.incompleteDataLog.count({ where })\r\n      ]);\r\n\r\n      return {\r\n        incompleteData,\r\n        pagination: {\r\n          page,\r\n          limit,\r\n          total,\r\n          pages: Math.ceil(total / limit)\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при получении отчета по незаполненным данным:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение статистики по незаполненным данным\r\n   */\r\n  async getIncompleteDataStats() {\r\n    try {\r\n      const [\r\n        totalIncomplete,\r\n        byEntity,\r\n        byUser,\r\n        byStatus,\r\n        avgCompletionRate,\r\n        oldestIncomplete\r\n      ] = await Promise.all([\r\n        // Общее количество незаполненных записей\r\n        prisma.incompleteDataLog.count({\r\n          where: { status: { not: 'COMPLETED' } }\r\n        }),\r\n        \r\n        // По сущностям\r\n        prisma.incompleteDataLog.groupBy({\r\n          by: ['entity'],\r\n          where: { status: { not: 'COMPLETED' } },\r\n          _count: { id: true },\r\n          _avg: { completionRate: true },\r\n          orderBy: { _count: { id: 'desc' } }\r\n        }),\r\n        \r\n        // По пользователям\r\n        prisma.incompleteDataLog.groupBy({\r\n          by: ['userId'],\r\n          where: { \r\n            status: { not: 'COMPLETED' },\r\n            userId: { not: null }\r\n          },\r\n          _count: { id: true },\r\n          _avg: { completionRate: true },\r\n          orderBy: { _count: { id: 'desc' } },\r\n          take: 10\r\n        }),\r\n        \r\n        // По статусам\r\n        prisma.incompleteDataLog.groupBy({\r\n          by: ['status'],\r\n          _count: { id: true },\r\n          orderBy: { _count: { id: 'desc' } }\r\n        }),\r\n        \r\n        // Средний процент заполнения\r\n        prisma.incompleteDataLog.aggregate({\r\n          where: { status: { not: 'COMPLETED' } },\r\n          _avg: { completionRate: true }\r\n        }),\r\n        \r\n        // Самые старые незаполненные записи\r\n        prisma.incompleteDataLog.findMany({\r\n          where: { status: { not: 'COMPLETED' } },\r\n          include: {\r\n            user: {\r\n              select: { id: true, name: true, email: true }\r\n            }\r\n          },\r\n          orderBy: { createdAt: 'asc' },\r\n          take: 5\r\n        })\r\n      ]);\r\n\r\n      // Получаем информацию о пользователях\r\n      const userIds = byUser.map(u => u.userId).filter(Boolean);\r\n      const users = await prisma.user.findMany({\r\n        where: { id: { in: userIds } },\r\n        select: { id: true, name: true, email: true }\r\n      });\r\n\r\n      const userMap = users.reduce((acc, user) => {\r\n        acc[user.id] = user;\r\n        return acc;\r\n      }, {});\r\n\r\n      const byUserWithNames = byUser.map(u => ({\r\n        ...u,\r\n        user: u.userId ? userMap[u.userId] : null\r\n      }));\r\n\r\n      return {\r\n        totalIncomplete,\r\n        byEntity,\r\n        byUser: byUserWithNames,\r\n        byStatus,\r\n        avgCompletionRate: avgCompletionRate._avg.completionRate || 0,\r\n        oldestIncomplete\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при получении статистики по незаполненным данным:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Отправка напоминаний о незаполненных данных\r\n   */\r\n  async sendReminders() {\r\n    try {\r\n      const pendingData = await prisma.incompleteDataLog.findMany({\r\n        where: {\r\n          status: 'PENDING',\r\n          userId: { not: null },\r\n          OR: [\r\n            { lastReminderAt: null },\r\n            { \r\n              lastReminderAt: {\r\n                lt: moment().subtract(24, 'hours').toDate()\r\n              }\r\n            }\r\n          ]\r\n        },\r\n        include: {\r\n          user: {\r\n            select: { id: true, name: true, email: true, telegramId: true }\r\n          }\r\n        },\r\n        take: 100 // Ограничиваем количество напоминаний за раз\r\n      });\r\n\r\n      const reminders = [];\r\n\r\n      for (const item of pendingData) {\r\n        try {\r\n          // Создаем уведомление\r\n          const notification = await prisma.notification.create({\r\n            data: {\r\n              userId: item.userId,\r\n              type: 'SYSTEM_ALERT',\r\n              title: 'Незаполненные данные',\r\n              message: `У вас есть незаполненные поля в ${item.entity}. Процент заполнения: ${item.completionRate.toFixed(1)}%`,\r\n              data: {\r\n                entity: item.entity,\r\n                entityId: item.entityId,\r\n                missingFields: item.missingFields,\r\n                completionRate: item.completionRate\r\n              }\r\n            }\r\n          });\r\n\r\n          // Обновляем счетчик напоминаний\r\n          await prisma.incompleteDataLog.update({\r\n            where: { id: item.id },\r\n            data: {\r\n              remindersSent: item.remindersSent + 1,\r\n              lastReminderAt: new Date()\r\n            }\r\n          });\r\n\r\n          reminders.push({\r\n            userId: item.userId,\r\n            entity: item.entity,\r\n            entityId: item.entityId,\r\n            notificationId: notification.id\r\n          });\r\n\r\n        } catch (error) {\r\n          console.error(`Ошибка при отправке напоминания для ${item.id}:`, error);\r\n        }\r\n      }\r\n\r\n      console.log(`Отправлено ${reminders.length} напоминаний о незаполненных данных`);\r\n      return reminders;\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при отправке напоминаний:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Обработка незаполненных данных (cron задача)\r\n   */\r\n  async processIncompleteData() {\r\n    try {\r\n      console.log('Запуск обработки незаполненных данных...');\r\n\r\n      // Отправляем напоминания\r\n      const reminders = await this.sendReminders();\r\n\r\n      // Помечаем старые записи как просроченные\r\n      const expiredThreshold = moment().subtract(30, 'days').toDate();\r\n      const expiredResult = await prisma.incompleteDataLog.updateMany({\r\n        where: {\r\n          status: 'PENDING',\r\n          createdAt: { lt: expiredThreshold }\r\n        },\r\n        data: {\r\n          status: 'EXPIRED'\r\n        }\r\n      });\r\n\r\n      // Проверяем завершенные записи\r\n      const completedResult = await prisma.incompleteDataLog.updateMany({\r\n        where: {\r\n          status: { in: ['PENDING', 'IN_PROGRESS'] },\r\n          completionRate: 100\r\n        },\r\n        data: {\r\n          status: 'COMPLETED',\r\n          completedAt: new Date()\r\n        }\r\n      });\r\n\r\n      console.log(`Обработка завершена:\r\n        - Отправлено напоминаний: ${reminders.length}\r\n        - Помечено как просроченные: ${expiredResult.count}\r\n        - Помечено как завершенные: ${completedResult.count}`);\r\n\r\n      return {\r\n        remindersSent: reminders.length,\r\n        expired: expiredResult.count,\r\n        completed: completedResult.count\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при обработке незаполненных данных:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение детальной информации о незаполненной записи\r\n   */\r\n  async getIncompleteDataDetails(id) {\r\n    try {\r\n      const incompleteData = await prisma.incompleteDataLog.findUnique({\r\n        where: { id },\r\n        include: {\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              phoneNumber: true\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      if (!incompleteData) {\r\n        throw new Error('Запись не найдена');\r\n      }\r\n\r\n      // Получаем историю изменений для этой сущности\r\n      const auditHistory = await prisma.systemAuditLog.findMany({\r\n        where: {\r\n          entity: incompleteData.entity,\r\n          entityId: incompleteData.entityId\r\n        },\r\n        include: {\r\n          user: {\r\n            select: { id: true, name: true, email: true }\r\n          }\r\n        },\r\n        orderBy: { createdAt: 'desc' },\r\n        take: 10\r\n      });\r\n\r\n      return {\r\n        ...incompleteData,\r\n        auditHistory\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при получении деталей незаполненной записи:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Обновление статуса незаполненной записи\r\n   */\r\n  async updateIncompleteDataStatus(id, status, userId) {\r\n    try {\r\n      const updatedRecord = await prisma.incompleteDataLog.update({\r\n        where: { id },\r\n        data: {\r\n          status,\r\n          completedAt: status === 'COMPLETED' ? new Date() : null,\r\n          updatedAt: new Date()\r\n        }\r\n      });\r\n\r\n      // Логируем изменение статуса\r\n      const auditService = require('./auditService');\r\n      await auditService.logSystemAction({\r\n        userId,\r\n        action: 'UPDATE',\r\n        entity: 'INCOMPLETE_DATA_LOG',\r\n        entityId: id,\r\n        description: `Изменен статус незаполненных данных на ${status}`,\r\n        newValues: { status }\r\n      });\r\n\r\n      return updatedRecord;\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при обновлении статуса незаполненной записи:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение рекомендаций по заполнению данных\r\n   */\r\n  async getCompletionRecommendations(entity, entityId) {\r\n    try {\r\n      const incompleteData = await prisma.incompleteDataLog.findUnique({\r\n        where: {\r\n          entity_entityId: {\r\n            entity,\r\n            entityId\r\n          }\r\n        }\r\n      });\r\n\r\n      if (!incompleteData) {\r\n        return { recommendations: [] };\r\n      }\r\n\r\n      const recommendations = [];\r\n\r\n      // Генерируем рекомендации на основе недостающих полей\r\n      for (const field of incompleteData.missingFields) {\r\n        const recommendation = this.getFieldRecommendation(entity, field);\r\n        if (recommendation) {\r\n          recommendations.push(recommendation);\r\n        }\r\n      }\r\n\r\n      // Сортируем по приоритету\r\n      recommendations.sort((a, b) => b.priority - a.priority);\r\n\r\n      return {\r\n        entity,\r\n        entityId,\r\n        completionRate: incompleteData.completionRate,\r\n        missingFields: incompleteData.missingFields,\r\n        recommendations\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Ошибка при получении рекомендаций:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение рекомендации для конкретного поля\r\n   */\r\n  getFieldRecommendation(entity, field) {\r\n    const recommendations = {\r\n      'User': {\r\n        'phoneNumber': {\r\n          title: 'Добавьте номер телефона',\r\n          description: 'Номер телефона необходим для связи и уведомлений',\r\n          priority: 8,\r\n          example: '+998901234567'\r\n        },\r\n        'email': {\r\n          title: 'Укажите email адрес',\r\n          description: 'Email используется для входа в систему и уведомлений',\r\n          priority: 10,\r\n          example: 'user@example.com'\r\n        }\r\n      },\r\n      'Machine': {\r\n        'locationId': {\r\n          title: 'Укажите местоположение автомата',\r\n          description: 'Местоположение необходимо для планирования маршрутов',\r\n          priority: 9,\r\n          example: 'Выберите из списка доступных локаций'\r\n        },\r\n        'serialNumber': {\r\n          title: 'Добавьте серийный номер',\r\n          description: 'Серийный номер нужен для идентификации и обслуживания',\r\n          priority: 8,\r\n          example: 'SN123456789'\r\n        }\r\n      },\r\n      'Task': {\r\n        'dueDate': {\r\n          title: 'Установите срок выполнения',\r\n          description: 'Срок выполнения помогает планировать работу',\r\n          priority: 7,\r\n          example: 'Выберите дату и время'\r\n        },\r\n        'assignedToId': {\r\n          title: 'Назначьте исполнителя',\r\n          description: 'Задача должна быть назначена конкретному сотруднику',\r\n          priority: 9,\r\n          example: 'Выберите из списка сотрудников'\r\n        }\r\n      }\r\n    };\r\n\r\n    return recommendations[entity]?.[field] || {\r\n      title: `Заполните поле ${field}`,\r\n      description: 'Это поле обязательно для заполнения',\r\n      priority: 5,\r\n      example: 'Введите корректное значение'\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = new IncompleteDataService();\r\n",
  "services/machines/src/index.js": "/**\r\n * VHM24 - VendHub Manager 24/7\r\n * Machines Service - PRODUCTION READY\r\n * Secure machine management with telemetry\r\n */\r\n\r\nrequire('dotenv').config({ path: require('path').join(__dirname, '../../../.env') });\r\n\r\n// Устанавливаем SERVICE_NAME для конфигурации\r\nprocess.env.SERVICE_NAME = 'machines';\r\n\r\nconst Fastify = require('fastify');\r\nconst { getMachinesClient } = require('@vhm24/database');\r\nconst { sanitizeInput } = require('@vhm24/shared-types/src/security');\r\nconst { cacheManagers, cacheMiddleware } = require('@vhm24/shared-types/src/redis');\r\n\r\n// Импортируем наш новый shared пакет\r\nconst {\r\n  // Middleware\r\n  setupCORS,\r\n  setupHelmet,\r\n  setupRateLimit,\r\n  setupJWT,\r\n  authenticate,\r\n  authorize,\r\n  sanitizeInputs,\r\n  securityLogger,\r\n  healthCheck,\r\n  \r\n  // Validation\r\n  validateBody,\r\n  validateQuery,\r\n  validateId,\r\n  \r\n  // Error handling\r\n  registerErrorHandlers,\r\n  setupGlobalErrorHandlers,\r\n  createError,\r\n  asyncHandler,\r\n  \r\n  // Utils\r\n  logger,\r\n  config: sharedConfig,\r\n  createFastifyConfig,\r\n  paginate\r\n} = require('@vhm24/shared');\r\n\r\n// Настройка глобальных обработчиков ошибок\r\nsetupGlobalErrorHandlers();\r\n\r\n// Создаем Fastify с безопасной конфигурацией\r\nconst fastify = Fastify(createFastifyConfig());\r\n\r\nconst prisma = getMachinesClient();\r\nconst cache = cacheManagers.machines;\r\n\r\n// Регистрируем обработчики ошибок\r\nregisterErrorHandlers(fastify);\r\n\r\n// Настройка безопасности\r\nsetupHelmet(fastify);\r\nsetupCORS(fastify);\r\nsetupRateLimit(fastify, {\r\n  max: 150, // Средний лимит для machines сервиса\r\n  timeWindow: '1 minute'\r\n});\r\nsetupJWT(fastify, {\r\n  verify: {\r\n    issuer: ['vhm24-gateway', 'vhm24-auth']\r\n  }\r\n});\r\n\r\n// Middleware для логирования и санитизации\r\nfastify.addHook('preHandler', securityLogger);\r\nfastify.addHook('preHandler', sanitizeInputs);\r\n\r\n// Декоратор для проверки авторизации (переопределяем для совместимости)\r\nfastify.decorate('authenticate', authenticate);\r\n\r\n// Декоратор для проверки ролей (переопределяем для совместимости)\r\nfastify.decorate('requireRole', (roles) => {\r\n  return authorize(roles);\r\n});\r\n\r\n// Health check\r\nfastify.get('/health', async (request, reply) => {\r\n  return { status: 'ok', service: 'machines' };\r\n});\r\n\r\n// Получить все машины с фильтрами\r\nfastify.get('/api/v1/machines', {\r\n  preValidation: [fastify.authenticate],\r\n  preHandler: cacheMiddleware({\r\n    keyGenerator: (req) => `machines:list:${JSON.stringify(req.query)}`,\r\n    ttl: 300, // 5 минут\r\n    serviceName: 'machines',\r\n    condition: (req) => !req.query.search // Кешируем только если нет поиска\r\n  }),\r\n  schema: {\r\n    querystring: {\r\n      type: 'object',\r\n      properties: {\r\n        status: { type: 'string', enum: ['ONLINE', 'OFFLINE', 'MAINTENANCE', 'ERROR'] },\r\n        type: { type: 'string' },\r\n        locationId: { type: 'string' },\r\n        search: { type: 'string' },\r\n        skip: { type: 'integer', minimum: 0, default: 0 },\r\n        take: { type: 'integer', minimum: 1, maximum: 100, default: 20 },\r\n        orderBy: { type: 'string', enum: ['code', 'name', 'status', 'updatedAt'], default: 'code' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { status, type, locationId, search, skip, take, orderBy } = request.query;\r\n  \r\n  try {\r\n    const where = {};\r\n    \r\n    if (status) where.status = status;\r\n    if (type) where.type = type;\r\n    if (locationId) where.locationId = locationId;\r\n    if (search) {\r\n      where.OR = [\r\n        { code: { contains: search, mode: 'insensitive' } },\r\n        { name: { contains: search, mode: 'insensitive' } },\r\n        { serialNumber: { contains: search, mode: 'insensitive' } }\r\n      ];\r\n    }\r\n\r\n    const [machines, total] = await Promise.all([\r\n      prisma.machine.findMany({\r\n        where,\r\n        skip,\r\n        take,\r\n        orderBy: { [orderBy]: 'asc' },\r\n        include: {\r\n          location: true,\r\n          _count: {\r\n            select: {\r\n              tasks: true,\r\n              telemetry: true\r\n            }\r\n          }\r\n        }\r\n      }),\r\n      prisma.machine.count({ where })\r\n    ]);\r\n\r\n    // Добавляем последнюю телеметрию\r\n    const machinesWithTelemetry = await Promise.all(\r\n      machines.map(async (machine) => {\r\n        const lastTelemetry = await prisma.machineTelemetry.findFirst({\r\n          where: { machineId: machine.id },\r\n          orderBy: { createdAt: 'desc' }\r\n        });\r\n        return {\r\n          ...machine,\r\n          lastTelemetry\r\n        };\r\n      })\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        items: machinesWithTelemetry,\r\n        total,\r\n        skip,\r\n        take\r\n      }\r\n    };\r\n  } catch (error) {\r\n    throw createError.database('Failed to fetch machines');\r\n  }\r\n});\r\n\r\n// Получить машину по ID\r\nfastify.get('/api/v1/machines/:id', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  const { id } = request.params;\r\n  \r\n  try {\r\n    // Пробуем получить из кеша\r\n    const cacheKey = `machine:${id}`;\r\n    const cached = await cache.get(cacheKey);\r\n    if (cached) {\r\n      reply.header('X-Cache', 'HIT');\r\n      return {\r\n        success: true,\r\n        data: cached\r\n      };\r\n    }\r\n    \r\n    const machine = await prisma.machine.findUnique({\r\n      where: { id },\r\n      include: {\r\n        location: true,\r\n        tasks: {\r\n          take: 10,\r\n          orderBy: { createdAt: 'desc' },\r\n          include: {\r\n            assignedTo: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                email: true\r\n              }\r\n            }\r\n          }\r\n        },\r\n        telemetry: {\r\n          take: 50,\r\n          orderBy: { createdAt: 'desc' }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (!machine) {\r\n      return reply.code(404).send({\r\n        success: false,\r\n        error: 'Machine not found'\r\n      });\r\n    }\r\n\r\n    // Вычисляем статистику\r\n    const stats = {\r\n      totalTasks: await prisma.task.count({ where: { machineId: id } }),\r\n      activeTasks: await prisma.task.count({ \r\n        where: { \r\n          machineId: id,\r\n          status: { in: ['CREATED', 'ASSIGNED', 'IN_PROGRESS'] }\r\n        }\r\n      }),\r\n      completedToday: await prisma.task.count({\r\n        where: {\r\n          machineId: id,\r\n          status: 'COMPLETED',\r\n          completedAt: {\r\n            gte: new Date(new Date().setHours(0, 0, 0, 0))\r\n          }\r\n        }\r\n      })\r\n    };\r\n\r\n    const result = {\r\n      ...machine,\r\n      stats\r\n    };\r\n    \r\n    // Сохраняем в кеш\r\n    await cache.set(cacheKey, result, 600); // 10 минут\r\n    \r\n    return {\r\n      success: true,\r\n      data: result\r\n    };\r\n  } catch (error) {\r\n    throw createError.database('Failed to fetch machine');\r\n  }\r\n});\r\n\r\n// Создать новую машину (только для ADMIN и MANAGER)\r\nfastify.post('/api/v1/machines', {\r\n  preValidation: [fastify.authenticate, fastify.requireRole(['ADMIN', 'MANAGER'])],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['code', 'serialNumber', 'type', 'name'],\r\n      properties: {\r\n        code: { type: 'string', pattern: '^CVM-\\\\d{5}$' },\r\n        serialNumber: { type: 'string', minLength: 5 },\r\n        type: { type: 'string', enum: ['COFFEE', 'SNACK', 'COMBO', 'OTHER'] },\r\n        name: { type: 'string', minLength: 3 },\r\n        locationId: { type: 'string' },\r\n        metadata: { type: 'object' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const data = request.body;\r\n  \r\n  try {\r\n    // Проверяем уникальность кода и серийного номера\r\n    const existing = await prisma.machine.findFirst({\r\n      where: {\r\n        OR: [\r\n          { code: data.code },\r\n          { serialNumber: data.serialNumber }\r\n        ]\r\n      }\r\n    });\r\n\r\n    if (existing) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'Machine with this code or serial number already exists'\r\n      });\r\n    }\r\n\r\n    // Проверяем локацию, если указана\r\n    if (data.locationId) {\r\n      const location = await prisma.location.findUnique({\r\n        where: { id: data.locationId }\r\n      });\r\n      \r\n      if (!location) {\r\n        return reply.code(400).send({\r\n          success: false,\r\n          error: 'Location not found'\r\n        });\r\n      }\r\n    }\r\n\r\n    // Создаем машину\r\n    const machine = await prisma.machine.create({\r\n      data: {\r\n        ...data,\r\n        status: 'OFFLINE'\r\n      },\r\n      include: {\r\n        location: true\r\n      }\r\n    });\r\n\r\n    // Логируем действие\r\n    await prisma.auditLog.create({\r\n      data: {\r\n        userId: request.user.id,\r\n        action: 'MACHINE_CREATED',\r\n        entity: 'Machine',\r\n        entityId: machine.id,\r\n        changes: data\r\n      }\r\n    });\r\n\r\n    // Инвалидируем кеш списка машин\r\n    await cache.deletePattern('machines:list:*');\r\n    await cache.deletePattern('machines:stats');\r\n\r\n    return {\r\n      success: true,\r\n      data: machine\r\n    };\r\n  } catch (error) {\r\n    throw createError.database('Failed to create machine');\r\n  }\r\n});\r\n\r\n// Обновить машину\r\nfastify.patch('/api/v1/machines/:id', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    params: {\r\n      type: 'object',\r\n      properties: {\r\n        id: { type: 'string' }\r\n      }\r\n    },\r\n    body: {\r\n      type: 'object',\r\n      properties: {\r\n        name: { type: 'string', minLength: 3 },\r\n        status: { type: 'string', enum: ['ONLINE', 'OFFLINE', 'MAINTENANCE', 'ERROR'] },\r\n        locationId: { type: 'string' },\r\n        metadata: { type: 'object' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { id } = request.params;\r\n  const updates = request.body;\r\n  \r\n  try {\r\n    // Проверяем существование машины\r\n    const existingMachine = await prisma.machine.findUnique({\r\n      where: { id }\r\n    });\r\n\r\n    if (!existingMachine) {\r\n      return reply.code(404).send({\r\n        success: false,\r\n        error: 'Machine not found'\r\n      });\r\n    }\r\n\r\n    // Проверяем локацию, если обновляется\r\n    if (updates.locationId) {\r\n      const location = await prisma.location.findUnique({\r\n        where: { id: updates.locationId }\r\n      });\r\n      \r\n      if (!location) {\r\n        return reply.code(400).send({\r\n          success: false,\r\n          error: 'Location not found'\r\n        });\r\n      }\r\n    }\r\n\r\n    // Обновляем машину\r\n    const machine = await prisma.machine.update({\r\n      where: { id },\r\n      data: {\r\n        ...updates,\r\n        updatedAt: new Date()\r\n      },\r\n      include: {\r\n        location: true\r\n      }\r\n    });\r\n\r\n    // Логируем изменения\r\n    const changes = {};\r\n    for (const [key, value] of Object.entries(updates)) {\r\n      if (existingMachine[key] !== value) {\r\n        changes[key] = {\r\n          from: existingMachine[key],\r\n          to: value\r\n        };\r\n      }\r\n    }\r\n\r\n    if (Object.keys(changes).length > 0) {\r\n      await prisma.auditLog.create({\r\n        data: {\r\n          userId: request.user.id,\r\n          action: 'MACHINE_UPDATED',\r\n          entity: 'Machine',\r\n          entityId: machine.id,\r\n          changes\r\n        }\r\n      });\r\n    }\r\n\r\n    // Инвалидируем кеш\r\n    await cache.delete(`machine:${id}`);\r\n    await cache.deletePattern('machines:list:*');\r\n    await cache.deletePattern('machines:stats');\r\n\r\n    return {\r\n      success: true,\r\n      data: machine\r\n    };\r\n  } catch (error) {\r\n    throw createError.database('Failed to update machine');\r\n  }\r\n});\r\n\r\n// Удалить машину (soft delete) - только для ADMIN\r\nfastify.delete('/api/v1/machines/:id', {\r\n  preValidation: [fastify.authenticate, fastify.requireRole(['ADMIN'])]\r\n}, async (request, reply) => {\r\n  const { id } = request.params;\r\n  \r\n  try {\r\n    // Проверяем, есть ли активные задачи\r\n    const activeTasks = await prisma.task.count({\r\n      where: {\r\n        machineId: id,\r\n        status: { in: ['CREATED', 'ASSIGNED', 'IN_PROGRESS'] }\r\n      }\r\n    });\r\n\r\n    if (activeTasks > 0) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: `Cannot delete machine with ${activeTasks} active tasks`\r\n      });\r\n    }\r\n\r\n    // Помечаем как удаленную (soft delete)\r\n    const machine = await prisma.machine.update({\r\n      where: { id },\r\n      data: {\r\n        status: 'OFFLINE',\r\n        metadata: {\r\n          ...(await prisma.machine.findUnique({ where: { id } })).metadata,\r\n          deletedAt: new Date().toISOString(),\r\n          deletedBy: request.user.id\r\n        }\r\n      }\r\n    });\r\n\r\n    // Логируем действие\r\n    await prisma.auditLog.create({\r\n      data: {\r\n        userId: request.user.id,\r\n        action: 'MACHINE_DELETED',\r\n        entity: 'Machine',\r\n        entityId: id\r\n      }\r\n    });\r\n\r\n    // Инвалидируем кеш\r\n    await cache.delete(`machine:${id}`);\r\n    await cache.deletePattern('machines:list:*');\r\n    await cache.deletePattern('machines:stats');\r\n\r\n    return {\r\n      success: true,\r\n      message: 'Machine deleted successfully'\r\n    };\r\n  } catch (error) {\r\n    if (error.code === 'P2025') {\r\n      return reply.code(404).send({\r\n        success: false,\r\n        error: 'Machine not found'\r\n      });\r\n    }\r\n    \r\n    throw createError.database('Failed to delete machine');\r\n  }\r\n});\r\n\r\n// Записать телеметрию\r\nfastify.post('/api/v1/machines/:id/telemetry', {\r\n  schema: {\r\n    params: {\r\n      type: 'object',\r\n      properties: {\r\n        id: { type: 'string' }\r\n      }\r\n    },\r\n    body: {\r\n      type: 'object',\r\n      required: ['rawData'],\r\n      properties: {\r\n        temperature: { type: 'number' },\r\n        humidity: { type: 'number' },\r\n        sales: { type: 'integer' },\r\n        errors: { type: 'array', items: { type: 'string' } },\r\n        rawData: { type: 'object' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { id } = request.params;\r\n  const telemetryData = request.body;\r\n  \r\n  try {\r\n    // Проверяем существование машины\r\n    const machine = await prisma.machine.findUnique({\r\n      where: { id }\r\n    });\r\n\r\n    if (!machine) {\r\n      return reply.code(404).send({\r\n        success: false,\r\n        error: 'Machine not found'\r\n      });\r\n    }\r\n\r\n    // Создаем запись телеметрии\r\n    const telemetry = await prisma.machineTelemetry.create({\r\n      data: {\r\n        machineId: id,\r\n        ...telemetryData\r\n      }\r\n    });\r\n\r\n    // Обновляем статус машины и время последнего пинга\r\n    const newStatus = telemetryData.errors && telemetryData.errors.length > 0 \r\n      ? 'ERROR' \r\n      : 'ONLINE';\r\n\r\n    await prisma.machine.update({\r\n      where: { id },\r\n      data: {\r\n        status: newStatus,\r\n        lastPing: new Date()\r\n      }\r\n    });\r\n\r\n    // Инвалидируем кеш машины\r\n    await cache.delete(`machine:${id}`);\r\n    await cache.deletePattern('machines:stats');\r\n\r\n    return {\r\n      success: true,\r\n      data: telemetry\r\n    };\r\n  } catch (error) {\r\n    throw createError.database('Failed to save telemetry');\r\n  }\r\n});\r\n\r\n// Получить телеметрию машины\r\nfastify.get('/api/v1/machines/:id/telemetry', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    params: {\r\n      type: 'object',\r\n      properties: {\r\n        id: { type: 'string' }\r\n      }\r\n    },\r\n    querystring: {\r\n      type: 'object',\r\n      properties: {\r\n        from: { type: 'string', format: 'date-time' },\r\n        to: { type: 'string', format: 'date-time' },\r\n        limit: { type: 'integer', minimum: 1, maximum: 1000, default: 100 }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { id } = request.params;\r\n  const { from, to, limit } = request.query;\r\n  \r\n  try {\r\n    const where = { machineId: id };\r\n    \r\n    if (from || to) {\r\n      where.createdAt = {};\r\n      if (from) where.createdAt.gte = new Date(from);\r\n      if (to) where.createdAt.lte = new Date(to);\r\n    }\r\n\r\n    const telemetry = await prisma.machineTelemetry.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n      take: limit\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: telemetry\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch telemetry'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить статистику машин\r\nfastify.get('/api/v1/machines/stats', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    // Пробуем получить из кеша\r\n    const cacheKey = 'machines:stats';\r\n    const cached = await cache.get(cacheKey);\r\n    if (cached) {\r\n      reply.header('X-Cache', 'HIT');\r\n      return {\r\n        success: true,\r\n        data: cached\r\n      };\r\n    }\r\n    \r\n    const [\r\n      totalMachines,\r\n      machinesByStatus,\r\n      machinesByType,\r\n      machinesWithErrors,\r\n      recentTelemetry\r\n    ] = await Promise.all([\r\n      prisma.machine.count(),\r\n      prisma.machine.groupBy({\r\n        by: ['status'],\r\n        _count: true\r\n      }),\r\n      prisma.machine.groupBy({\r\n        by: ['type'],\r\n        _count: true\r\n      }),\r\n      prisma.machine.count({\r\n        where: { status: 'ERROR' }\r\n      }),\r\n      prisma.machineTelemetry.count({\r\n        where: {\r\n          createdAt: {\r\n            gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // За последние 24 часа\r\n          }\r\n        }\r\n      })\r\n    ]);\r\n\r\n    const stats = {\r\n      total: totalMachines,\r\n      byStatus: machinesByStatus.reduce((acc, item) => {\r\n        acc[item.status] = item._count;\r\n        return acc;\r\n      }, {}),\r\n      byType: machinesByType.reduce((acc, item) => {\r\n        acc[item.type] = item._count;\r\n        return acc;\r\n      }, {}),\r\n      withErrors: machinesWithErrors,\r\n      telemetryLast24h: recentTelemetry\r\n    };\r\n    \r\n    // Сохраняем в кеш на 5 минут\r\n    await cache.set(cacheKey, stats, 300);\r\n    \r\n    return {\r\n      success: true,\r\n      data: stats\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch statistics'\r\n    });\r\n  }\r\n});\r\n\r\n// Start server\r\nconst start = async () => {\r\n  try {\r\n    const port = process.env.MACHINES_PORT || process.env.PORT || 3002;\r\n    await fastify.listen({ \r\n      port: port,\r\n      host: '0.0.0.0'\r\n    });\r\n    console.log('Machines service is running on port', port);\r\n  } catch (err) {\r\n    fastify.log.error(err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\nstart();\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGTERM', async () => {\r\n  await fastify.close();\r\n  await prisma.$disconnect();\r\n  process.exit(0);\r\n});\r\n",
  "services/recipes/src/index.js": "const fastify = require('fastify')({ logger: true });\r\nconst path = require('path');\r\n\r\n// Load environment variables\r\nrequire('dotenv').config({ path: path.join(__dirname, '../../../.env') });\r\n\r\n// Import shared middleware and utilities\r\nconst { errorHandler } = require('@vhm24/shared/middleware/errorHandler');\r\nconst { authMiddleware } = require('@vhm24/shared/middleware/security');\r\nconst logger = require('@vhm24/shared/utils/logger');\r\nconst { PrismaClient } = require('@prisma/client');\r\n\r\n// Initialize Prisma\r\nconst prisma = new PrismaClient();\r\n\r\n// Configuration\r\nconst config = {\r\n  port: process.env.RECIPES_SERVICE_PORT || 3007,\r\n  host: process.env.HOST || '0.0.0.0',\r\n  jwtSecret: process.env.JWT_SECRET || 'your-secret-key'\r\n};\r\n\r\n// Register plugins\r\nasync function registerPlugins() {\r\n  // CORS\r\n  await fastify.register(require('@fastify/cors'), {\r\n    origin: true,\r\n    credentials: true\r\n  });\r\n\r\n  // Security headers\r\n  await fastify.register(require('@fastify/helmet'));\r\n\r\n  // Rate limiting\r\n  await fastify.register(require('@fastify/rate-limit'), {\r\n    max: 100,\r\n    timeWindow: '1 minute'\r\n  });\r\n\r\n  // Swagger documentation\r\n  await fastify.register(require('@fastify/swagger'), {\r\n    swagger: {\r\n      info: {\r\n        title: 'VHM24 Recipes API',\r\n        description: 'API for managing recipes, ingredients and cost calculations',\r\n        version: '1.0.0'\r\n      },\r\n      host: 'localhost:3007',\r\n      schemes: ['http', 'https'],\r\n      consumes: ['application/json'],\r\n      produces: ['application/json'],\r\n      securityDefinitions: {\r\n        Bearer: {\r\n          type: 'apiKey',\r\n          name: 'Authorization',\r\n          in: 'header'\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  await fastify.register(require('@fastify/swagger-ui'), {\r\n    routePrefix: '/docs',\r\n    uiConfig: {\r\n      docExpansion: 'full',\r\n      deepLinking: false\r\n    }\r\n  });\r\n}\r\n\r\n// Authentication hook\r\nfastify.addHook('preHandler', async (request, reply) => {\r\n  // Skip auth for health check and docs\r\n  if (request.url === '/health' || request.url.startsWith('/docs')) {\r\n    return;\r\n  }\r\n\r\n  try {\r\n    await authMiddleware(request, reply, config.jwtSecret);\r\n  } catch (error) {\r\n    reply.code(401).send({ success: false, message: 'Unauthorized' });\r\n  }\r\n});\r\n\r\n// Health check\r\nfastify.get('/health', async (request, reply) => {\r\n  return { status: 'ok', service: 'recipes', timestamp: new Date().toISOString() };\r\n});\r\n\r\n// Recipes endpoints\r\nfastify.get('/api/v1/recipes', {\r\n  schema: {\r\n    description: 'Get all recipes',\r\n    tags: ['Recipes'],\r\n    security: [{ Bearer: [] }],\r\n    querystring: {\r\n      type: 'object',\r\n      properties: {\r\n        page: { type: 'integer', minimum: 1, default: 1 },\r\n        limit: { type: 'integer', minimum: 1, maximum: 100, default: 20 },\r\n        search: { type: 'string' },\r\n        category: { type: 'string' }\r\n      }\r\n    },\r\n    response: {\r\n      200: {\r\n        type: 'object',\r\n        properties: {\r\n          success: { type: 'boolean' },\r\n          data: {\r\n            type: 'array',\r\n            items: {\r\n              type: 'object',\r\n              properties: {\r\n                id: { type: 'integer' },\r\n                name: { type: 'string' },\r\n                description: { type: 'string' },\r\n                category: { type: 'string' },\r\n                preparationTime: { type: 'integer' },\r\n                servings: { type: 'integer' },\r\n                cost: { type: 'number' },\r\n                createdAt: { type: 'string' },\r\n                updatedAt: { type: 'string' }\r\n              }\r\n            }\r\n          },\r\n          pagination: {\r\n            type: 'object',\r\n            properties: {\r\n              page: { type: 'integer' },\r\n              limit: { type: 'integer' },\r\n              total: { type: 'integer' },\r\n              pages: { type: 'integer' }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  try {\r\n    const { page = 1, limit = 20, search, category } = request.query;\r\n    const skip = (page - 1) * limit;\r\n\r\n    const where = {};\r\n    if (search) {\r\n      where.OR = [\r\n        { name: { contains: search, mode: 'insensitive' } },\r\n        { description: { contains: search, mode: 'insensitive' } }\r\n      ];\r\n    }\r\n    if (category) {\r\n      where.category = category;\r\n    }\r\n\r\n    const [recipes, total] = await Promise.all([\r\n      prisma.recipe.findMany({\r\n        where,\r\n        skip,\r\n        take: limit,\r\n        include: {\r\n          ingredients: {\r\n            include: {\r\n              ingredient: true\r\n            }\r\n          }\r\n        },\r\n        orderBy: { createdAt: 'desc' }\r\n      }),\r\n      prisma.recipe.count({ where })\r\n    ]);\r\n\r\n    return {\r\n      success: true,\r\n      data: recipes,\r\n      pagination: {\r\n        page,\r\n        limit,\r\n        total,\r\n        pages: Math.ceil(total / limit)\r\n      }\r\n    };\r\n  } catch (error) {\r\n    logger.error('Get recipes error:', error);\r\n    reply.code(500).send({ success: false, message: 'Internal server error' });\r\n  }\r\n});\r\n\r\nfastify.get('/api/v1/recipes/:id', {\r\n  schema: {\r\n    description: 'Get recipe by ID',\r\n    tags: ['Recipes'],\r\n    security: [{ Bearer: [] }],\r\n    params: {\r\n      type: 'object',\r\n      properties: {\r\n        id: { type: 'integer' }\r\n      },\r\n      required: ['id']\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  try {\r\n    const { id } = request.params;\r\n\r\n    const recipe = await prisma.recipe.findUnique({\r\n      where: { id: parseInt(id) },\r\n      include: {\r\n        ingredients: {\r\n          include: {\r\n            ingredient: true\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (!recipe) {\r\n      return reply.code(404).send({ success: false, message: 'Recipe not found' });\r\n    }\r\n\r\n    return { success: true, data: recipe };\r\n  } catch (error) {\r\n    logger.error('Get recipe error:', error);\r\n    reply.code(500).send({ success: false, message: 'Internal server error' });\r\n  }\r\n});\r\n\r\nfastify.post('/api/v1/recipes', {\r\n  schema: {\r\n    description: 'Create new recipe',\r\n    tags: ['Recipes'],\r\n    security: [{ Bearer: [] }],\r\n    body: {\r\n      type: 'object',\r\n      properties: {\r\n        name: { type: 'string', minLength: 1, maxLength: 255 },\r\n        description: { type: 'string' },\r\n        category: { type: 'string' },\r\n        preparationTime: { type: 'integer', minimum: 1 },\r\n        servings: { type: 'integer', minimum: 1 },\r\n        instructions: { type: 'string' },\r\n        ingredients: {\r\n          type: 'array',\r\n          items: {\r\n            type: 'object',\r\n            properties: {\r\n              ingredientId: { type: 'integer' },\r\n              quantity: { type: 'number', minimum: 0 },\r\n              unit: { type: 'string' }\r\n            },\r\n            required: ['ingredientId', 'quantity', 'unit']\r\n          }\r\n        }\r\n      },\r\n      required: ['name', 'category', 'preparationTime', 'servings', 'ingredients']\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  try {\r\n    const { name, description, category, preparationTime, servings, instructions, ingredients } = request.body;\r\n\r\n    // Calculate total cost\r\n    let totalCost = 0;\r\n    for (const ing of ingredients) {\r\n      const ingredient = await prisma.ingredient.findUnique({\r\n        where: { id: ing.ingredientId }\r\n      });\r\n      if (ingredient) {\r\n        totalCost += (ingredient.costPerUnit * ing.quantity);\r\n      }\r\n    }\r\n\r\n    const recipe = await prisma.recipe.create({\r\n      data: {\r\n        name,\r\n        description,\r\n        category,\r\n        preparationTime,\r\n        servings,\r\n        instructions,\r\n        cost: totalCost,\r\n        ingredients: {\r\n          create: ingredients.map(ing => ({\r\n            ingredientId: ing.ingredientId,\r\n            quantity: ing.quantity,\r\n            unit: ing.unit\r\n          }))\r\n        }\r\n      },\r\n      include: {\r\n        ingredients: {\r\n          include: {\r\n            ingredient: true\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return { success: true, data: recipe };\r\n  } catch (error) {\r\n    logger.error('Create recipe error:', error);\r\n    reply.code(500).send({ success: false, message: 'Internal server error' });\r\n  }\r\n});\r\n\r\nfastify.put('/api/v1/recipes/:id', {\r\n  schema: {\r\n    description: 'Update recipe',\r\n    tags: ['Recipes'],\r\n    security: [{ Bearer: [] }],\r\n    params: {\r\n      type: 'object',\r\n      properties: {\r\n        id: { type: 'integer' }\r\n      },\r\n      required: ['id']\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  try {\r\n    const { id } = request.params;\r\n    const { name, description, category, preparationTime, servings, instructions, ingredients } = request.body;\r\n\r\n    // Check if recipe exists\r\n    const existingRecipe = await prisma.recipe.findUnique({\r\n      where: { id: parseInt(id) }\r\n    });\r\n\r\n    if (!existingRecipe) {\r\n      return reply.code(404).send({ success: false, message: 'Recipe not found' });\r\n    }\r\n\r\n    // Calculate new cost if ingredients provided\r\n    let totalCost = existingRecipe.cost;\r\n    if (ingredients) {\r\n      totalCost = 0;\r\n      for (const ing of ingredients) {\r\n        const ingredient = await prisma.ingredient.findUnique({\r\n          where: { id: ing.ingredientId }\r\n        });\r\n        if (ingredient) {\r\n          totalCost += (ingredient.costPerUnit * ing.quantity);\r\n        }\r\n      }\r\n    }\r\n\r\n    const updateData = {\r\n      name,\r\n      description,\r\n      category,\r\n      preparationTime,\r\n      servings,\r\n      instructions,\r\n      cost: totalCost\r\n    };\r\n\r\n    // Remove undefined values\r\n    Object.keys(updateData).forEach(key => {\r\n      if (updateData[key] === undefined) {\r\n        delete updateData[key];\r\n      }\r\n    });\r\n\r\n    const recipe = await prisma.recipe.update({\r\n      where: { id: parseInt(id) },\r\n      data: updateData,\r\n      include: {\r\n        ingredients: {\r\n          include: {\r\n            ingredient: true\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return { success: true, data: recipe };\r\n  } catch (error) {\r\n    logger.error('Update recipe error:', error);\r\n    reply.code(500).send({ success: false, message: 'Internal server error' });\r\n  }\r\n});\r\n\r\nfastify.delete('/api/v1/recipes/:id', {\r\n  schema: {\r\n    description: 'Delete recipe',\r\n    tags: ['Recipes'],\r\n    security: [{ Bearer: [] }],\r\n    params: {\r\n      type: 'object',\r\n      properties: {\r\n        id: { type: 'integer' }\r\n      },\r\n      required: ['id']\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  try {\r\n    const { id } = request.params;\r\n\r\n    const recipe = await prisma.recipe.findUnique({\r\n      where: { id: parseInt(id) }\r\n    });\r\n\r\n    if (!recipe) {\r\n      return reply.code(404).send({ success: false, message: 'Recipe not found' });\r\n    }\r\n\r\n    await prisma.recipe.delete({\r\n      where: { id: parseInt(id) }\r\n    });\r\n\r\n    return { success: true, message: 'Recipe deleted successfully' };\r\n  } catch (error) {\r\n    logger.error('Delete recipe error:', error);\r\n    reply.code(500).send({ success: false, message: 'Internal server error' });\r\n  }\r\n});\r\n\r\n// Ingredients endpoints\r\nfastify.get('/api/v1/ingredients', {\r\n  schema: {\r\n    description: 'Get all ingredients',\r\n    tags: ['Ingredients'],\r\n    security: [{ Bearer: [] }]\r\n  }\r\n}, async (request, reply) => {\r\n  try {\r\n    const { page = 1, limit = 50, search } = request.query;\r\n    const skip = (page - 1) * limit;\r\n\r\n    const where = {};\r\n    if (search) {\r\n      where.OR = [\r\n        { name: { contains: search, mode: 'insensitive' } },\r\n        { category: { contains: search, mode: 'insensitive' } }\r\n      ];\r\n    }\r\n\r\n    const [ingredients, total] = await Promise.all([\r\n      prisma.ingredient.findMany({\r\n        where,\r\n        skip,\r\n        take: limit,\r\n        orderBy: { name: 'asc' }\r\n      }),\r\n      prisma.ingredient.count({ where })\r\n    ]);\r\n\r\n    return {\r\n      success: true,\r\n      data: ingredients,\r\n      pagination: {\r\n        page,\r\n        limit,\r\n        total,\r\n        pages: Math.ceil(total / limit)\r\n      }\r\n    };\r\n  } catch (error) {\r\n    logger.error('Get ingredients error:', error);\r\n    reply.code(500).send({ success: false, message: 'Internal server error' });\r\n  }\r\n});\r\n\r\nfastify.post('/api/v1/ingredients', {\r\n  schema: {\r\n    description: 'Create new ingredient',\r\n    tags: ['Ingredients'],\r\n    security: [{ Bearer: [] }],\r\n    body: {\r\n      type: 'object',\r\n      properties: {\r\n        name: { type: 'string', minLength: 1, maxLength: 255 },\r\n        category: { type: 'string' },\r\n        unit: { type: 'string' },\r\n        costPerUnit: { type: 'number', minimum: 0 },\r\n        supplier: { type: 'string' },\r\n        description: { type: 'string' }\r\n      },\r\n      required: ['name', 'category', 'unit', 'costPerUnit']\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  try {\r\n    const ingredient = await prisma.ingredient.create({\r\n      data: request.body\r\n    });\r\n\r\n    return { success: true, data: ingredient };\r\n  } catch (error) {\r\n    logger.error('Create ingredient error:', error);\r\n    reply.code(500).send({ success: false, message: 'Internal server error' });\r\n  }\r\n});\r\n\r\n// Cost calculation endpoint\r\nfastify.post('/api/v1/cost-calculation', {\r\n  schema: {\r\n    description: 'Calculate recipe cost',\r\n    tags: ['Cost Calculation'],\r\n    security: [{ Bearer: [] }],\r\n    body: {\r\n      type: 'object',\r\n      properties: {\r\n        ingredients: {\r\n          type: 'array',\r\n          items: {\r\n            type: 'object',\r\n            properties: {\r\n              ingredientId: { type: 'integer' },\r\n              quantity: { type: 'number', minimum: 0 }\r\n            },\r\n            required: ['ingredientId', 'quantity']\r\n          }\r\n        },\r\n        servings: { type: 'integer', minimum: 1 },\r\n        markup: { type: 'number', minimum: 0, default: 0 }\r\n      },\r\n      required: ['ingredients', 'servings']\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  try {\r\n    const { ingredients, servings, markup = 0 } = request.body;\r\n\r\n    let totalCost = 0;\r\n    const costBreakdown = [];\r\n\r\n    for (const ing of ingredients) {\r\n      const ingredient = await prisma.ingredient.findUnique({\r\n        where: { id: ing.ingredientId }\r\n      });\r\n\r\n      if (ingredient) {\r\n        const cost = ingredient.costPerUnit * ing.quantity;\r\n        totalCost += cost;\r\n        \r\n        costBreakdown.push({\r\n          ingredient: ingredient.name,\r\n          quantity: ing.quantity,\r\n          unit: ingredient.unit,\r\n          costPerUnit: ingredient.costPerUnit,\r\n          totalCost: cost\r\n        });\r\n      }\r\n    }\r\n\r\n    const costPerServing = totalCost / servings;\r\n    const finalCostPerServing = costPerServing * (1 + markup / 100);\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        totalCost,\r\n        costPerServing,\r\n        finalCostPerServing,\r\n        servings,\r\n        markup,\r\n        breakdown: costBreakdown\r\n      }\r\n    };\r\n  } catch (error) {\r\n    logger.error('Cost calculation error:', error);\r\n    reply.code(500).send({ success: false, message: 'Internal server error' });\r\n  }\r\n});\r\n\r\n// Recipe categories endpoint\r\nfastify.get('/api/v1/recipe-categories', {\r\n  schema: {\r\n    description: 'Get recipe categories',\r\n    tags: ['Recipes'],\r\n    security: [{ Bearer: [] }]\r\n  }\r\n}, async (request, reply) => {\r\n  try {\r\n    const categories = await prisma.recipe.findMany({\r\n      select: {\r\n        category: true\r\n      },\r\n      distinct: ['category'],\r\n      where: {\r\n        category: {\r\n          not: null\r\n        }\r\n      }\r\n    });\r\n\r\n    const categoryList = categories.map(c => c.category).filter(Boolean);\r\n\r\n    return {\r\n      success: true,\r\n      data: categoryList\r\n    };\r\n  } catch (error) {\r\n    logger.error('Get categories error:', error);\r\n    reply.code(500).send({ success: false, message: 'Internal server error' });\r\n  }\r\n});\r\n\r\n// Error handler\r\nfastify.setErrorHandler(errorHandler);\r\n\r\n// Start server\r\nasync function start() {\r\n  try {\r\n    await registerPlugins();\r\n    \r\n    await fastify.listen({\r\n      port: config.port,\r\n      host: config.host\r\n    });\r\n\r\n    logger.info(`🍳 Recipes service running on http://${config.host}:${config.port}`);\r\n    logger.info(`📚 API documentation available at http://${config.host}:${config.port}/docs`);\r\n  } catch (error) {\r\n    console.error('Failed to start recipes service:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGINT', async () => {\r\n  logger.info('Shutting down recipes service...');\r\n  await fastify.close();\r\n  await prisma.$disconnect();\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('SIGTERM', async () => {\r\n  logger.info('Shutting down recipes service...');\r\n  await fastify.close();\r\n  await prisma.$disconnect();\r\n  process.exit(0);\r\n});\r\n\r\nstart();\r\n",
  "services/tasks/src/scheduledTasks.js": "/**\r\n * VHM24 - Scheduled Tasks Module\r\n * Модуль для автоматического создания задач по расписанию и при дефиците товаров\r\n */\r\n\r\nconst cron = require('node-cron');\r\nconst { getTasksClient } = require('@vhm24/database');\r\n\r\n// Создаем простой логгер\r\nconst logger = {\r\n  info: (message, ...args) => console.log(`[INFO] ${message}`, ...args),\r\n  warn: (message, ...args) => console.warn(`[WARN] ${message}`, ...args),\r\n  error: (message, ...args) => console.error(`[ERROR] ${message}`, ...args)\r\n};\r\n\r\n// Получаем Prisma клиент\r\nconst prisma = getTasksClient();\r\n\r\n/**\r\n * Инициализация расписаний задач\r\n */\r\nfunction initScheduledTasks() {\r\n  logger.info('Initializing scheduled tasks...');\r\n\r\n  // Ежедневная проверка дефицита товаров (в 6:00 утра)\r\n  cron.schedule('0 6 * * *', async () => {\r\n    logger.info('Running scheduled inventory check...');\r\n    await createTasksForLowInventory();\r\n  });\r\n\r\n  // Еженедельное техническое обслуживание (в понедельник в 8:00 утра)\r\n  cron.schedule('0 8 * * 1', async () => {\r\n    logger.info('Running scheduled maintenance tasks...');\r\n    await createMaintenanceTasks();\r\n  });\r\n\r\n  // Ежемесячная инвентаризация (1-го числа каждого месяца в 7:00 утра)\r\n  cron.schedule('0 7 1 * *', async () => {\r\n    logger.info('Running scheduled inventory tasks...');\r\n    await createInventoryTasks();\r\n  });\r\n\r\n  logger.info('Scheduled tasks initialized successfully');\r\n}\r\n\r\n/**\r\n * Создание задач при низком уровне запасов\r\n */\r\nasync function createTasksForLowInventory() {\r\n  try {\r\n    // Получаем все товары с низким уровнем запасов\r\n    const lowInventoryItems = await prisma.inventoryItem.findMany({\r\n      where: {\r\n        quantity: {\r\n          lt: prisma.inventoryItem.minQuantity\r\n        }\r\n      },\r\n      include: {\r\n        machine: true\r\n      }\r\n    });\r\n\r\n    logger.info(`Found ${lowInventoryItems.length} items with low inventory`);\r\n\r\n    // Группируем товары по машинам\r\n    const itemsByMachine = lowInventoryItems.reduce((acc, item) => {\r\n      if (!acc[item.machineId]) {\r\n        acc[item.machineId] = [];\r\n      }\r\n      acc[item.machineId].push(item);\r\n      return acc;\r\n    }, {});\r\n\r\n    // Создаем задачи для каждой машины\r\n    for (const [machineId, items] of Object.entries(itemsByMachine)) {\r\n      const machine = items[0].machine;\r\n      \r\n      // Формируем описание задачи\r\n      const itemsList = items.map(item => \r\n        `- ${item.name}: ${item.quantity}/${item.minQuantity} ${item.unit}`\r\n      ).join('\\n');\r\n      \r\n      const description = `Необходимо пополнить запасы:\\n${itemsList}`;\r\n      \r\n      // Создаем задачу\r\n      const task = await prisma.task.create({\r\n        data: {\r\n          title: `Пополнение запасов для ${machine.name}`,\r\n          description,\r\n          machineId,\r\n          status: 'CREATED',\r\n          priority: 'HIGH',\r\n          type: 'RESUPPLY',\r\n          dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000) // Срок - 24 часа\r\n        }\r\n      });\r\n      \r\n      // Добавляем запись в историю действий\r\n      await prisma.taskAction.create({\r\n        data: {\r\n          taskId: task.id,\r\n          action: 'CREATED',\r\n          comment: 'Задача создана автоматически из-за низкого уровня запасов',\r\n          metadata: {\r\n            items: items.map(item => ({\r\n              id: item.id,\r\n              name: item.name,\r\n              quantity: item.quantity,\r\n              minQuantity: item.minQuantity\r\n            }))\r\n          }\r\n        }\r\n      });\r\n      \r\n      logger.info(`Created resupply task #${task.id} for machine ${machine.name}`);\r\n      \r\n      // Отправляем уведомление\r\n      await sendTaskNotification(task, 'LOW_INVENTORY');\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    logger.error('Error creating tasks for low inventory:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Создание задач для планового технического обслуживания\r\n */\r\nasync function createMaintenanceTasks() {\r\n  try {\r\n    // Получаем все машины, которые не проходили ТО более 30 дней\r\n    const thirtyDaysAgo = new Date();\r\n    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n    \r\n    const machines = await prisma.machine.findMany({\r\n      where: {\r\n        OR: [\r\n          { lastMaintenanceDate: { lt: thirtyDaysAgo } },\r\n          { lastMaintenanceDate: null }\r\n        ]\r\n      },\r\n      include: {\r\n        location: true\r\n      }\r\n    });\r\n    \r\n    logger.info(`Found ${machines.length} machines requiring maintenance`);\r\n    \r\n    // Создаем задачи для каждой машины\r\n    for (const machine of machines) {\r\n      const task = await prisma.task.create({\r\n        data: {\r\n          title: `Плановое ТО для ${machine.name}`,\r\n          description: `Требуется плановое техническое обслуживание.\\nПоследнее ТО: ${machine.lastMaintenanceDate ? new Date(machine.lastMaintenanceDate).toLocaleDateString('ru-RU') : 'Не проводилось'}`,\r\n          machineId: machine.id,\r\n          status: 'CREATED',\r\n          priority: 'MEDIUM',\r\n          type: 'MAINTENANCE',\r\n          dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // Срок - 7 дней\r\n        }\r\n      });\r\n      \r\n      // Добавляем запись в историю действий\r\n      await prisma.taskAction.create({\r\n        data: {\r\n          taskId: task.id,\r\n          action: 'CREATED',\r\n          comment: 'Задача создана автоматически по графику ТО',\r\n          metadata: {\r\n            lastMaintenance: machine.lastMaintenanceDate,\r\n            location: machine.location?.name || 'Неизвестно'\r\n          }\r\n        }\r\n      });\r\n      \r\n      logger.info(`Created maintenance task #${task.id} for machine ${machine.name}`);\r\n      \r\n      // Отправляем уведомление\r\n      await sendTaskNotification(task, 'MAINTENANCE_REQUIRED');\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    logger.error('Error creating maintenance tasks:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Создание задач для инвентаризации\r\n */\r\nasync function createInventoryTasks() {\r\n  try {\r\n    // Получаем все машины\r\n    const machines = await prisma.machine.findMany({\r\n      include: {\r\n        location: true\r\n      }\r\n    });\r\n    \r\n    logger.info(`Creating inventory tasks for ${machines.length} machines`);\r\n    \r\n    // Создаем задачи для каждой машины\r\n    for (const machine of machines) {\r\n      const task = await prisma.task.create({\r\n        data: {\r\n          title: `Инвентаризация для ${machine.name}`,\r\n          description: `Требуется провести ежемесячную инвентаризацию.\\nЛокация: ${machine.location?.name || 'Неизвестно'}`,\r\n          machineId: machine.id,\r\n          status: 'CREATED',\r\n          priority: 'MEDIUM',\r\n          type: 'INVENTORY',\r\n          dueDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000) // Срок - 5 дней\r\n        }\r\n      });\r\n      \r\n      // Добавляем запись в историю действий\r\n      await prisma.taskAction.create({\r\n        data: {\r\n          taskId: task.id,\r\n          action: 'CREATED',\r\n          comment: 'Задача создана автоматически по графику инвентаризации',\r\n          metadata: {\r\n            month: new Date().getMonth() + 1,\r\n            year: new Date().getFullYear(),\r\n            location: machine.location?.name || 'Неизвестно'\r\n          }\r\n        }\r\n      });\r\n      \r\n      logger.info(`Created inventory task #${task.id} for machine ${machine.name}`);\r\n      \r\n      // Отправляем уведомление\r\n      await sendTaskNotification(task, 'INVENTORY_REQUIRED');\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    logger.error('Error creating inventory tasks:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Отправка уведомления о задаче\r\n */\r\nasync function sendTaskNotification(task, type) {\r\n  try {\r\n    // Проверяем, доступен ли сервис уведомлений\r\n    if (!global.notificationService) {\r\n      logger.warn('Notification service not available, skipping notification');\r\n      return false;\r\n    }\r\n    \r\n    // Формируем данные для уведомления\r\n    const notificationData = {\r\n      type,\r\n      taskId: task.id,\r\n      title: task.title,\r\n      description: task.description,\r\n      priority: task.priority,\r\n      machineId: task.machineId,\r\n      dueDate: task.dueDate\r\n    };\r\n    \r\n    // Отправляем уведомление\r\n    await global.notificationService.sendTaskNotification(notificationData);\r\n    \r\n    logger.info(`Sent ${type} notification for task #${task.id}`);\r\n    return true;\r\n  } catch (error) {\r\n    logger.error(`Error sending notification for task #${task.id}:`, error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Ручной запуск проверки дефицита товаров\r\n */\r\nasync function manualCheckInventory() {\r\n  logger.info('Manual inventory check triggered');\r\n  return await createTasksForLowInventory();\r\n}\r\n\r\n/**\r\n * Ручной запуск создания задач ТО\r\n */\r\nasync function manualCreateMaintenanceTasks() {\r\n  logger.info('Manual maintenance tasks creation triggered');\r\n  return await createMaintenanceTasks();\r\n}\r\n\r\n/**\r\n * Ручной запуск создания задач инвентаризации\r\n */\r\nasync function manualCreateInventoryTasks() {\r\n  logger.info('Manual inventory tasks creation triggered');\r\n  return await createInventoryTasks();\r\n}\r\n\r\nmodule.exports = {\r\n  initScheduledTasks,\r\n  manualCheckInventory,\r\n  manualCreateMaintenanceTasks,\r\n  manualCreateInventoryTasks\r\n};\r\n",
  "services/telegram-bot/src/handlers/technicianHandler.js": "const { FSMManager } = require('../fsm/manager');\r\nconst { STATES } = require('../fsm/states');\r\nconst logger = require('@vhm24/shared/utils/logger');\r\n\r\nclass TechnicianHandler {\r\n    constructor(bot, prisma) {\r\n        this.bot = bot;\r\n        this.prisma = prisma;\r\n        this.fsmManager = new FSMManager();\r\n    }\r\n\r\n    async showTechnicianMenu(chatId, userId) {\r\n        try {\r\n            logger.info(`Showing technician menu for user ${userId}`);\r\n            \r\n            // Проверяем роль пользователя\r\n            const user = await this.prisma.user.findUnique({\r\n                where: { telegramId: userId.toString() },\r\n                include: { role: true }\r\n            });\r\n\r\n            if (!user || user.role.name !== 'TECHNICIAN') {\r\n                await this.bot.sendMessage(chatId, '❌ У вас нет доступа к функциям техника');\r\n                return;\r\n            }\r\n\r\n            // Устанавливаем состояние FSM\r\n            await this.fsmManager.setState(userId, STATES.TECHNICIAN_MENU);\r\n\r\n            const keyboard = {\r\n                inline_keyboard: [\r\n                    [\r\n                        { text: '🔧 Начать ТО', callback_data: 'tech_start_maintenance' },\r\n                        { text: '📋 Чек-листы', callback_data: 'tech_checklists' }\r\n                    ],\r\n                    [\r\n                        { text: '🔩 Замена деталей', callback_data: 'tech_parts_replacement' },\r\n                        { text: '📊 Мои отчёты', callback_data: 'tech_reports' }\r\n                    ],\r\n                    [\r\n                        { text: '🚨 Сообщить о проблеме', callback_data: 'tech_report_problem' },\r\n                        { text: '📱 Настройки', callback_data: 'settings' }\r\n                    ],\r\n                    [\r\n                        { text: '🏠 Главное меню', callback_data: 'main_menu' }\r\n                    ]\r\n                ]\r\n            };\r\n\r\n            await this.bot.sendMessage(chatId, \r\n                '🔧 *Меню техника*\\n\\n' +\r\n                'Выберите действие:\\n' +\r\n                '• Техническое обслуживание\\n' +\r\n                '• Работа с чек-листами\\n' +\r\n                '• Замена деталей\\n' +\r\n                '• Отчёты и проблемы',\r\n                { \r\n                    parse_mode: 'Markdown',\r\n                    reply_markup: keyboard \r\n                }\r\n            );\r\n\r\n        } catch (error) {\r\n            logger.error('Error showing technician menu:', error);\r\n            await this.bot.sendMessage(chatId, '❌ Ошибка при загрузке меню техника');\r\n        }\r\n    }\r\n\r\n    async startMaintenance(chatId, userId) {\r\n        try {\r\n            logger.info(`Starting maintenance for technician ${userId}`);\r\n\r\n            // Получаем список доступных автоматов для ТО\r\n            const machines = await this.prisma.machine.findMany({\r\n                where: {\r\n                    OR: [\r\n                        { status: 'MAINTENANCE_REQUIRED' },\r\n                        { status: 'OFFLINE' }\r\n                    ]\r\n                },\r\n                include: {\r\n                    location: true\r\n                }\r\n            });\r\n\r\n            if (machines.length === 0) {\r\n                await this.bot.sendMessage(chatId, \r\n                    '✅ Все автоматы в рабочем состоянии!\\n' +\r\n                    'Нет автоматов, требующих технического обслуживания.'\r\n                );\r\n                return;\r\n            }\r\n\r\n            await this.fsmManager.setState(userId, STATES.TECHNICIAN_SELECT_MACHINE);\r\n\r\n            const keyboard = {\r\n                inline_keyboard: machines.map(machine => ([\r\n                    { \r\n                        text: `🏪 ${machine.location.name} - ${machine.model}`, \r\n                        callback_data: `tech_select_machine_${machine.id}` \r\n                    }\r\n                ])).concat([[\r\n                    { text: '🔙 Назад', callback_data: 'technician_menu' }\r\n                ]])\r\n            };\r\n\r\n            await this.bot.sendMessage(chatId,\r\n                '🔧 *Выберите автомат для ТО*\\n\\n' +\r\n                `Найдено ${machines.length} автоматов, требующих обслуживания:`,\r\n                {\r\n                    parse_mode: 'Markdown',\r\n                    reply_markup: keyboard\r\n                }\r\n            );\r\n\r\n        } catch (error) {\r\n            logger.error('Error starting maintenance:', error);\r\n            await this.bot.sendMessage(chatId, '❌ Ошибка при запуске ТО');\r\n        }\r\n    }\r\n\r\n    async selectMachineForMaintenance(chatId, userId, machineId) {\r\n        try {\r\n            const machine = await this.prisma.machine.findUnique({\r\n                where: { id: parseInt(machineId) },\r\n                include: { \r\n                    location: true,\r\n                    maintenanceTasks: {\r\n                        where: { status: 'PENDING' },\r\n                        orderBy: { priority: 'desc' }\r\n                    }\r\n                }\r\n            });\r\n\r\n            if (!machine) {\r\n                await this.bot.sendMessage(chatId, '❌ Автомат не найден');\r\n                return;\r\n            }\r\n\r\n            // Создаем новую задачу ТО\r\n            const maintenanceTask = await this.prisma.maintenanceTask.create({\r\n                data: {\r\n                    machineId: machine.id,\r\n                    technicianId: parseInt(userId),\r\n                    type: 'ROUTINE',\r\n                    status: 'IN_PROGRESS',\r\n                    priority: 'MEDIUM',\r\n                    description: `Плановое ТО автомата ${machine.model}`,\r\n                    scheduledDate: new Date()\r\n                }\r\n            });\r\n\r\n            await this.fsmManager.setState(userId, STATES.TECHNICIAN_MAINTENANCE, {\r\n                machineId: machine.id,\r\n                taskId: maintenanceTask.id\r\n            });\r\n\r\n            const keyboard = {\r\n                inline_keyboard: [\r\n                    [\r\n                        { text: '📋 Начать чек-лист', callback_data: `tech_start_checklist_${maintenanceTask.id}` }\r\n                    ],\r\n                    [\r\n                        { text: '🔩 Замена деталей', callback_data: `tech_parts_${maintenanceTask.id}` },\r\n                        { text: '📸 Добавить фото', callback_data: `tech_photo_${maintenanceTask.id}` }\r\n                    ],\r\n                    [\r\n                        { text: '✅ Завершить ТО', callback_data: `tech_complete_${maintenanceTask.id}` }\r\n                    ],\r\n                    [\r\n                        { text: '🔙 Назад', callback_data: 'tech_start_maintenance' }\r\n                    ]\r\n                ]\r\n            };\r\n\r\n            await this.bot.sendMessage(chatId,\r\n                `🔧 *ТО автомата*\\n\\n` +\r\n                `📍 Локация: ${machine.location.name}\\n` +\r\n                `🤖 Модель: ${machine.model}\\n` +\r\n                `📊 Статус: ${machine.status}\\n` +\r\n                `🆔 Задача: #${maintenanceTask.id}\\n\\n` +\r\n                `Выберите действие:`,\r\n                {\r\n                    parse_mode: 'Markdown',\r\n                    reply_markup: keyboard\r\n                }\r\n            );\r\n\r\n        } catch (error) {\r\n            logger.error('Error selecting machine for maintenance:', error);\r\n            await this.bot.sendMessage(chatId, '❌ Ошибка при выборе автомата');\r\n        }\r\n    }\r\n\r\n    async startChecklist(chatId, userId, taskId) {\r\n        try {\r\n            const task = await this.prisma.maintenanceTask.findUnique({\r\n                where: { id: parseInt(taskId) },\r\n                include: { \r\n                    machine: { include: { location: true } },\r\n                    checklistItems: true\r\n                }\r\n            });\r\n\r\n            if (!task) {\r\n                await this.bot.sendMessage(chatId, '❌ Задача не найдена');\r\n                return;\r\n            }\r\n\r\n            // Стандартный чек-лист для ТО\r\n            const standardChecklist = [\r\n                'Проверка внешнего состояния',\r\n                'Проверка дисплея и интерфейса',\r\n                'Проверка купюроприемника',\r\n                'Проверка монетоприемника',\r\n                'Проверка системы выдачи',\r\n                'Проверка температурного режима',\r\n                'Проверка уровня товаров',\r\n                'Очистка и дезинфекция',\r\n                'Проверка подключений',\r\n                'Тестирование работы'\r\n            ];\r\n\r\n            // Создаем элементы чек-листа если их нет\r\n            if (task.checklistItems.length === 0) {\r\n                for (let i = 0; i < standardChecklist.length; i++) {\r\n                    await this.prisma.checklistItem.create({\r\n                        data: {\r\n                            taskId: task.id,\r\n                            description: standardChecklist[i],\r\n                            order: i + 1,\r\n                            status: 'PENDING'\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n\r\n            await this.fsmManager.setState(userId, STATES.TECHNICIAN_CHECKLIST, {\r\n                taskId: task.id,\r\n                currentItem: 0\r\n            });\r\n\r\n            await this.showNextChecklistItem(chatId, userId, task.id, 0);\r\n\r\n        } catch (error) {\r\n            logger.error('Error starting checklist:', error);\r\n            await this.bot.sendMessage(chatId, '❌ Ошибка при запуске чек-листа');\r\n        }\r\n    }\r\n\r\n    async showNextChecklistItem(chatId, userId, taskId, itemIndex) {\r\n        try {\r\n            const items = await this.prisma.checklistItem.findMany({\r\n                where: { taskId: parseInt(taskId) },\r\n                orderBy: { order: 'asc' }\r\n            });\r\n\r\n            if (itemIndex >= items.length) {\r\n                await this.completeChecklist(chatId, userId, taskId);\r\n                return;\r\n            }\r\n\r\n            const currentItem = items[itemIndex];\r\n            const completedCount = items.filter(item => item.status === 'COMPLETED').length;\r\n\r\n            const keyboard = {\r\n                inline_keyboard: [\r\n                    [\r\n                        { text: '✅ Выполнено', callback_data: `tech_check_ok_${currentItem.id}_${itemIndex}` },\r\n                        { text: '❌ Проблема', callback_data: `tech_check_issue_${currentItem.id}_${itemIndex}` }\r\n                    ],\r\n                    [\r\n                        { text: '📸 Добавить фото', callback_data: `tech_check_photo_${currentItem.id}` }\r\n                    ],\r\n                    [\r\n                        { text: '⏭️ Пропустить', callback_data: `tech_check_skip_${currentItem.id}_${itemIndex}` }\r\n                    ]\r\n                ]\r\n            };\r\n\r\n            await this.bot.sendMessage(chatId,\r\n                `📋 *Чек-лист ТО*\\n\\n` +\r\n                `Пункт ${itemIndex + 1} из ${items.length}\\n` +\r\n                `Выполнено: ${completedCount}/${items.length}\\n\\n` +\r\n                `🔍 **${currentItem.description}**\\n\\n` +\r\n                `Отметьте результат проверки:`,\r\n                {\r\n                    parse_mode: 'Markdown',\r\n                    reply_markup: keyboard\r\n                }\r\n            );\r\n\r\n        } catch (error) {\r\n            logger.error('Error showing checklist item:', error);\r\n            await this.bot.sendMessage(chatId, '❌ Ошибка при отображении чек-листа');\r\n        }\r\n    }\r\n\r\n    async handleChecklistItem(chatId, userId, itemId, itemIndex, status, comment = null) {\r\n        try {\r\n            await this.prisma.checklistItem.update({\r\n                where: { id: parseInt(itemId) },\r\n                data: {\r\n                    status: status,\r\n                    comment: comment,\r\n                    completedAt: status === 'COMPLETED' ? new Date() : null\r\n                }\r\n            });\r\n\r\n            const nextIndex = parseInt(itemIndex) + 1;\r\n            const item = await this.prisma.checklistItem.findUnique({\r\n                where: { id: parseInt(itemId) }\r\n            });\r\n\r\n            await this.showNextChecklistItem(chatId, userId, item.taskId, nextIndex);\r\n\r\n        } catch (error) {\r\n            logger.error('Error handling checklist item:', error);\r\n            await this.bot.sendMessage(chatId, '❌ Ошибка при обработке пункта чек-листа');\r\n        }\r\n    }\r\n\r\n    async completeChecklist(chatId, userId, taskId) {\r\n        try {\r\n            const items = await this.prisma.checklistItem.findMany({\r\n                where: { taskId: parseInt(taskId) }\r\n            });\r\n\r\n            const completedCount = items.filter(item => item.status === 'COMPLETED').length;\r\n            const issuesCount = items.filter(item => item.status === 'ISSUE').length;\r\n\r\n            const keyboard = {\r\n                inline_keyboard: [\r\n                    [\r\n                        { text: '🔩 Замена деталей', callback_data: `tech_parts_${taskId}` },\r\n                        { text: '📸 Добавить фото', callback_data: `tech_photo_${taskId}` }\r\n                    ],\r\n                    [\r\n                        { text: '✅ Завершить ТО', callback_data: `tech_complete_${taskId}` }\r\n                    ],\r\n                    [\r\n                        { text: '🔙 К задаче', callback_data: `tech_task_${taskId}` }\r\n                    ]\r\n                ]\r\n            };\r\n\r\n            await this.bot.sendMessage(chatId,\r\n                `✅ *Чек-лист завершён!*\\n\\n` +\r\n                `📊 Результаты:\\n` +\r\n                `• Выполнено: ${completedCount}/${items.length}\\n` +\r\n                `• Проблем: ${issuesCount}\\n\\n` +\r\n                `Что делать дальше?`,\r\n                {\r\n                    parse_mode: 'Markdown',\r\n                    reply_markup: keyboard\r\n                }\r\n            );\r\n\r\n        } catch (error) {\r\n            logger.error('Error completing checklist:', error);\r\n            await this.bot.sendMessage(chatId, '❌ Ошибка при завершении чек-листа');\r\n        }\r\n    }\r\n\r\n    async reportPartReplacement(chatId, userId, taskId) {\r\n        try {\r\n            await this.fsmManager.setState(userId, STATES.TECHNICIAN_PART_REPLACEMENT, {\r\n                taskId: taskId\r\n            });\r\n\r\n            await this.bot.sendMessage(chatId,\r\n                '🔩 *Замена деталей*\\n\\n' +\r\n                'Введите информацию о замененной детали:\\n\\n' +\r\n                'Формат: Название детали | Серийный номер | Причина замены\\n\\n' +\r\n                'Пример: Купюроприемник | SN123456 | Не принимает купюры',\r\n                { parse_mode: 'Markdown' }\r\n            );\r\n\r\n        } catch (error) {\r\n            logger.error('Error reporting part replacement:', error);\r\n            await this.bot.sendMessage(chatId, '❌ Ошибка при регистрации замены детали');\r\n        }\r\n    }\r\n\r\n    async handlePartReplacementInput(chatId, userId, text) {\r\n        try {\r\n            const state = await this.fsmManager.getState(userId);\r\n            const taskId = state.data.taskId;\r\n\r\n            const parts = text.split('|').map(part => part.trim());\r\n            if (parts.length !== 3) {\r\n                await this.bot.sendMessage(chatId,\r\n                    '❌ Неверный формат!\\n\\n' +\r\n                    'Используйте: Название | Серийный номер | Причина'\r\n                );\r\n                return;\r\n            }\r\n\r\n            const [partName, serialNumber, reason] = parts;\r\n\r\n            await this.prisma.partReplacement.create({\r\n                data: {\r\n                    taskId: parseInt(taskId),\r\n                    partName: partName,\r\n                    serialNumber: serialNumber,\r\n                    reason: reason,\r\n                    replacedAt: new Date()\r\n                }\r\n            });\r\n\r\n            const keyboard = {\r\n                inline_keyboard: [\r\n                    [\r\n                        { text: '📸 Добавить фото', callback_data: `tech_part_photo_${taskId}` }\r\n                    ],\r\n                    [\r\n                        { text: '🔩 Ещё деталь', callback_data: `tech_parts_${taskId}` },\r\n                        { text: '✅ Готово', callback_data: `tech_task_${taskId}` }\r\n                    ]\r\n                ]\r\n            };\r\n\r\n            await this.bot.sendMessage(chatId,\r\n                `✅ *Замена зарегистрирована*\\n\\n` +\r\n                `🔩 Деталь: ${partName}\\n` +\r\n                `🏷️ Серийный номер: ${serialNumber}\\n` +\r\n                `📝 Причина: ${reason}\\n\\n` +\r\n                `Добавить фото или продолжить?`,\r\n                {\r\n                    parse_mode: 'Markdown',\r\n                    reply_markup: keyboard\r\n                }\r\n            );\r\n\r\n            await this.fsmManager.setState(userId, STATES.TECHNICIAN_MAINTENANCE, {\r\n                taskId: taskId\r\n            });\r\n\r\n        } catch (error) {\r\n            logger.error('Error handling part replacement input:', error);\r\n            await this.bot.sendMessage(chatId, '❌ Ошибка при сохранении информации о детали');\r\n        }\r\n    }\r\n\r\n    async completeMaintenanceReport(chatId, userId, taskId) {\r\n        try {\r\n            const task = await this.prisma.maintenanceTask.findUnique({\r\n                where: { id: parseInt(taskId) },\r\n                include: {\r\n                    machine: { include: { location: true } },\r\n                    checklistItems: true,\r\n                    partReplacements: true\r\n                }\r\n            });\r\n\r\n            if (!task) {\r\n                await this.bot.sendMessage(chatId, '❌ Задача не найдена');\r\n                return;\r\n            }\r\n\r\n            // Обновляем статус задачи\r\n            await this.prisma.maintenanceTask.update({\r\n                where: { id: parseInt(taskId) },\r\n                data: {\r\n                    status: 'COMPLETED',\r\n                    completedAt: new Date()\r\n                }\r\n            });\r\n\r\n            // Обновляем статус автомата\r\n            const issuesCount = task.checklistItems.filter(item => item.status === 'ISSUE').length;\r\n            const newMachineStatus = issuesCount > 0 ? 'MAINTENANCE_REQUIRED' : 'ONLINE';\r\n\r\n            await this.prisma.machine.update({\r\n                where: { id: task.machineId },\r\n                data: { status: newMachineStatus }\r\n            });\r\n\r\n            // Формируем отчёт\r\n            const completedItems = task.checklistItems.filter(item => item.status === 'COMPLETED').length;\r\n            const totalItems = task.checklistItems.length;\r\n\r\n            const keyboard = {\r\n                inline_keyboard: [\r\n                    [\r\n                        { text: '📋 Новое ТО', callback_data: 'tech_start_maintenance' }\r\n                    ],\r\n                    [\r\n                        { text: '🏠 Главное меню', callback_data: 'main_menu' }\r\n                    ]\r\n                ]\r\n            };\r\n\r\n            await this.bot.sendMessage(chatId,\r\n                `✅ *ТО завершено!*\\n\\n` +\r\n                `📍 Локация: ${task.machine.location.name}\\n` +\r\n                `🤖 Автомат: ${task.machine.model}\\n` +\r\n                `🆔 Задача: #${task.id}\\n\\n` +\r\n                `📊 Результаты:\\n` +\r\n                `• Чек-лист: ${completedItems}/${totalItems}\\n` +\r\n                `• Проблем: ${issuesCount}\\n` +\r\n                `• Замен деталей: ${task.partReplacements.length}\\n` +\r\n                `• Статус автомата: ${newMachineStatus}\\n\\n` +\r\n                `⏰ Завершено: ${new Date().toLocaleString('ru-RU')}`,\r\n                {\r\n                    parse_mode: 'Markdown',\r\n                    reply_markup: keyboard\r\n                }\r\n            );\r\n\r\n            await this.fsmManager.setState(userId, STATES.TECHNICIAN_MENU);\r\n\r\n            // Отправляем уведомление менеджерам\r\n            await this.sendMaintenanceNotification(task, issuesCount);\r\n\r\n        } catch (error) {\r\n            logger.error('Error completing maintenance report:', error);\r\n            await this.bot.sendMessage(chatId, '❌ Ошибка при завершении отчёта ТО');\r\n        }\r\n    }\r\n\r\n    async sendMaintenanceNotification(task, issuesCount) {\r\n        try {\r\n            // Получаем менеджеров для уведомления\r\n            const managers = await this.prisma.user.findMany({\r\n                where: {\r\n                    role: { name: 'MANAGER' },\r\n                    telegramId: { not: null }\r\n                }\r\n            });\r\n\r\n            const message = \r\n                `🔧 *Завершено ТО*\\n\\n` +\r\n                `📍 ${task.machine.location.name}\\n` +\r\n                `🤖 ${task.machine.model}\\n` +\r\n                `👨‍🔧 Техник: ${task.technicianId}\\n` +\r\n                `⚠️ Проблем: ${issuesCount}\\n` +\r\n                `⏰ ${new Date().toLocaleString('ru-RU')}`;\r\n\r\n            for (const manager of managers) {\r\n                try {\r\n                    await this.bot.sendMessage(manager.telegramId, message, {\r\n                        parse_mode: 'Markdown'\r\n                    });\r\n                } catch (error) {\r\n                    logger.warn(`Failed to send notification to manager ${manager.id}:`, error);\r\n                }\r\n            }\r\n\r\n        } catch (error) {\r\n            logger.error('Error sending maintenance notification:', error);\r\n        }\r\n    }\r\n\r\n    async showReports(chatId, userId) {\r\n        try {\r\n            const reports = await this.prisma.maintenanceTask.findMany({\r\n                where: { \r\n                    technicianId: parseInt(userId),\r\n                    status: 'COMPLETED'\r\n                },\r\n                include: {\r\n                    machine: { include: { location: true } }\r\n                },\r\n                orderBy: { completedAt: 'desc' },\r\n                take: 10\r\n            });\r\n\r\n            if (reports.length === 0) {\r\n                await this.bot.sendMessage(chatId, \r\n                    '📊 У вас пока нет завершённых отчётов ТО'\r\n                );\r\n                return;\r\n            }\r\n\r\n            let message = '📊 *Ваши отчёты ТО*\\n\\n';\r\n            \r\n            reports.forEach((report, index) => {\r\n                message += `${index + 1}. 🏪 ${report.machine.location.name}\\n`;\r\n                message += `   📅 ${report.completedAt.toLocaleDateString('ru-RU')}\\n`;\r\n                message += `   🆔 #${report.id}\\n\\n`;\r\n            });\r\n\r\n            const keyboard = {\r\n                inline_keyboard: [\r\n                    [\r\n                        { text: '🔙 Назад', callback_data: 'technician_menu' }\r\n                    ]\r\n                ]\r\n            };\r\n\r\n            await this.bot.sendMessage(chatId, message, {\r\n                parse_mode: 'Markdown',\r\n                reply_markup: keyboard\r\n            });\r\n\r\n        } catch (error) {\r\n            logger.error('Error showing reports:', error);\r\n            await this.bot.sendMessage(chatId, '❌ Ошибка при загрузке отчётов');\r\n        }\r\n    }\r\n\r\n    async reportProblem(chatId, userId) {\r\n        try {\r\n            await this.fsmManager.setState(userId, STATES.TECHNICIAN_REPORT_PROBLEM);\r\n\r\n            await this.bot.sendMessage(chatId,\r\n                '🚨 *Сообщить о проблеме*\\n\\n' +\r\n                'Опишите проблему подробно:\\n' +\r\n                '• Что произошло?\\n' +\r\n                '• Где произошло?\\n' +\r\n                '• Когда заметили?\\n' +\r\n                '• Критичность проблемы',\r\n                { parse_mode: 'Markdown' }\r\n            );\r\n\r\n        } catch (error) {\r\n            logger.error('Error reporting problem:', error);\r\n            await this.bot.sendMessage(chatId, '❌ Ошибка при создании отчёта о проблеме');\r\n        }\r\n    }\r\n\r\n    async handleProblemReport(chatId, userId, text) {\r\n        try {\r\n            // Создаем задачу с высоким приоритетом\r\n            const problemTask = await this.prisma.maintenanceTask.create({\r\n                data: {\r\n                    technicianId: parseInt(userId),\r\n                    type: 'EMERGENCY',\r\n                    status: 'PENDING',\r\n                    priority: 'HIGH',\r\n                    description: `ПРОБЛЕМА: ${text}`,\r\n                    scheduledDate: new Date()\r\n                }\r\n            });\r\n\r\n            await this.bot.sendMessage(chatId,\r\n                `🚨 *Проблема зарегистрирована*\\n\\n` +\r\n                `🆔 Номер: #${problemTask.id}\\n` +\r\n                `📝 Описание: ${text}\\n` +\r\n                `⚡ Приоритет: ВЫСОКИЙ\\n\\n` +\r\n                `Менеджеры уведомлены!`,\r\n                { parse_mode: 'Markdown' }\r\n            );\r\n\r\n            await this.fsmManager.setState(userId, STATES.TECHNICIAN_MENU);\r\n\r\n            // Уведомляем менеджеров\r\n            await this.sendProblemNotification(problemTask, userId);\r\n\r\n        } catch (error) {\r\n            logger.error('Error handling problem report:', error);\r\n            await this.bot.sendMessage(chatId, '❌ Ошибка при сохранении отчёта о проблеме');\r\n        }\r\n    }\r\n\r\n    async sendProblemNotification(task, technicianId) {\r\n        try {\r\n            const managers = await this.prisma.user.findMany({\r\n                where: {\r\n                    role: { name: 'MANAGER' },\r\n                    telegramId: { not: null }\r\n                }\r\n            });\r\n\r\n            const message = \r\n                `🚨 *ПРОБЛЕМА!*\\n\\n` +\r\n                `👨‍🔧 Техник: ${technicianId}\\n` +\r\n                `🆔 Задача: #${task.id}\\n` +\r\n                `📝 ${task.description}\\n` +\r\n                `⏰ ${new Date().toLocaleString('ru-RU')}\\n\\n` +\r\n                `⚡ Требует немедленного внимания!`;\r\n\r\n            for (const manager of managers) {\r\n                try {\r\n                    await this.bot.sendMessage(manager.telegramId, message, {\r\n                        parse_mode: 'Markdown'\r\n                    });\r\n                } catch (error) {\r\n                    logger.warn(`Failed to send problem notification to manager ${manager.id}:`, error);\r\n                }\r\n            }\r\n\r\n        } catch (error) {\r\n            logger.error('Error sending problem notification:', error);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = { TechnicianHandler };\r\n",
  "services/telegram-bot/src/index.js": "const TelegramBot = require('node-telegram-bot-api');\r\nconst dotenv = require('dotenv');\r\nconst winston = require('winston');\r\nconst axios = require('axios');\r\nconst path = require('path');\r\n\r\n// Handlers\r\nconst { handleStart } = require('./handlers/startHandler.js');\r\nconst { handleMachines } = require('./handlers/machinesHandler.js');\r\nconst { handleInventory } = require('./handlers/inventoryHandler.js');\r\nconst { handleTasks } = require('./handlers/tasksHandler.js');\r\nconst { handleReports } = require('./handlers/reportsHandler.js');\r\nconst { handleSettings } = require('./handlers/settingsHandler.js');\r\nconst { handleCallbackQuery } = require('./handlers/callbackHandler.js');\r\nconst UploadHandler = require('./handlers/uploadHandler.js');\r\n\r\n// FSM Handlers\r\nconst registrationHandler = require('./handlers/registrationHandler.js');\r\nconst driverHandler = require('./handlers/driverHandler.js');\r\nconst warehouseHandler = require('./handlers/warehouseHandler.js');\r\nconst operatorHandler = require('./handlers/operatorHandler.js');\r\nconst { TechnicianHandler } = require('./handlers/technicianHandler.js');\r\n\r\n// FSM\r\nconst fsmManager = require('./fsm/manager.js');\r\nconst { \r\n  REGISTRATION_STATES, \r\n  DRIVER_STATES, \r\n  WAREHOUSE_STATES, \r\n  OPERATOR_STATES,\r\n  TECHNICIAN_STATES,\r\n  isRegistrationState, \r\n  isDriverState, \r\n  isWarehouseState, \r\n  isOperatorState,\r\n  isTechnicianState \r\n} = require('./fsm/states.js');\r\n\r\n// Utils\r\nconst { checkAuth } = require('./utils/auth.js');\r\nconst { errorHandler } = require('./utils/errorHandler.js');\r\n\r\n// Load environment variables\r\ndotenv.config({ path: path.join(__dirname, '../../../.env') });\r\n\r\n// Configure logger\r\nconst logger = winston.createLogger({\r\n  level: 'info',\r\n  format: winston.format.combine(\r\n    winston.format.timestamp(),\r\n    winston.format.errors({ stack: true }),\r\n    winston.format.json()\r\n  ),\r\n  transports: [\r\n    new winston.transports.Console({\r\n      format: winston.format.combine(\r\n        winston.format.colorize(),\r\n        winston.format.simple()\r\n      )\r\n    }),\r\n    new winston.transports.File({ \r\n      filename: path.join(__dirname, '../logs/error.log'), \r\n      level: 'error' \r\n    }),\r\n    new winston.transports.File({ \r\n      filename: path.join(__dirname, '../logs/combined.log') \r\n    })\r\n  ]\r\n});\r\n\r\n// Configuration\r\nconst config = {\r\n  telegramToken: process.env.TELEGRAM_BOT_TOKEN || '',\r\n  apiUrl: process.env.API_URL || 'http://localhost:8000/api/v1',\r\n  adminIds: (process.env.ADMIN_IDS || '').split(',').map(id => id.trim()),\r\n  // Определяем режим работы бота (polling или webhook)\r\n  mode: process.env.NODE_ENV === 'production' ? 'webhook' : 'polling',\r\n  polling: {\r\n    interval: 1000,\r\n    autoStart: true,\r\n    params: {\r\n      timeout: 10\r\n    }\r\n  },\r\n  webhook: {\r\n    port: process.env.TELEGRAM_WEBHOOK_PORT || 8443,\r\n    url: process.env.TELEGRAM_WEBHOOK_URL || ''\r\n  }\r\n};\r\n\r\n// Validate required configuration\r\nif (!config.telegramToken) {\r\n  logger.error('TELEGRAM_BOT_TOKEN is not set in environment variables');\r\n  process.exit(1);\r\n}\r\n\r\n// Create bot instance\r\nlet bot;\r\nif (config.mode === 'webhook' && config.webhook.url) {\r\n  logger.info(`Starting bot in webhook mode with URL: ${config.webhook.url}`);\r\n  bot = new TelegramBot(config.telegramToken, {\r\n    webhook: {\r\n      port: config.webhook.port,\r\n      host: '0.0.0.0'\r\n    }\r\n  });\r\n  // Устанавливаем webhook\r\n  bot.setWebHook(config.webhook.url)\r\n    .then(() => logger.info('Webhook set successfully'))\r\n    .catch(error => logger.error('Failed to set webhook:', error));\r\n} else {\r\n  logger.info('Starting bot in polling mode');\r\n  bot = new TelegramBot(config.telegramToken, { polling: config.polling });\r\n}\r\n\r\n// Global error handler\r\nbot.on('polling_error', (error) => {\r\n  logger.error('Polling error:', error);\r\n});\r\n\r\nbot.on('webhook_error', (error) => {\r\n  logger.error('Webhook error:', error);\r\n});\r\n\r\n// API client setup\r\nconst apiClient = axios.create({\r\n  baseURL: config.apiUrl,\r\n  timeout: 10000,\r\n  headers: {\r\n    'Content-Type': 'application/json'\r\n  }\r\n});\r\n\r\n// Request interceptor to add auth token\r\napiClient.interceptors.request.use((config) => {\r\n  const token = global.userTokens?.get(global.currentUserId);\r\n  if (token) {\r\n    config.headers.Authorization = `Bearer ${token}`;\r\n  }\r\n  return config;\r\n});\r\n\r\n// Response interceptor for error handling\r\napiClient.interceptors.response.use(\r\n  (response) => response,\r\n  (error) => {\r\n    logger.error('API Error:', error.response?.data || error.message);\r\n    throw error;\r\n  }\r\n);\r\n\r\n// Store user tokens (in production, use Redis or similar)\r\nglobal.userTokens = new Map();\r\nglobal.apiClient = apiClient;\r\nglobal.logger = logger;\r\nglobal.config = config;\r\n\r\n// Initialize handlers\r\nlet technicianHandler;\r\nlet uploadHandler;\r\n\r\n// Initialize FSM Manager\r\n(async () => {\r\n  try {\r\n    await fsmManager.initRedis();\r\n    logger.info('FSM Manager initialized');\r\n    \r\n    // Initialize TechnicianHandler after bot is ready\r\n    // Note: prisma will be initialized when needed\r\n    technicianHandler = new TechnicianHandler(bot, null);\r\n    logger.info('TechnicianHandler initialized');\r\n    \r\n    // Initialize UploadHandler for DigitalOcean Spaces integration\r\n    uploadHandler = new UploadHandler(bot);\r\n    logger.info('UploadHandler initialized - DigitalOcean Spaces ready');\r\n    \r\n    // Setup cleanup interval for temporary files\r\n    setInterval(() => {\r\n      if (uploadHandler) {\r\n        uploadHandler.cleanupTempFiles();\r\n      }\r\n    }, 60 * 60 * 1000); // Cleanup every hour\r\n    \r\n  } catch (error) {\r\n    logger.error('FSM Manager initialization failed:', error);\r\n  }\r\n})();\r\n\r\n// Command handlers\r\nbot.onText(/\\/start/, async (msg) => {\r\n  try {\r\n    await handleStart(bot, msg);\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/machines/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await handleMachines(bot, msg);\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/inventory/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await handleInventory(bot, msg);\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/tasks/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await handleTasks(bot, msg);\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/reports/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await handleReports(bot, msg);\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/settings/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await handleSettings(bot, msg);\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\n// Недостающие команды для полной функциональности\r\nbot.onText(/\\/set_password/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await bot.sendMessage(msg.chat.id, \r\n      '🔐 Смена пароля временно недоступна.\\n' +\r\n      'Обратитесь к администратору для смены пароля.'\r\n    );\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/change_password/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await bot.sendMessage(msg.chat.id, \r\n      '🔐 Изменение пароля временно недоступно.\\n' +\r\n      'Обратитесь к администратору для изменения пароля.'\r\n    );\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/route/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await bot.sendMessage(msg.chat.id, \r\n      '🚚 Управление маршрутами.\\n' +\r\n      'Используйте меню водителя для работы с маршрутами.'\r\n    );\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/fuel/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await bot.sendMessage(msg.chat.id, \r\n      '⛽ Заправка.\\n' +\r\n      'Используйте меню водителя для отчёта о заправке.'\r\n    );\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/mileage/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await bot.sendMessage(msg.chat.id, \r\n      '📏 Пробег.\\n' +\r\n      'Используйте меню водителя для ввода пробега.'\r\n    );\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/arrived/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await bot.sendMessage(msg.chat.id, \r\n      '📍 Прибытие.\\n' +\r\n      'Используйте меню водителя для подтверждения прибытия.'\r\n    );\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/receive/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await bot.sendMessage(msg.chat.id, \r\n      '📦 Приём товара.\\n' +\r\n      'Используйте меню склада для приёма товаров.'\r\n    );\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/weigh/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await bot.sendMessage(msg.chat.id, \r\n      '⚖️ Взвешивание.\\n' +\r\n      'Используйте меню склада для взвешивания товаров.'\r\n    );\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/fill_bunker/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await bot.sendMessage(msg.chat.id, \r\n      '🗂️ Заполнение бункера.\\n' +\r\n      'Используйте меню склада для заполнения бункеров.'\r\n    );\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/select_machine/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await bot.sendMessage(msg.chat.id, \r\n      '🤖 Выбор автомата.\\n' +\r\n      'Используйте меню оператора для выбора автомата.'\r\n    );\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/set_remains/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await bot.sendMessage(msg.chat.id, \r\n      '📊 Остатки.\\n' +\r\n      'Используйте меню оператора для установки остатков.'\r\n    );\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/report_problem/, async (msg) => {\r\n  try {\r\n    if (!await checkAuth(bot, msg)) return;\r\n    await bot.sendMessage(msg.chat.id, \r\n      '🚨 Сообщить о проблеме.\\n' +\r\n      'Используйте соответствующее меню для сообщения о проблемах.'\r\n    );\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\nbot.onText(/\\/help/, async (msg) => {\r\n  const helpText = `\r\n🤖 VHM24 Bot Commands\r\n\r\n/start - Start the bot and authenticate\r\n/machines - View and manage vending machines\r\n/inventory - Manage inventory items\r\n/tasks - View and manage tasks\r\n/reports - Generate reports\r\n/settings - Bot settings and preferences\r\n/help - Show this help message\r\n\r\nRole-specific commands:\r\n/route - Manage routes (drivers)\r\n/fuel - Report fuel (drivers)\r\n/mileage - Enter mileage (drivers)\r\n/arrived - Confirm arrival (drivers)\r\n/receive - Receive goods (warehouse)\r\n/weigh - Weigh items (warehouse)\r\n/fill_bunker - Fill bunkers (warehouse)\r\n/select_machine - Select machine (operators)\r\n/set_remains - Set remains (operators)\r\n/report_problem - Report problems (all)\r\n\r\nQuick Actions:\r\n• Send machine ID to view details\r\n• Send QR code photo to access machine\r\n• Send location to find nearest machines\r\n\r\nFor support, contact @vhm24_support\r\n  `;\r\n\r\n  await bot.sendMessage(msg.chat.id, helpText);\r\n});\r\n\r\n// Callback query handler\r\nbot.on('callback_query', async (callbackQuery) => {\r\n  try {\r\n    await handleCallbackQuery(bot, callbackQuery);\r\n  } catch (error) {\r\n    logger.error('Callback query error:', error);\r\n    await bot.answerCallbackQuery(callbackQuery.id, {\r\n      text: '❌ Error processing request',\r\n      show_alert: true\r\n    });\r\n  }\r\n});\r\n\r\n// FSM Message Handler - обрабатывает все сообщения через FSM\r\nbot.on('message', async (msg) => {\r\n  try {\r\n    const userId = msg.from.id;\r\n    const currentState = await fsmManager.getUserState(userId);\r\n    \r\n    // Пропускаем команды (они обрабатываются отдельно)\r\n    if (msg.text && msg.text.startsWith('/')) {\r\n      return;\r\n    }\r\n\r\n    // Обработка контактов (номер телефона)\r\n    if (msg.contact) {\r\n      if (isRegistrationState(currentState)) {\r\n        const handled = await registrationHandler.handlePhoneNumber(bot, msg);\r\n        if (handled) return;\r\n      }\r\n    }\r\n\r\n    // Обработка локации\r\n    if (msg.location) {\r\n      // FSM обработка GPS для водителей\r\n      if (isDriverState(currentState)) {\r\n        const handled = await driverHandler.handleGPSLocation(bot, msg);\r\n        if (handled) return;\r\n      }\r\n      \r\n      // Обычная обработка локации для поиска машин\r\n      if (!await checkAuth(bot, msg)) return;\r\n      \r\n      const { latitude, longitude } = msg.location;\r\n      \r\n      // Find nearest machines\r\n      const response = await global.apiClient.get('/machines', {\r\n        params: {\r\n          lat: latitude,\r\n          lon: longitude,\r\n          radius: 5000 // 5km radius\r\n        }\r\n      });\r\n\r\n      if (response.data.data.length === 0) {\r\n        await bot.sendMessage(msg.chat.id, '📍 No machines found nearby');\r\n        return;\r\n      }\r\n\r\n      const machines = response.data.data.slice(0, 5); // Show top 5 nearest\r\n      let message = '📍 Nearest Machines:\\n\\n';\r\n      \r\n      machines.forEach((machine, index) => {\r\n        const distance = machine.distance ? `${(machine.distance / 1000).toFixed(1)}km` : 'N/A';\r\n        message += `${index + 1}. ${machine.name}\\n`;\r\n        message += `   📍 ${machine.location || 'No address'}\\n`;\r\n        message += `   📏 Distance: ${distance}\\n`;\r\n        message += `   🔧 Status: ${machine.status}\\n\\n`;\r\n      });\r\n\r\n      await bot.sendMessage(msg.chat.id, message);\r\n      return;\r\n    }\r\n\r\n    // Обработка фото\r\n    if (msg.photo) {\r\n      // FSM обработка фото для водителей\r\n      if (isDriverState(currentState)) {\r\n        const handled = await driverHandler.handleFuelPhoto(bot, msg);\r\n        if (handled) return;\r\n      }\r\n\r\n      // FSM обработка фото для склада\r\n      if (isWarehouseState(currentState)) {\r\n        const handled = await warehouseHandler.handleConfirmationPhoto(bot, msg);\r\n        if (handled) return;\r\n      }\r\n\r\n      // FSM обработка фото для операторов\r\n      if (isOperatorState(currentState)) {\r\n        const handled = await operatorHandler.handleBunkerPhoto(bot, msg);\r\n        if (handled) return;\r\n      }\r\n      \r\n      // Обычная обработка фото\r\n      if (!await checkAuth(bot, msg)) return;\r\n      \r\n      await bot.sendMessage(msg.chat.id, \r\n        '📸 QR code scanning is under development.\\n' +\r\n        'Please use /machines command to access machines.'\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Обработка текстовых сообщений\r\n    if (msg.text) {\r\n      // FSM обработка текста для регистрации\r\n      if (isRegistrationState(currentState)) {\r\n        const handled = await registrationHandler.handlePassword(bot, msg);\r\n        if (handled) return;\r\n      }\r\n\r\n      // FSM обработка текста для водителей\r\n      if (isDriverState(currentState)) {\r\n        const handled = await driverHandler.handleMileage(bot, msg);\r\n        if (handled) return;\r\n      }\r\n\r\n      // FSM обработка текста для склада\r\n      if (isWarehouseState(currentState)) {\r\n        let handled = await warehouseHandler.handleItemScan(bot, msg);\r\n        if (handled) return;\r\n        \r\n        handled = await warehouseHandler.handleQuantityInput(bot, msg);\r\n        if (handled) return;\r\n        \r\n        handled = await warehouseHandler.handleWeightInput(bot, msg);\r\n        if (handled) return;\r\n      }\r\n\r\n      // FSM обработка текста для операторов\r\n      if (isOperatorState(currentState)) {\r\n        let handled = await operatorHandler.handleRemainsInput(bot, msg);\r\n        if (handled) return;\r\n        \r\n        handled = await operatorHandler.handleProblemDescription(bot, msg);\r\n        if (handled) return;\r\n      }\r\n\r\n      // FSM обработка текста для техников\r\n      if (isTechnicianState(currentState)) {\r\n        if (technicianHandler) {\r\n          if (currentState === TECHNICIAN_STATES.TECHNICIAN_PART_REPLACEMENT) {\r\n            await technicianHandler.handlePartReplacementInput(msg.chat.id, userId, msg.text);\r\n            return;\r\n          }\r\n          \r\n          if (currentState === TECHNICIAN_STATES.TECHNICIAN_REPORT_PROBLEM) {\r\n            await technicianHandler.handleProblemReport(msg.chat.id, userId, msg.text);\r\n            return;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Если сообщение не обработано FSM и пользователь авторизован\r\n      if (await checkAuth(bot, msg)) {\r\n        await bot.sendMessage(msg.chat.id,\r\n          '🤖 Используйте команды или кнопки меню для взаимодействия с ботом.\\n\\n' +\r\n          'Введите /help для просмотра доступных команд.'\r\n        );\r\n      }\r\n    }\r\n\r\n  } catch (error) {\r\n    await errorHandler(bot, msg, error);\r\n  }\r\n});\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGINT', () => {\r\n  logger.info('Shutting down Telegram bot...');\r\n  if (config.mode === 'polling') {\r\n    bot.stopPolling();\r\n  } else if (config.mode === 'webhook') {\r\n    bot.deleteWebHook();\r\n  }\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('SIGTERM', () => {\r\n  logger.info('Shutting down Telegram bot...');\r\n  if (config.mode === 'polling') {\r\n    bot.stopPolling();\r\n  } else if (config.mode === 'webhook') {\r\n    bot.deleteWebHook();\r\n  }\r\n  process.exit(0);\r\n});\r\n\r\n// Start the bot\r\nlogger.info('VHM24 Telegram Bot is starting...');\r\nlogger.info(`Admin IDs: ${config.adminIds.join(', ')}`);\r\nlogger.info(`API URL: ${config.apiUrl}`);\r\n\r\n// Set bot commands\r\nbot.setMyCommands([\r\n  { command: 'start', description: 'Start the bot' },\r\n  { command: 'machines', description: 'View machines' },\r\n  { command: 'inventory', description: 'Manage inventory' },\r\n  { command: 'tasks', description: 'View tasks' },\r\n  { command: 'reports', description: 'Generate reports' },\r\n  { command: 'settings', description: 'Bot settings' },\r\n  { command: 'help', description: 'Show help' }\r\n]).then(() => {\r\n  logger.info('Bot commands have been set');\r\n}).catch((error) => {\r\n  logger.error('Failed to set bot commands:', error);\r\n});\r\n\r\nlogger.info('VHM24 Telegram Bot is running!');\r\n\r\n\r\n// Health check endpoint for Railway\r\nconst express = require('express');\r\nconst healthApp = express();\r\nconst healthPort = process.env.PORT || 3005;\r\n\r\nhealthApp.get('/health', (req, res) => {\r\n  res.json({\r\n    status: 'ok',\r\n    service: 'telegram-bot',\r\n    timestamp: new Date().toISOString(),\r\n    uptime: process.uptime(),\r\n    bot: bot ? 'connected' : 'disconnected'\r\n  });\r\n});\r\n\r\nhealthApp.listen(healthPort, () => {\r\n  console.log(`Health check server running on port ${healthPort}`);\r\n});\r\n",
  "fix-dependencies-and-start.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Dependencies Fix and Start Script\r\n * Исправление зависимостей и запуск всех сервисов\r\n */\r\n\r\nconst { spawn, exec } = require('child_process');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nconsole.log('🔧 Исправление зависимостей и запуск VHM24...\\n');\r\n\r\n// Список сервисов с их зависимостями\r\nconst services = [\r\n  {\r\n    name: 'Notifications',\r\n    path: 'services/notifications',\r\n    dependencies: {\r\n      '@fastify/cors': '^11.0.1',\r\n      '@fastify/helmet': '^13.0.1',\r\n      '@fastify/jwt': '^9.1.0',\r\n      '@fastify/rate-limit': '^10.3.0',\r\n      '@vhm24/database': 'file:../../packages/database',\r\n      '@vhm24/shared-types': 'file:../../packages/shared-types',\r\n      'dotenv': '^16.3.1',\r\n      'fastify': '^5.4.0',\r\n      'nodemailer': '^6.9.7',\r\n      'node-telegram-bot-api': '^0.64.0',\r\n      'winston': '^3.11.0'\r\n    }\r\n  },\r\n  {\r\n    name: 'Audit',\r\n    path: 'services/audit',\r\n    dependencies: {\r\n      '@fastify/cors': '^11.0.1',\r\n      '@fastify/helmet': '^13.0.1',\r\n      '@fastify/jwt': '^9.1.0',\r\n      '@fastify/rate-limit': '^10.3.0',\r\n      '@vhm24/database': 'file:../../packages/database',\r\n      '@vhm24/shared-types': 'file:../../packages/shared-types',\r\n      '@vhm24/shared': 'file:../../packages/shared',\r\n      'dotenv': '^16.3.1',\r\n      'fastify': '^5.4.0',\r\n      'winston': '^3.11.0'\r\n    }\r\n  },\r\n  {\r\n    name: 'Gateway',\r\n    path: 'services/gateway',\r\n    dependencies: {\r\n      '@fastify/cors': '^11.0.1',\r\n      '@fastify/helmet': '^13.0.1',\r\n      '@fastify/jwt': '^9.1.0',\r\n      '@fastify/rate-limit': '^10.3.0',\r\n      '@fastify/http-proxy': '^10.0.0',\r\n      '@fastify/multipart': '^8.0.0',\r\n      '@fastify/websocket': '^10.0.0',\r\n      '@vhm24/database': 'file:../../packages/database',\r\n      '@vhm24/shared-types': 'file:../../packages/shared-types',\r\n      '@vhm24/shared': 'file:../../packages/shared',\r\n      'dotenv': '^16.3.1',\r\n      'fastify': '^5.4.0',\r\n      'uuid': '^9.0.1'\r\n    }\r\n  }\r\n];\r\n\r\n// Функция для обновления package.json\r\nfunction updatePackageJson(servicePath, dependencies) {\r\n  const packageJsonPath = path.join(__dirname, servicePath, 'package.json');\r\n  \r\n  if (!fs.existsSync(packageJsonPath)) {\r\n    console.log(`⚠️  package.json не найден: ${packageJsonPath}`);\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\r\n    \r\n    // Обновляем зависимости\r\n    packageJson.dependencies = {\r\n      ...packageJson.dependencies,\r\n      ...dependencies\r\n    };\r\n\r\n    // Сохраняем обновленный package.json\r\n    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));\r\n    console.log(`✅ Обновлен package.json для ${servicePath}`);\r\n    return true;\r\n  } catch (error) {\r\n    console.log(`❌ Ошибка обновления package.json для ${servicePath}:`, error.message);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Функция для установки зависимостей\r\nfunction installDependencies(servicePath) {\r\n  return new Promise((resolve) => {\r\n    console.log(`📦 Установка зависимостей для ${servicePath}...`);\r\n    \r\n    const installProcess = spawn('npm', ['install'], {\r\n      cwd: path.join(__dirname, servicePath),\r\n      stdio: 'pipe',\r\n      shell: true\r\n    });\r\n\r\n    let output = '';\r\n    installProcess.stdout.on('data', (data) => {\r\n      output += data.toString();\r\n    });\r\n\r\n    installProcess.stderr.on('data', (data) => {\r\n      output += data.toString();\r\n    });\r\n\r\n    installProcess.on('close', (code) => {\r\n      if (code === 0) {\r\n        console.log(`✅ Зависимости установлены для ${servicePath}`);\r\n        resolve(true);\r\n      } else {\r\n        console.log(`❌ Ошибка установки зависимостей для ${servicePath}`);\r\n        console.log(output);\r\n        resolve(false);\r\n      }\r\n    });\r\n\r\n    installProcess.on('error', (error) => {\r\n      console.log(`❌ Ошибка запуска установки для ${servicePath}:`, error.message);\r\n      resolve(false);\r\n    });\r\n  });\r\n}\r\n\r\n// Функция для создания недостающих файлов\r\nfunction createMissingFiles() {\r\n  console.log('📁 Проверка и создание недостающих файлов...');\r\n\r\n  // Создаем директории если не существуют\r\n  const directories = [\r\n    'services/notifications/src',\r\n    'services/audit/src',\r\n    'packages/shared/middleware'\r\n  ];\r\n\r\n  directories.forEach(dir => {\r\n    const fullPath = path.join(__dirname, dir);\r\n    if (!fs.existsSync(fullPath)) {\r\n      fs.mkdirSync(fullPath, { recursive: true });\r\n      console.log(`✅ Создана директория: ${dir}`);\r\n    }\r\n  });\r\n\r\n  // Проверяем наличие критически важных файлов\r\n  const criticalFiles = [\r\n    'services/notifications/src/index.js',\r\n    'services/notifications/src/services/notificationService.js',\r\n    'services/audit/src/index.js',\r\n    'packages/shared/middleware/auditMiddleware.js'\r\n  ];\r\n\r\n  let missingFiles = [];\r\n  criticalFiles.forEach(file => {\r\n    if (!fs.existsSync(path.join(__dirname, file))) {\r\n      missingFiles.push(file);\r\n    }\r\n  });\r\n\r\n  if (missingFiles.length > 0) {\r\n    console.log('⚠️  Отсутствуют критически важные файлы:');\r\n    missingFiles.forEach(file => console.log(`   - ${file}`));\r\n    return false;\r\n  }\r\n\r\n  console.log('✅ Все критически важные файлы на месте');\r\n  return true;\r\n}\r\n\r\n// Функция для проверки переменных окружения\r\nfunction checkEnvironmentVariables() {\r\n  console.log('🔍 Проверка переменных окружения...');\r\n\r\n  const envPath = path.join(__dirname, '.env');\r\n  if (!fs.existsSync(envPath)) {\r\n    console.log('⚠️  Файл .env не найден, создаем из .env.example...');\r\n    \r\n    const examplePath = path.join(__dirname, '.env.example');\r\n    if (fs.existsSync(examplePath)) {\r\n      fs.copyFileSync(examplePath, envPath);\r\n      console.log('✅ Создан файл .env из .env.example');\r\n    } else {\r\n      console.log('❌ Файл .env.example не найден');\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Проверяем критически важные переменные\r\n  const envContent = fs.readFileSync(envPath, 'utf8');\r\n  const requiredVars = ['JWT_SECRET', 'DATABASE_URL'];\r\n  \r\n  const missingVars = requiredVars.filter(varName => \r\n    !envContent.includes(`${varName}=`) || envContent.includes(`${varName}=`)\r\n  );\r\n\r\n  if (missingVars.length > 0) {\r\n    console.log('⚠️  Не хватает переменных окружения:');\r\n    missingVars.forEach(varName => console.log(`   - ${varName}`));\r\n    console.log('📝 Пожалуйста, заполните файл .env');\r\n  } else {\r\n    console.log('✅ Переменные окружения настроены');\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// Основная функция\r\nasync function main() {\r\n  try {\r\n    // 1. Проверяем и создаем недостающие файлы\r\n    if (!createMissingFiles()) {\r\n      console.log('❌ Критические файлы отсутствуют. Остановка.');\r\n      process.exit(1);\r\n    }\r\n\r\n    // 2. Проверяем переменные окружения\r\n    checkEnvironmentVariables();\r\n\r\n    // 3. Обновляем package.json файлы\r\n    console.log('\\n📝 Обновление package.json файлов...');\r\n    for (const service of services) {\r\n      updatePackageJson(service.path, service.dependencies);\r\n    }\r\n\r\n    // 4. Устанавливаем зависимости\r\n    console.log('\\n📦 Установка зависимостей...');\r\n    for (const service of services) {\r\n      const servicePath = path.join(__dirname, service.path);\r\n      if (fs.existsSync(servicePath)) {\r\n        await installDependencies(service.path);\r\n      } else {\r\n        console.log(`⚠️  Сервис не найден: ${service.path}`);\r\n      }\r\n    }\r\n\r\n    // 5. Устанавливаем зависимости для основных пакетов\r\n    console.log('\\n📦 Установка зависимостей для основных пакетов...');\r\n    const packages = ['packages/database', 'packages/shared', 'packages/shared-types'];\r\n    \r\n    for (const pkg of packages) {\r\n      const pkgPath = path.join(__dirname, pkg);\r\n      if (fs.existsSync(pkgPath)) {\r\n        await installDependencies(pkg);\r\n      }\r\n    }\r\n\r\n    // 6. Устанавливаем зависимости в корне проекта\r\n    console.log('\\n📦 Установка корневых зависимостей...');\r\n    await installDependencies('.');\r\n\r\n    console.log('\\n🎉 Все зависимости установлены успешно!');\r\n    console.log('\\n🚀 Теперь можно запускать сервисы:');\r\n    console.log('   node start-all-services-with-audit.js');\r\n    console.log('   node test-complete-system-with-notifications.js');\r\n\r\n  } catch (error) {\r\n    console.error('💥 Критическая ошибка:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Запуск\r\nif (require.main === module) {\r\n  main();\r\n}\r\n\r\nmodule.exports = { main };\r\n",
  "fix-fast-jwt.js": "/**\r\n * VHM24 - Fix Fast-JWT Compatibility\r\n * \r\n * Этот скрипт исправляет проблему совместимости fast-jwt с Node.js v22+\r\n * Проблема: fast-jwt имеет ограничение на версию Node.js < 22\r\n * Решение: Патчим package.json для удаления ограничения\r\n */\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n// Путь к package.json fast-jwt\r\nconst fastJwtPath = path.join(__dirname, 'node_modules', 'fast-jwt', 'package.json');\r\n\r\n// Проверяем существование файла\r\nif (!fs.existsSync(fastJwtPath)) {\r\n  console.error('❌ Не найден package.json для fast-jwt');\r\n  process.exit(1);\r\n}\r\n\r\ntry {\r\n  // Читаем текущий package.json\r\n  const packageJson = JSON.parse(fs.readFileSync(fastJwtPath, 'utf8'));\r\n  \r\n  // Сохраняем оригинальные engines для логирования\r\n  const originalEngines = JSON.stringify(packageJson.engines || {});\r\n  \r\n  // Удаляем ограничение на версию Node.js\r\n  if (packageJson.engines && packageJson.engines.node) {\r\n    console.log(`ℹ️ Текущее ограничение: ${packageJson.engines.node}`);\r\n    packageJson.engines.node = \">=16\";\r\n    console.log(`✅ Новое ограничение: ${packageJson.engines.node}`);\r\n  } else {\r\n    console.log('ℹ️ Ограничение на версию Node.js не найдено');\r\n  }\r\n  \r\n  // Записываем обновленный package.json\r\n  fs.writeFileSync(fastJwtPath, JSON.stringify(packageJson, null, 2), 'utf8');\r\n  \r\n  console.log(`✅ Успешно обновлен ${fastJwtPath}`);\r\n  console.log(`ℹ️ Изменено: engines с ${originalEngines} на ${JSON.stringify(packageJson.engines || {})}`);\r\n  \r\n} catch (error) {\r\n  console.error('❌ Ошибка при обновлении package.json:', error);\r\n  process.exit(1);\r\n}\r\n",
  "railway-start-production.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Railway Production Start Script\r\n * Стабильный запуск для Railway с базовой функциональностью\r\n */\r\n\r\nconst Fastify = require('fastify');\r\nconst path = require('path');\r\n\r\nconsole.log('🚂 VHM24 Railway Production Start...');\r\nconsole.log(`📍 Environment: ${process.env.NODE_ENV || 'production'}`);\r\nconsole.log(`🔌 Port: ${process.env.PORT || 8000}`);\r\n\r\n// Устанавливаем переменные окружения\r\nprocess.env.NODE_ENV = process.env.NODE_ENV || 'production';\r\nconst PORT = process.env.PORT || 8000;\r\n\r\n// Создаем Fastify сервер с логированием\r\nconst fastify = Fastify({\r\n  logger: {\r\n    level: 'info',\r\n    prettyPrint: process.env.NODE_ENV === 'development'\r\n  }\r\n});\r\n\r\n// Регистрируем CORS\r\nfastify.register(require('@fastify/cors'), {\r\n  origin: true,\r\n  credentials: true\r\n});\r\n\r\n// Health check endpoint\r\nfastify.get('/health', async (request, reply) => {\r\n  const healthData = {\r\n    status: 'ok',\r\n    service: 'vhm24-production',\r\n    timestamp: new Date().toISOString(),\r\n    environment: process.env.NODE_ENV || 'production',\r\n    port: PORT,\r\n    uptime: process.uptime(),\r\n    memory: process.memoryUsage(),\r\n    version: '1.0.0'\r\n  };\r\n\r\n  // Проверяем подключение к базе данных если доступно\r\n  if (process.env.DATABASE_URL) {\r\n    try {\r\n      const { PrismaClient } = require('@prisma/client');\r\n      const prisma = new PrismaClient();\r\n      await prisma.$queryRaw`SELECT 1`;\r\n      await prisma.$disconnect();\r\n      healthData.database = 'connected';\r\n    } catch (error) {\r\n      healthData.database = 'disconnected';\r\n      healthData.database_error = error.message;\r\n    }\r\n  }\r\n\r\n  return healthData;\r\n});\r\n\r\n// Root endpoint\r\nfastify.get('/', async (request, reply) => {\r\n  reply.type('text/html');\r\n  return `\r\n    <!DOCTYPE html>\r\n    <html lang=\"ru\">\r\n    <head>\r\n      <meta charset=\"UTF-8\">\r\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n      <title>VHM24 - Railway Production</title>\r\n      <style>\r\n        * { margin: 0; padding: 0; box-sizing: border-box; }\r\n        body { \r\n          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n          color: white;\r\n          min-height: 100vh;\r\n          display: flex;\r\n          align-items: center;\r\n          justify-content: center;\r\n        }\r\n        .container { \r\n          max-width: 900px; \r\n          margin: 0 auto; \r\n          padding: 40px;\r\n          background: rgba(255,255,255,0.1);\r\n          border-radius: 20px;\r\n          backdrop-filter: blur(10px);\r\n          box-shadow: 0 8px 32px rgba(0,0,0,0.1);\r\n          text-align: center;\r\n        }\r\n        .success { \r\n          color: #4CAF50; \r\n          font-size: 2.5em; \r\n          margin: 20px 0;\r\n          text-shadow: 2px 2px 4px rgba(0,0,0,0.3);\r\n        }\r\n        .info-grid {\r\n          display: grid;\r\n          grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\r\n          gap: 15px;\r\n          margin: 30px 0;\r\n        }\r\n        .info-card { \r\n          padding: 15px; \r\n          background: rgba(255,255,255,0.2); \r\n          border-radius: 10px;\r\n          border: 1px solid rgba(255,255,255,0.3);\r\n        }\r\n        .endpoint-list {\r\n          display: grid;\r\n          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\r\n          gap: 10px;\r\n          margin: 20px 0;\r\n        }\r\n        .endpoint { \r\n          padding: 12px; \r\n          background: rgba(255,255,255,0.15); \r\n          border-radius: 8px;\r\n          font-family: 'Courier New', monospace;\r\n          font-size: 0.9em;\r\n        }\r\n        .status-indicator {\r\n          display: inline-block;\r\n          width: 12px;\r\n          height: 12px;\r\n          border-radius: 50%;\r\n          background: #4CAF50;\r\n          margin-right: 8px;\r\n          animation: pulse 2s infinite;\r\n        }\r\n        @keyframes pulse {\r\n          0% { opacity: 1; }\r\n          50% { opacity: 0.5; }\r\n          100% { opacity: 1; }\r\n        }\r\n        .footer {\r\n          margin-top: 40px;\r\n          font-size: 0.9em;\r\n          opacity: 0.8;\r\n          border-top: 1px solid rgba(255,255,255,0.2);\r\n          padding-top: 20px;\r\n        }\r\n        .btn {\r\n          display: inline-block;\r\n          padding: 12px 24px;\r\n          margin: 10px;\r\n          background: rgba(255,255,255,0.2);\r\n          border: 1px solid rgba(255,255,255,0.3);\r\n          border-radius: 8px;\r\n          color: white;\r\n          text-decoration: none;\r\n          transition: all 0.3s ease;\r\n        }\r\n        .btn:hover {\r\n          background: rgba(255,255,255,0.3);\r\n          transform: translateY(-2px);\r\n        }\r\n      </style>\r\n    </head>\r\n    <body>\r\n      <div class=\"container\">\r\n        <h1>🎉 VHM24 Railway Production</h1>\r\n        <div class=\"success\">\r\n          <span class=\"status-indicator\"></span>\r\n          УСПЕШНО РАЗВЕРНУТО!\r\n        </div>\r\n        \r\n        <div class=\"info-grid\">\r\n          <div class=\"info-card\">\r\n            <strong>🌍 Environment</strong><br>\r\n            ${process.env.NODE_ENV || 'production'}\r\n          </div>\r\n          <div class=\"info-card\">\r\n            <strong>🔌 Port</strong><br>\r\n            ${PORT}\r\n          </div>\r\n          <div class=\"info-card\">\r\n            <strong>🚂 Railway URL</strong><br>\r\n            ${process.env.RAILWAY_STATIC_URL || 'N/A'}\r\n          </div>\r\n          <div class=\"info-card\">\r\n            <strong>⏰ Deployed</strong><br>\r\n            ${new Date().toLocaleString('ru-RU')}\r\n          </div>\r\n        </div>\r\n        \r\n        <h2>🔗 Доступные API endpoints:</h2>\r\n        <div class=\"endpoint-list\">\r\n          <div class=\"endpoint\">GET /health</div>\r\n          <div class=\"endpoint\">GET /</div>\r\n          <div class=\"endpoint\">GET /docs</div>\r\n          <div class=\"endpoint\">GET /api/status</div>\r\n        </div>\r\n        \r\n        <div style=\"margin: 30px 0;\">\r\n          <a href=\"/health\" class=\"btn\">🏥 Health Check</a>\r\n          <a href=\"/docs\" class=\"btn\">📚 Documentation</a>\r\n          <a href=\"/api/status\" class=\"btn\">📊 System Status</a>\r\n        </div>\r\n        \r\n        <h2>🎯 Статус системы:</h2>\r\n        <div class=\"info-grid\">\r\n          <div class=\"info-card\">\r\n            <strong>✅ Сервер</strong><br>\r\n            Запущен и работает\r\n          </div>\r\n          <div class=\"info-card\">\r\n            <strong>🗄️ База данных</strong><br>\r\n            ${process.env.DATABASE_URL ? 'Настроена' : 'Не настроена'}\r\n          </div>\r\n          <div class=\"info-card\">\r\n            <strong>🔐 Аутентификация</strong><br>\r\n            ${process.env.JWT_SECRET ? 'Настроена' : 'Не настроена'}\r\n          </div>\r\n          <div class=\"info-card\">\r\n            <strong>🤖 Telegram Bot</strong><br>\r\n            ${process.env.TELEGRAM_BOT_TOKEN ? 'Настроен' : 'Не настроен'}\r\n          </div>\r\n        </div>\r\n        \r\n        <div class=\"footer\">\r\n          <strong>VHM24 - VendHub Manager 24/7</strong><br>\r\n          Railway Production Deployment - Version 1.0.0<br>\r\n          Uptime: ${Math.floor(process.uptime())} seconds\r\n        </div>\r\n      </div>\r\n    </body>\r\n    </html>\r\n  `;\r\n});\r\n\r\n// API Documentation endpoint\r\nfastify.get('/docs', async (request, reply) => {\r\n  reply.type('text/html');\r\n  return `\r\n    <!DOCTYPE html>\r\n    <html lang=\"ru\">\r\n    <head>\r\n      <meta charset=\"UTF-8\">\r\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n      <title>VHM24 API Documentation</title>\r\n      <style>\r\n        body { \r\n          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n          margin: 40px; \r\n          background: #f5f5f5;\r\n          color: #333;\r\n        }\r\n        .container { max-width: 1000px; margin: 0 auto; background: white; padding: 40px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }\r\n        .endpoint { \r\n          margin: 20px 0; \r\n          padding: 20px; \r\n          border: 1px solid #ddd; \r\n          border-radius: 8px;\r\n          background: #fafafa;\r\n        }\r\n        .method { \r\n          font-weight: bold; \r\n          color: #007bff; \r\n          font-family: 'Courier New', monospace;\r\n          background: #e3f2fd;\r\n          padding: 4px 8px;\r\n          border-radius: 4px;\r\n          display: inline-block;\r\n          margin-bottom: 10px;\r\n        }\r\n        .description { margin: 10px 0; }\r\n        .response { \r\n          background: #f8f9fa; \r\n          padding: 15px; \r\n          border-radius: 5px; \r\n          font-family: 'Courier New', monospace;\r\n          font-size: 0.9em;\r\n          margin-top: 10px;\r\n        }\r\n        h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }\r\n        h2 { color: #34495e; margin-top: 30px; }\r\n        .status { color: #27ae60; font-weight: bold; }\r\n      </style>\r\n    </head>\r\n    <body>\r\n      <div class=\"container\">\r\n        <h1>🤖 VHM24 API Documentation</h1>\r\n        <p><strong>VendHub Manager 24/7 - Railway Production API</strong></p>\r\n        \r\n        <h2>📋 Основные endpoints</h2>\r\n        \r\n        <div class=\"endpoint\">\r\n          <div class=\"method\">GET /</div>\r\n          <div class=\"description\">Главная страница с информацией о развертывании</div>\r\n          <div class=\"response\">Возвращает: HTML страницу с системной информацией</div>\r\n        </div>\r\n        \r\n        <div class=\"endpoint\">\r\n          <div class=\"method\">GET /health</div>\r\n          <div class=\"description\">Health check endpoint для мониторинга состояния сервиса</div>\r\n          <div class=\"response\">\r\nВозвращает: JSON объект<br>\r\n{<br>\r\n&nbsp;&nbsp;\"status\": \"ok\",<br>\r\n&nbsp;&nbsp;\"service\": \"vhm24-production\",<br>\r\n&nbsp;&nbsp;\"timestamp\": \"2025-07-10T02:10:00.000Z\",<br>\r\n&nbsp;&nbsp;\"environment\": \"production\",<br>\r\n&nbsp;&nbsp;\"port\": 8000,<br>\r\n&nbsp;&nbsp;\"uptime\": 123.45,<br>\r\n&nbsp;&nbsp;\"memory\": {...},<br>\r\n&nbsp;&nbsp;\"database\": \"connected\"<br>\r\n}\r\n          </div>\r\n        </div>\r\n        \r\n        <div class=\"endpoint\">\r\n          <div class=\"method\">GET /docs</div>\r\n          <div class=\"description\">Эта страница документации API</div>\r\n          <div class=\"response\">Возвращает: HTML страницу с документацией</div>\r\n        </div>\r\n        \r\n        <div class=\"endpoint\">\r\n          <div class=\"method\">GET /api/status</div>\r\n          <div class=\"description\">Расширенная информация о статусе системы</div>\r\n          <div class=\"response\">Возвращает: JSON с детальной информацией о системе</div>\r\n        </div>\r\n        \r\n        <h2>📊 Системная информация</h2>\r\n        <div class=\"endpoint\">\r\n          <p><strong>Статус:</strong> <span class=\"status\">Railway production deployment успешен</span></p>\r\n          <p><strong>Environment:</strong> ${process.env.NODE_ENV || 'production'}</p>\r\n          <p><strong>Version:</strong> 1.0.0</p>\r\n          <p><strong>Port:</strong> ${PORT}</p>\r\n          <p><strong>Uptime:</strong> ${Math.floor(process.uptime())} секунд</p>\r\n        </div>\r\n        \r\n        <h2>🔧 Конфигурация</h2>\r\n        <div class=\"endpoint\">\r\n          <p><strong>База данных:</strong> ${process.env.DATABASE_URL ? '✅ Настроена' : '❌ Не настроена'}</p>\r\n          <p><strong>JWT Secret:</strong> ${process.env.JWT_SECRET ? '✅ Настроен' : '❌ Не настроен'}</p>\r\n          <p><strong>Telegram Bot:</strong> ${process.env.TELEGRAM_BOT_TOKEN ? '✅ Настроен' : '❌ Не настроен'}</p>\r\n          <p><strong>Redis:</strong> ${process.env.REDIS_URL ? '✅ Настроен' : '❌ Не настроен'}</p>\r\n        </div>\r\n        \r\n        <div style=\"margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; text-align: center; color: #666;\">\r\n          <p>VHM24 - VendHub Manager 24/7 | Railway Production API</p>\r\n        </div>\r\n      </div>\r\n    </body>\r\n    </html>\r\n  `;\r\n});\r\n\r\n// System status API endpoint\r\nfastify.get('/api/status', async (request, reply) => {\r\n  const status = {\r\n    service: 'vhm24-production',\r\n    status: 'running',\r\n    timestamp: new Date().toISOString(),\r\n    environment: process.env.NODE_ENV || 'production',\r\n    port: PORT,\r\n    uptime: process.uptime(),\r\n    memory: process.memoryUsage(),\r\n    version: '1.0.0',\r\n    railway: {\r\n      environment: process.env.RAILWAY_ENVIRONMENT || null,\r\n      static_url: process.env.RAILWAY_STATIC_URL || null,\r\n      deployment_id: process.env.RAILWAY_DEPLOYMENT_ID || null\r\n    },\r\n    configuration: {\r\n      database: !!process.env.DATABASE_URL,\r\n      jwt_secret: !!process.env.JWT_SECRET,\r\n      telegram_bot: !!process.env.TELEGRAM_BOT_TOKEN,\r\n      redis: !!process.env.REDIS_URL,\r\n      admin_ids: !!process.env.ADMIN_IDS\r\n    }\r\n  };\r\n\r\n  // Проверяем подключение к базе данных\r\n  if (process.env.DATABASE_URL) {\r\n    try {\r\n      const { PrismaClient } = require('@prisma/client');\r\n      const prisma = new PrismaClient();\r\n      await prisma.$queryRaw`SELECT 1`;\r\n      await prisma.$disconnect();\r\n      status.database = { status: 'connected', error: null };\r\n    } catch (error) {\r\n      status.database = { status: 'error', error: error.message };\r\n    }\r\n  } else {\r\n    status.database = { status: 'not_configured', error: null };\r\n  }\r\n\r\n  return status;\r\n});\r\n\r\n// 404 handler\r\nfastify.setNotFoundHandler(async (request, reply) => {\r\n  reply.code(404).type('application/json');\r\n  return {\r\n    error: 'Not Found',\r\n    message: `Route ${request.method}:${request.url} not found`,\r\n    statusCode: 404,\r\n    timestamp: new Date().toISOString()\r\n  };\r\n});\r\n\r\n// Error handler\r\nfastify.setErrorHandler(async (error, request, reply) => {\r\n  fastify.log.error(error);\r\n  reply.code(500).type('application/json');\r\n  return {\r\n    error: 'Internal Server Error',\r\n    message: error.message,\r\n    statusCode: 500,\r\n    timestamp: new Date().toISOString()\r\n  };\r\n});\r\n\r\n// Запускаем сервер\r\nconst start = async () => {\r\n  try {\r\n    await fastify.listen({ \r\n      port: PORT,\r\n      host: '0.0.0.0'\r\n    });\r\n    \r\n    console.log(`🎉 VHM24 Production is running on port ${PORT}`);\r\n    console.log(`🌐 Health check: http://localhost:${PORT}/health`);\r\n    console.log(`📚 Documentation: http://localhost:${PORT}/docs`);\r\n    console.log(`📊 System status: http://localhost:${PORT}/api/status`);\r\n    \r\n    // Railway specific logging\r\n    if (process.env.RAILWAY_ENVIRONMENT) {\r\n      console.log('🚂 Running on Railway environment:', process.env.RAILWAY_ENVIRONMENT);\r\n      console.log('🔗 Railway static URL:', process.env.RAILWAY_STATIC_URL);\r\n      console.log('🆔 Deployment ID:', process.env.RAILWAY_DEPLOYMENT_ID);\r\n    }\r\n    \r\n  } catch (err) {\r\n    console.error('❌ Server failed to start:', err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\n// Обработка сигналов для graceful shutdown\r\nprocess.on('SIGTERM', async () => {\r\n  console.log('🛑 Received SIGTERM, shutting down gracefully...');\r\n  try {\r\n    await fastify.close();\r\n    console.log('✅ Server closed successfully');\r\n    process.exit(0);\r\n  } catch (error) {\r\n    console.error('❌ Error during shutdown:', error);\r\n    process.exit(1);\r\n  }\r\n});\r\n\r\nprocess.on('SIGINT', async () => {\r\n  console.log('🛑 Received SIGINT, shutting down gracefully...');\r\n  try {\r\n    await fastify.close();\r\n    console.log('✅ Server closed successfully');\r\n    process.exit(0);\r\n  } catch (error) {\r\n    console.error('❌ Error during shutdown:', error);\r\n    process.exit(1);\r\n  }\r\n});\r\n\r\n// Обработка необработанных ошибок\r\nprocess.on('uncaughtException', (error) => {\r\n  console.error('❌ Uncaught Exception:', error);\r\n  process.exit(1);\r\n});\r\n\r\nprocess.on('unhandledRejection', (reason, promise) => {\r\n  console.error('❌ Unhandled Rejection at:', promise, 'reason:', reason);\r\n  process.exit(1);\r\n});\r\n\r\n// Запускаем приложение\r\nstart();\r\n",
  "scripts/check-railway-dependencies.js": "#!/usr/bin/env node\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nconsole.log('🔍 Checking Railway deployment compatibility...\\n');\r\n\r\n// Проблемные зависимости и их исправления\r\nconst knownIssues = {\r\n  'xlsx': {\r\n    problematic: ['^0.20.0', '^0.19.0'],\r\n    recommended: '^0.18.5',\r\n    reason: 'Version 0.20.0+ not available in npm registry'\r\n  },\r\n  'fastify': {\r\n    problematic: ['^5.0.0', '^5.4.0'],\r\n    recommended: '^4.24.3',\r\n    reason: 'Plugin compatibility issues with v5'\r\n  },\r\n  '@fastify/cors': {\r\n    problematic: ['^11.0.0'],\r\n    recommended: '^8.4.0',\r\n    reason: 'Requires fastify v4 compatibility'\r\n  },\r\n  '@fastify/helmet': {\r\n    problematic: ['^13.0.0'],\r\n    recommended: '^11.1.1',\r\n    reason: 'Requires fastify v4 compatibility'\r\n  },\r\n  '@fastify/jwt': {\r\n    problematic: ['^9.0.0'],\r\n    recommended: '^7.2.4',\r\n    reason: 'Requires fastify v4 compatibility'\r\n  },\r\n  '@fastify/rate-limit': {\r\n    problematic: ['^10.0.0'],\r\n    recommended: '^9.0.1',\r\n    reason: 'Requires fastify v4 compatibility'\r\n  },\r\n  'next': {\r\n    problematic: ['*'],\r\n    recommended: 'remove',\r\n    reason: 'Not needed in backend services',\r\n    allowedIn: ['apps/web-dashboard']\r\n  }\r\n};\r\n\r\n// Ненужные зависимости для backend сервисов\r\nconst backendUnnecessary = ['next', 'react', 'react-dom', '@types/react'];\r\n\r\nlet issuesFound = 0;\r\nlet servicesChecked = 0;\r\n\r\n// Функция для проверки версии\r\nfunction isProblematicVersion(packageName, version, issues) {\r\n  if (!issues[packageName]) return false;\r\n  \r\n  const problematic = issues[packageName].problematic;\r\n  return problematic.some(prob => {\r\n    if (prob === '*') return true;\r\n    if (prob === version) return true;\r\n    if (prob.startsWith('^') && version.startsWith('^')) {\r\n      return prob === version;\r\n    }\r\n    return false;\r\n  });\r\n}\r\n\r\n// Функция для проверки package.json\r\nfunction checkPackageJson(filePath, serviceName = 'root') {\r\n  if (!fs.existsSync(filePath)) return;\r\n  \r\n  try {\r\n    const packageJson = JSON.parse(fs.readFileSync(filePath, 'utf8'));\r\n    const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };\r\n    \r\n    console.log(`📦 Checking ${serviceName}...`);\r\n    servicesChecked++;\r\n    \r\n    let serviceIssues = 0;\r\n    \r\n    Object.entries(dependencies).forEach(([name, version]) => {\r\n      // Проверка проблемных версий\r\n      if (isProblematicVersion(name, version, knownIssues)) {\r\n        const issue = knownIssues[name];\r\n        \r\n        // Проверка исключений\r\n        if (issue.allowedIn && issue.allowedIn.some(allowed => filePath.replace(/\\\\/g, '/').includes(allowed))) {\r\n          return; // Разрешено в этом контексте\r\n        }\r\n        \r\n        console.log(`  ❌ ${name}: ${version}`);\r\n        console.log(`     Issue: ${issue.reason}`);\r\n        console.log(`     Fix: Use ${issue.recommended}`);\r\n        issuesFound++;\r\n        serviceIssues++;\r\n      }\r\n      \r\n      // Проверка ненужных зависимостей в backend сервисах\r\n      if (serviceName.includes('services/') && backendUnnecessary.includes(name)) {\r\n        console.log(`  ⚠️  ${name}: ${version}`);\r\n        console.log(`     Warning: Unnecessary for backend service`);\r\n        console.log(`     Fix: Remove this dependency`);\r\n        issuesFound++;\r\n        serviceIssues++;\r\n      }\r\n    });\r\n    \r\n    if (serviceIssues === 0) {\r\n      console.log(`  ✅ No issues found`);\r\n    }\r\n    \r\n    console.log('');\r\n    \r\n  } catch (error) {\r\n    console.log(`  ❌ Error reading ${filePath}: ${error.message}\\n`);\r\n  }\r\n}\r\n\r\n// Проверка основного package.json\r\ncheckPackageJson('./package.json', 'root');\r\n\r\n// Проверка всех сервисов\r\nconst servicesDir = './services';\r\nif (fs.existsSync(servicesDir)) {\r\n  const services = fs.readdirSync(servicesDir);\r\n  \r\n  services.forEach(service => {\r\n    const servicePath = path.join(servicesDir, service);\r\n    const packagePath = path.join(servicePath, 'package.json');\r\n    \r\n    if (fs.statSync(servicePath).isDirectory()) {\r\n      checkPackageJson(packagePath, `services/${service}`);\r\n    }\r\n  });\r\n}\r\n\r\n// Проверка приложений\r\nconst appsDir = './apps';\r\nif (fs.existsSync(appsDir)) {\r\n  const apps = fs.readdirSync(appsDir);\r\n  \r\n  apps.forEach(app => {\r\n    const appPath = path.join(appsDir, app);\r\n    const packagePath = path.join(appPath, 'package.json');\r\n    \r\n    if (fs.statSync(appPath).isDirectory()) {\r\n      checkPackageJson(packagePath, `apps/${app}`);\r\n    }\r\n  });\r\n}\r\n\r\n// Проверка пакетов\r\nconst packagesDir = './packages';\r\nif (fs.existsSync(packagesDir)) {\r\n  const packages = fs.readdirSync(packagesDir);\r\n  \r\n  packages.forEach(pkg => {\r\n    const pkgPath = path.join(packagesDir, pkg);\r\n    const packagePath = path.join(pkgPath, 'package.json');\r\n    \r\n    if (fs.statSync(pkgPath).isDirectory()) {\r\n      checkPackageJson(packagePath, `packages/${pkg}`);\r\n    }\r\n  });\r\n}\r\n\r\n// Итоговый отчёт\r\nconsole.log('=' .repeat(50));\r\nconsole.log(`📊 SUMMARY:`);\r\nconsole.log(`   Services checked: ${servicesChecked}`);\r\nconsole.log(`   Issues found: ${issuesFound}`);\r\n\r\nif (issuesFound === 0) {\r\n  console.log(`   ✅ All dependencies are Railway compatible!`);\r\n  process.exit(0);\r\n} else {\r\n  console.log(`   ❌ Found ${issuesFound} compatibility issues`);\r\n  console.log(`   🔧 Please fix the issues above before deploying to Railway`);\r\n  process.exit(1);\r\n}\r\n",
  "scripts/fix-railway-dependencies.js": "#!/usr/bin/env node\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nconsole.log('🔧 Fixing Railway deployment compatibility issues...\\n');\r\n\r\n// Исправления для зависимостей\r\nconst fixes = {\r\n  'fastify': '^4.24.3',\r\n  '@fastify/cors': '^8.4.0',\r\n  '@fastify/helmet': '^11.1.1',\r\n  '@fastify/jwt': '^7.2.4',\r\n  '@fastify/rate-limit': '^9.0.1',\r\n  'xlsx': '^0.18.5'\r\n};\r\n\r\n// Зависимости для удаления из backend сервисов\r\nconst removeFromBackend = ['next'];\r\n\r\n// Исключения - где next разрешен\r\nconst allowNext = ['apps/web-dashboard'];\r\n\r\nlet filesFixed = 0;\r\nlet issuesFixed = 0;\r\n\r\nfunction fixPackageJson(filePath, serviceName = 'root') {\r\n  if (!fs.existsSync(filePath)) return;\r\n  \r\n  try {\r\n    const packageJson = JSON.parse(fs.readFileSync(filePath, 'utf8'));\r\n    let modified = false;\r\n    \r\n    console.log(`📦 Fixing ${serviceName}...`);\r\n    \r\n    // Исправление dependencies\r\n    if (packageJson.dependencies) {\r\n      Object.keys(packageJson.dependencies).forEach(name => {\r\n        // Исправление версий\r\n        if (fixes[name] && packageJson.dependencies[name] !== fixes[name]) {\r\n          console.log(`  🔧 ${name}: ${packageJson.dependencies[name]} → ${fixes[name]}`);\r\n          packageJson.dependencies[name] = fixes[name];\r\n          modified = true;\r\n          issuesFixed++;\r\n        }\r\n        \r\n        // Удаление ненужных зависимостей из backend сервисов\r\n        if (removeFromBackend.includes(name) && serviceName.includes('services/')) {\r\n          console.log(`  🗑️  Removing ${name} from backend service`);\r\n          delete packageJson.dependencies[name];\r\n          modified = true;\r\n          issuesFixed++;\r\n        }\r\n      });\r\n    }\r\n    \r\n    // Исправление devDependencies\r\n    if (packageJson.devDependencies) {\r\n      Object.keys(packageJson.devDependencies).forEach(name => {\r\n        // Исправление версий\r\n        if (fixes[name] && packageJson.devDependencies[name] !== fixes[name]) {\r\n          console.log(`  🔧 ${name}: ${packageJson.devDependencies[name]} → ${fixes[name]}`);\r\n          packageJson.devDependencies[name] = fixes[name];\r\n          modified = true;\r\n          issuesFixed++;\r\n        }\r\n        \r\n        // Удаление ненужных зависимостей из backend сервисов\r\n        if (removeFromBackend.includes(name) && serviceName.includes('services/')) {\r\n          console.log(`  🗑️  Removing ${name} from backend service`);\r\n          delete packageJson.devDependencies[name];\r\n          modified = true;\r\n          issuesFixed++;\r\n        }\r\n      });\r\n    }\r\n    \r\n    if (modified) {\r\n      fs.writeFileSync(filePath, JSON.stringify(packageJson, null, 2) + '\\n');\r\n      filesFixed++;\r\n      console.log(`  ✅ Fixed and saved`);\r\n    } else {\r\n      console.log(`  ✅ No issues found`);\r\n    }\r\n    \r\n    console.log('');\r\n    \r\n  } catch (error) {\r\n    console.log(`  ❌ Error fixing ${filePath}: ${error.message}\\n`);\r\n  }\r\n}\r\n\r\n// Исправление основного package.json\r\nfixPackageJson('./package.json', 'root');\r\n\r\n// Исправление всех сервисов\r\nconst servicesDir = './services';\r\nif (fs.existsSync(servicesDir)) {\r\n  const services = fs.readdirSync(servicesDir);\r\n  \r\n  services.forEach(service => {\r\n    const servicePath = path.join(servicesDir, service);\r\n    const packagePath = path.join(servicePath, 'package.json');\r\n    \r\n    if (fs.statSync(servicePath).isDirectory()) {\r\n      fixPackageJson(packagePath, `services/${service}`);\r\n    }\r\n  });\r\n}\r\n\r\n// Исправление приложений (но оставляем next в web-dashboard)\r\nconst appsDir = './apps';\r\nif (fs.existsSync(appsDir)) {\r\n  const apps = fs.readdirSync(appsDir);\r\n  \r\n  apps.forEach(app => {\r\n    const appPath = path.join(appsDir, app);\r\n    const packagePath = path.join(appPath, 'package.json');\r\n    \r\n    if (fs.statSync(appPath).isDirectory()) {\r\n      // Для web-dashboard не удаляем next\r\n      if (app === 'web-dashboard') {\r\n        // Только исправляем версии, но не удаляем next\r\n        if (fs.existsSync(packagePath)) {\r\n          try {\r\n            const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));\r\n            let modified = false;\r\n            \r\n            console.log(`📦 Fixing apps/${app}...`);\r\n            \r\n            // Исправляем только версии, не удаляем next\r\n            ['dependencies', 'devDependencies'].forEach(depType => {\r\n              if (packageJson[depType]) {\r\n                Object.keys(packageJson[depType]).forEach(name => {\r\n                  if (fixes[name] && packageJson[depType][name] !== fixes[name]) {\r\n                    console.log(`  🔧 ${name}: ${packageJson[depType][name]} → ${fixes[name]}`);\r\n                    packageJson[depType][name] = fixes[name];\r\n                    modified = true;\r\n                    issuesFixed++;\r\n                  }\r\n                });\r\n              }\r\n            });\r\n            \r\n            if (modified) {\r\n              fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\\n');\r\n              filesFixed++;\r\n              console.log(`  ✅ Fixed and saved`);\r\n            } else {\r\n              console.log(`  ✅ No issues found`);\r\n            }\r\n            \r\n            console.log('');\r\n            \r\n          } catch (error) {\r\n            console.log(`  ❌ Error fixing ${packagePath}: ${error.message}\\n`);\r\n          }\r\n        }\r\n      } else {\r\n        fixPackageJson(packagePath, `apps/${app}`);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n// Исправление пакетов\r\nconst packagesDir = './packages';\r\nif (fs.existsSync(packagesDir)) {\r\n  const packages = fs.readdirSync(packagesDir);\r\n  \r\n  packages.forEach(pkg => {\r\n    const pkgPath = path.join(packagesDir, pkg);\r\n    const packagePath = path.join(pkgPath, 'package.json');\r\n    \r\n    if (fs.statSync(pkgPath).isDirectory()) {\r\n      fixPackageJson(packagePath, `packages/${pkg}`);\r\n    }\r\n  });\r\n}\r\n\r\n// Итоговый отчёт\r\nconsole.log('=' .repeat(50));\r\nconsole.log(`📊 SUMMARY:`);\r\nconsole.log(`   Files fixed: ${filesFixed}`);\r\nconsole.log(`   Issues fixed: ${issuesFixed}`);\r\n\r\nif (issuesFixed > 0) {\r\n  console.log(`   ✅ Fixed ${issuesFixed} compatibility issues!`);\r\n  console.log(`   🚀 Project is now Railway deployment ready`);\r\n} else {\r\n  console.log(`   ✅ No issues found - project is already Railway compatible!`);\r\n}\r\n",
  "scripts/prepare-railway.js": "const fs = require('fs');\r\nconst path = require('path');\r\n\r\nclass RailwayPreparation {\r\n  constructor() {\r\n    this.tasks = [];\r\n    this.warnings = [];\r\n  }\r\n\r\n  async prepare() {\r\n    console.log('🚂 Подготовка к деплою на Railway...\\n');\r\n    \r\n    try {\r\n      // 1. Проверка и создание необходимых файлов\r\n      this.createRailwayConfig();\r\n      \r\n      // 2. Обновление package.json\r\n      this.updatePackageJson();\r\n      \r\n      // 3. Создание переменных окружения\r\n      this.prepareEnvironmentVariables();\r\n      \r\n      // 4. Адаптация для Railway ограничений\r\n      this.adaptForRailwayLimitations();\r\n      \r\n      // 5. Создание скриптов деплоя\r\n      this.createDeploymentScripts();\r\n      \r\n      // 6. Финальная проверка\r\n      this.finalCheck();\r\n      \r\n      // 7. Генерация инструкций\r\n      this.generateDeploymentGuide();\r\n      \r\n    } catch (error) {\r\n      console.error('❌ Error during preparation:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  createRailwayConfig() {\r\n    console.log('📝 Создание Railway конфигурации...');\r\n    \r\n    // Обновляем nixpacks.toml для monorepo\r\n    const nixpacksConfig = `[phases.setup]\r\nnixPkgs = [\"nodejs-18_x\", \"npm-9_x\"]\r\n\r\n[phases.install]\r\ncmds = [\"npm install\", \"npm install --workspaces\"]\r\n\r\n[phases.build]\r\ncmds = [\"npm run build --if-present\"]\r\n\r\n[start]\r\ncmd = \"npm run start:production\"`;\r\n    \r\n    fs.writeFileSync('nixpacks.toml', nixpacksConfig);\r\n    this.tasks.push('Updated nixpacks.toml for monorepo');\r\n    \r\n    // Создаем railway.toml для конфигурации сервисов\r\n    const railwayConfig = `[build]\r\nbuilder = \"nixpacks\"\r\nbuildCommand = \"npm install && npm install --workspaces\"\r\n\r\n[deploy]\r\nstartCommand = \"npm run start:production\"\r\nhealthcheckPath = \"/health\"\r\nhealthcheckTimeout = 30\r\nrestartPolicyType = \"always\"\r\n\r\n[env]\r\nNODE_ENV = \"production\"`;\r\n    \r\n    fs.writeFileSync('railway.toml', railwayConfig);\r\n    this.tasks.push('Created railway.toml');\r\n  }\r\n\r\n  updatePackageJson() {\r\n    console.log('📦 Обновление package.json...');\r\n    \r\n    const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));\r\n    \r\n    // Добавляем production скрипты\r\n    pkg.scripts = pkg.scripts || {};\r\n    pkg.scripts['start:production'] = 'node scripts/start-production.js';\r\n    pkg.scripts['build'] = 'npm install --workspaces && npm run build --workspaces --if-present';\r\n    pkg.scripts['railway:deploy'] = 'npm run build && npm run start:production';\r\n    \r\n    // Убедимся что есть engines\r\n    pkg.engines = pkg.engines || {};\r\n    pkg.engines.node = '>=18.0.0';\r\n    pkg.engines.npm = '>=9.0.0';\r\n    \r\n    // Добавляем workspaces если их нет\r\n    if (!pkg.workspaces) {\r\n      pkg.workspaces = [\r\n        \"packages/*\",\r\n        \"services/*\",\r\n        \"apps/*\"\r\n      ];\r\n    }\r\n    \r\n    fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));\r\n    this.tasks.push('Updated root package.json');\r\n  }\r\n\r\n  prepareEnvironmentVariables() {\r\n    console.log('🔐 Подготовка переменных окружения...');\r\n    \r\n    const envExample = `# Railway Environment Variables for VHM24\r\n\r\n# ===== ОСНОВНЫЕ НАСТРОЙКИ =====\r\nNODE_ENV=production\r\nPORT=8000\r\n\r\n# ===== БАЗА ДАННЫХ =====\r\n# Railway PostgreSQL (автоматически добавляется Railway)\r\nDATABASE_URL=postgresql://user:password@host:port/database\r\n\r\n# ===== REDIS =====\r\n# Railway Redis (автоматически добавляется Railway)\r\nREDIS_URL=redis://default:password@host:port\r\n\r\n# ===== БЕЗОПАСНОСТЬ =====\r\nJWT_SECRET=your-super-secret-jwt-key-min-32-chars-long\r\nJWT_EXPIRES_IN=7d\r\n\r\n# ===== ВНУТРЕННИЕ URL СЕРВИСОВ =====\r\n# Railway внутренняя сеть (замените на ваши Railway URLs)\r\nGATEWAY_URL=https://gateway-production.up.railway.app\r\nAUTH_SERVICE_URL=https://auth-production.up.railway.app\r\nMACHINES_SERVICE_URL=https://machines-production.up.railway.app\r\nINVENTORY_SERVICE_URL=https://inventory-production.up.railway.app\r\nTASKS_SERVICE_URL=https://tasks-production.up.railway.app\r\nNOTIFICATIONS_SERVICE_URL=https://notifications-production.up.railway.app\r\nTELEGRAM_BOT_SERVICE_URL=https://telegram-bot-production.up.railway.app\r\n\r\n# ===== ВНЕШНИЕ СЕРВИСЫ =====\r\n# Telegram Bot\r\nTELEGRAM_BOT_TOKEN=your-bot-token-from-botfather\r\n\r\n# S3 Storage (AWS, DigitalOcean Spaces, или другой S3-совместимый)\r\nS3_BUCKET=your-s3-bucket-name\r\nS3_ACCESS_KEY=your-s3-access-key\r\nS3_SECRET_KEY=your-s3-secret-key\r\nS3_ENDPOINT=https://s3.amazonaws.com\r\nS3_REGION=us-east-1\r\n\r\n# ===== МОНИТОРИНГ И ЛОГИ =====\r\nLOG_LEVEL=info\r\nSENTRY_DSN=your-sentry-dsn-for-error-tracking\r\n\r\n# ===== CORS И БЕЗОПАСНОСТЬ =====\r\nALLOWED_ORIGINS=https://your-frontend.railway.app,https://your-dashboard.railway.app\r\nCORS_CREDENTIALS=true\r\n\r\n# ===== ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ =====\r\n# Таймауты\r\nREQUEST_TIMEOUT=30000\r\nDB_CONNECTION_TIMEOUT=10000\r\n\r\n# Лимиты\r\nMAX_FILE_SIZE=10485760\r\nMAX_REQUEST_SIZE=52428800\r\n\r\n# Кэширование\r\nCACHE_TTL=3600`;\r\n    \r\n    fs.writeFileSync('.env.railway.example', envExample);\r\n    this.tasks.push('Created .env.railway.example');\r\n    \r\n    // Создаем скрипт для проверки переменных\r\n    const envChecker = `const required = [\r\n  'DATABASE_URL',\r\n  'REDIS_URL',\r\n  'JWT_SECRET',\r\n  'TELEGRAM_BOT_TOKEN'\r\n];\r\n\r\nconst optional = [\r\n  'S3_BUCKET',\r\n  'S3_ACCESS_KEY',\r\n  'S3_SECRET_KEY',\r\n  'SENTRY_DSN'\r\n];\r\n\r\nconsole.log('🔍 Checking environment variables...');\r\n\r\nconst missing = required.filter(key => !process.env[key]);\r\nconst missingOptional = optional.filter(key => !process.env[key]);\r\n\r\nif (missing.length > 0) {\r\n  console.error('❌ Missing required environment variables:');\r\n  missing.forEach(key => console.error(\\`  - \\${key}\\`));\r\n  process.exit(1);\r\n}\r\n\r\nif (missingOptional.length > 0) {\r\n  console.warn('⚠️ Missing optional environment variables:');\r\n  missingOptional.forEach(key => console.warn(\\`  - \\${key}\\`));\r\n}\r\n\r\n// Проверка JWT секрета\r\nif (process.env.JWT_SECRET && process.env.JWT_SECRET.length < 32) {\r\n  console.error('❌ JWT_SECRET must be at least 32 characters long');\r\n  process.exit(1);\r\n}\r\n\r\n// Проверка S3 конфигурации\r\nif (process.env.S3_BUCKET && (!process.env.S3_ACCESS_KEY || !process.env.S3_SECRET_KEY)) {\r\n  console.error('❌ S3_BUCKET requires S3_ACCESS_KEY and S3_SECRET_KEY');\r\n  process.exit(1);\r\n}\r\n\r\nconsole.log('✅ All required environment variables are set');\r\nconsole.log(\\`📊 \\${required.length - missing.length}/\\${required.length} required variables configured\\`);\r\nconsole.log(\\`📊 \\${optional.length - missingOptional.length}/\\${optional.length} optional variables configured\\`);`;\r\n    \r\n    fs.writeFileSync('scripts/check-env.js', envChecker);\r\n    this.tasks.push('Created environment checker script');\r\n  }\r\n\r\n  adaptForRailwayLimitations() {\r\n    console.log('🔧 Адаптация под ограничения Railway...');\r\n    \r\n    // Railway не поддерживает персистентное хранилище\r\n    this.warnings.push('MinIO заменен на внешний S3 - настройте S3_BUCKET, S3_ACCESS_KEY, S3_SECRET_KEY');\r\n    \r\n    // Railway предоставляет только один публичный порт на сервис\r\n    this.warnings.push('Каждый сервис будет иметь свой Railway URL, обновите CORS настройки');\r\n    \r\n    // Создаем middleware для Railway специфичных настроек\r\n    const railwayMiddleware = `// Railway-specific middleware\r\nconst railwayMiddleware = (fastify, options, done) => {\r\n  // Добавляем Railway health check headers\r\n  fastify.addHook('onRequest', async (request, reply) => {\r\n    if (request.url === '/health') {\r\n      reply.header('X-Railway-Health', 'ok');\r\n    }\r\n  });\r\n  \r\n  // Обработка Railway внутренних запросов\r\n  fastify.addHook('preHandler', async (request, reply) => {\r\n    // Добавляем Railway request ID если есть\r\n    if (request.headers['x-railway-request-id']) {\r\n      request.railwayRequestId = request.headers['x-railway-request-id'];\r\n    }\r\n  });\r\n  \r\n  // Graceful shutdown для Railway\r\n  const gracefulShutdown = () => {\r\n    console.log('🛑 Received shutdown signal, closing server gracefully...');\r\n    fastify.close(() => {\r\n      console.log('✅ Server closed successfully');\r\n      process.exit(0);\r\n    });\r\n  };\r\n  \r\n  process.on('SIGTERM', gracefulShutdown);\r\n  process.on('SIGINT', gracefulShutdown);\r\n  \r\n  done();\r\n};\r\n\r\nmodule.exports = railwayMiddleware;`;\r\n    \r\n    const middlewareDir = 'packages/shared/middleware';\r\n    if (!fs.existsSync(middlewareDir)) {\r\n      fs.mkdirSync(middlewareDir, { recursive: true });\r\n    }\r\n    \r\n    fs.writeFileSync(path.join(middlewareDir, 'railway.js'), railwayMiddleware);\r\n    this.tasks.push('Created Railway-specific middleware');\r\n    \r\n    // Обновляем .railwayignore\r\n    const railwayIgnore = `# Development files\r\n*.log\r\n*.backup.*\r\nnode_modules/\r\n.env\r\n.env.local\r\n.env.development\r\n\r\n# Test files\r\ncoverage/\r\n*.test.js\r\n__tests__/\r\n\r\n# Build artifacts\r\ndist/\r\nbuild/\r\n\r\n# IDE files\r\n.vscode/\r\n.idea/\r\n*.swp\r\n*.swo\r\n\r\n# OS files\r\n.DS_Store\r\nThumbs.db\r\n\r\n# Temporary files\r\ntmp/\r\ntemp/\r\n*.tmp\r\n\r\n# Documentation (optional)\r\ndocs/\r\n*.md\r\n!README.md\r\n\r\n# Scripts not needed in production\r\nscripts/test-*\r\nscripts/dev-*\r\nscripts/local-*`;\r\n    \r\n    fs.writeFileSync('.railwayignore', railwayIgnore);\r\n    this.tasks.push('Updated .railwayignore');\r\n  }\r\n\r\n  createDeploymentScripts() {\r\n    console.log('📜 Создание скриптов деплоя...');\r\n    \r\n    // Скрипт для production запуска\r\n    const productionStarter = `// Production starter for Railway deployment\r\nconst { spawn } = require('child_process');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nconsole.log('🚀 Starting VHM24 in production mode on Railway...');\r\n\r\n// Проверка переменных окружения\r\ntry {\r\n  require('./check-env');\r\n} catch (error) {\r\n  console.error('❌ Environment check failed:', error.message);\r\n  process.exit(1);\r\n}\r\n\r\n// Определяем какой сервис запускать на основе Railway переменных\r\nconst SERVICE = process.env.RAILWAY_SERVICE_NAME || \r\n               process.env.SERVICE_NAME || \r\n               detectServiceFromPath() ||\r\n               'gateway';\r\n\r\nconsole.log(\\`🎯 Detected service: \\${SERVICE}\\`);\r\n\r\nconst serviceMap = {\r\n  'gateway': { path: 'services/gateway', port: 8000, public: true },\r\n  'auth': { path: 'services/auth', port: 3001, public: false },\r\n  'machines': { path: 'services/machines', port: 3002, public: false },\r\n  'inventory': { path: 'services/inventory', port: 3003, public: false },\r\n  'tasks': { path: 'services/tasks', port: 3004, public: false },\r\n  'telegram-bot': { path: 'services/telegram-bot', port: 3005, public: false },\r\n  'notifications': { path: 'services/notifications', port: 3006, public: false },\r\n  'audit': { path: 'services/audit', port: 3007, public: false },\r\n  'data-import': { path: 'services/data-import', port: 3008, public: false },\r\n  'backup': { path: 'services/backup', port: 3009, public: false },\r\n  'monitoring': { path: 'services/monitoring', port: 3010, public: false },\r\n  'routes': { path: 'services/routes', port: 3011, public: false },\r\n  'warehouse': { path: 'services/warehouse', port: 3012, public: false },\r\n  'recipes': { path: 'services/recipes', port: 3013, public: false },\r\n  'bunkers': { path: 'services/bunkers', port: 3014, public: false }\r\n};\r\n\r\nconst service = serviceMap[SERVICE];\r\n\r\nif (!service) {\r\n  console.error(\\`❌ Unknown service: \\${SERVICE}\\`);\r\n  console.log('Available services:', Object.keys(serviceMap).join(', '));\r\n  process.exit(1);\r\n}\r\n\r\n// Проверяем существование сервиса\r\nif (!fs.existsSync(service.path)) {\r\n  console.error(\\`❌ Service path not found: \\${service.path}\\`);\r\n  process.exit(1);\r\n}\r\n\r\n// Устанавливаем PORT для Railway\r\nprocess.env.PORT = process.env.PORT || service.port.toString();\r\n\r\nconsole.log(\\`🚀 Starting \\${SERVICE} service...\\`);\r\nconsole.log(\\`📁 Path: \\${service.path}\\`);\r\nconsole.log(\\`🌐 Port: \\${process.env.PORT}\\`);\r\nconsole.log(\\`🔓 Public: \\${service.public ? 'Yes' : 'No'}\\`);\r\n\r\n// Устанавливаем дополнительные переменные для сервиса\r\nprocess.env.SERVICE_NAME = SERVICE;\r\nprocess.env.SERVICE_PATH = service.path;\r\n\r\n// Запускаем сервис\r\nconst child = spawn('npm', ['start'], {\r\n  cwd: service.path,\r\n  stdio: 'inherit',\r\n  env: process.env\r\n});\r\n\r\nchild.on('error', (error) => {\r\n  console.error('❌ Failed to start service:', error);\r\n  process.exit(1);\r\n});\r\n\r\nchild.on('exit', (code) => {\r\n  console.log(\\`🛑 Service \\${SERVICE} exited with code \\${code}\\`);\r\n  process.exit(code);\r\n});\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGTERM', () => {\r\n  console.log('🛑 Received SIGTERM, shutting down gracefully...');\r\n  child.kill('SIGTERM');\r\n});\r\n\r\nprocess.on('SIGINT', () => {\r\n  console.log('🛑 Received SIGINT, shutting down gracefully...');\r\n  child.kill('SIGINT');\r\n});\r\n\r\nfunction detectServiceFromPath() {\r\n  // Пытаемся определить сервис из текущего пути или переменных Railway\r\n  const cwd = process.cwd();\r\n  const servicePath = cwd.split(path.sep).find(part => \r\n    Object.keys(serviceMap).includes(part)\r\n  );\r\n  \r\n  return servicePath || null;\r\n}`;\r\n    \r\n    fs.writeFileSync('scripts/start-production.js', productionStarter);\r\n    this.tasks.push('Created production starter script');\r\n  }\r\n\r\n  finalCheck() {\r\n    console.log('\\n🔍 Финальная проверка...');\r\n    \r\n    const checklist = {\r\n      'Root package.json': fs.existsSync('package.json'),\r\n      'Start script': JSON.parse(fs.readFileSync('package.json', 'utf8')).scripts?.['start:production'],\r\n      'Node version specified': JSON.parse(fs.readFileSync('package.json', 'utf8')).engines?.node,\r\n      'Environment example': fs.existsSync('.env.railway.example'),\r\n      'Railway config': fs.existsSync('railway.toml'),\r\n      'Nixpacks config': fs.existsSync('nixpacks.toml'),\r\n      'S3 adapter': fs.existsSync('packages/shared/storage/s3.js'),\r\n      'Railway middleware': fs.existsSync('packages/shared/middleware/railway.js'),\r\n      'Environment checker': fs.existsSync('scripts/check-env.js'),\r\n      'Production starter': fs.existsSync('scripts/start-production.js')\r\n    };\r\n    \r\n    Object.entries(checklist).forEach(([item, status]) => {\r\n      console.log(`${status ? '✅' : '❌'} ${item}`);\r\n    });\r\n    \r\n    const passed = Object.values(checklist).filter(Boolean).length;\r\n    const total = Object.keys(checklist).length;\r\n    \r\n    console.log(`\\n📊 Readiness: ${passed}/${total} (${Math.round(passed/total*100)}%)`);\r\n  }\r\n\r\n  generateDeploymentGuide() {\r\n    console.log('\\n📚 Генерация руководства по деплою...');\r\n    \r\n    const guide = `# Railway Deployment Guide for VHM24\r\n\r\n## 🎯 Обзор\r\n\r\nVHM24 готов к деплою на Railway как monorepo с несколькими сервисами.\r\n\r\n## 📋 Pre-deployment Checklist\r\n\r\n### 1. Подготовка Railway проекта\r\n- [ ] Создан аккаунт на Railway\r\n- [ ] Установлен Railway CLI\r\n- [ ] Выполнен вход\r\n\r\n### 2. Настройка внешних сервисов\r\n- [ ] Настроен S3-совместимый storage\r\n- [ ] Создан Telegram Bot\r\n- [ ] Настроен Sentry (опционально)\r\n\r\n## 🚀 Deployment Steps\r\n\r\n### Шаг 1: Создание Railway проекта\r\nrailway new vhm24-production\r\nrailway link\r\n\r\n### Шаг 2: Добавление баз данных\r\nrailway add postgresql\r\nrailway add redis\r\n\r\n### Шаг 3: Настройка переменных окружения\r\nСкопируйте переменные из .env.railway.example\r\n\r\n### Шаг 4: Деплой\r\nrailway variables set RAILWAY_SERVICE_NAME=\"gateway\"\r\nrailway up\r\n\r\n## ⚠️ Важные замечания\r\n\r\n${this.warnings.map(w => `- ${w}`).join('\\n')}\r\n\r\n## 🔧 Troubleshooting\r\n\r\n### Проблема: Сервис не запускается\r\nrailway logs\r\nrailway variables\r\nrailway status\r\n\r\n### Проблема: База данных не подключается\r\n- Проверьте DATABASE_URL\r\n- Убедитесь что PostgreSQL addon активен\r\n\r\n### Проблема: Файлы не загружаются\r\n- Проверьте S3 credentials\r\n- Убедитесь что bucket существует\r\n\r\n## 📞 Поддержка\r\n\r\n- Railway Discord: https://discord.gg/railway\r\n- Railway Docs: https://docs.railway.app\r\n`;\r\n    \r\n    fs.writeFileSync('RAILWAY_DEPLOYMENT_GUIDE.md', guide);\r\n    this.tasks.push('Created comprehensive deployment guide');\r\n    \r\n    console.log('\\n✅ Railway preparation completed!');\r\n    console.log('\\n📋 Completed tasks:');\r\n    this.tasks.forEach(task => console.log(`  ✅ ${task}`));\r\n    \r\n    if (this.warnings.length > 0) {\r\n      console.log('\\n⚠️ Important warnings:');\r\n      this.warnings.forEach(warning => console.log(`  ⚠️ ${warning}`));\r\n    }\r\n    \r\n    console.log('\\n📖 Next steps:');\r\n    console.log('1. Review RAILWAY_DEPLOYMENT_GUIDE.md');\r\n    console.log('2. Set up external services (S3, Telegram Bot)');\r\n    console.log('3. Create Railway project: railway new vhm24-production');\r\n    console.log('4. Add databases: railway add postgresql && railway add redis');\r\n    console.log('5. Set environment variables from .env.railway.example');\r\n    console.log('6. Deploy: railway up');\r\n    \r\n    console.log('\\n🎯 Quick start command:');\r\n    console.log('railway variables set RAILWAY_SERVICE_NAME=gateway && railway up');\r\n  }\r\n}\r\n\r\n// Запуск подготовки\r\nconst prep = new RailwayPreparation();\r\nprep.prepare().catch(console.error);\r\n",
  "services/monitoring/src/index.js": "/**\r\n * VHM24 - VendHub Manager 24/7\r\n * Monitoring Service\r\n * Мониторинг системы и метрики для Prometheus\r\n */\r\n\r\nrequire('dotenv').config({ path: require('path').join(__dirname, '../../../.env') });\r\nconst Fastify = require('fastify');\r\nconst cors = require('@fastify/cors');\r\nconst jwt = require('@fastify/jwt');\r\nconst client = require('prom-client');\r\nconst { getPrismaClient } = require('@vhm24/database');\r\n\r\nconst prisma = getPrismaClient();\r\nconst fastify = Fastify({ \r\n  logger: true,\r\n  trustProxy: true\r\n});\r\n\r\n// Проверка обязательных переменных окружения\r\nif (!process.env.JWT_SECRET) {\r\n  throw new Error('JWT_SECRET must be set in environment variables');\r\n}\r\n\r\n// Создаем реестр для метрик\r\nconst register = new client.Registry();\r\n\r\n// Добавляем метрики по умолчанию (CPU, память и т.д.)\r\nclient.collectDefaultMetrics({ register });\r\n\r\n// Кастомные метрики\r\nconst httpRequestDuration = new client.Histogram({\r\n  name: 'vhm24_http_request_duration_seconds',\r\n  help: 'Duration of HTTP requests in seconds',\r\n  labelNames: ['method', 'route', 'status_code', 'service'],\r\n  buckets: [0.1, 0.5, 1, 2, 5]\r\n});\r\n\r\nconst httpRequestTotal = new client.Counter({\r\n  name: 'vhm24_http_requests_total',\r\n  help: 'Total number of HTTP requests',\r\n  labelNames: ['method', 'route', 'status_code', 'service']\r\n});\r\n\r\nconst machinesOnline = new client.Gauge({\r\n  name: 'vhm24_machines_online',\r\n  help: 'Number of online vending machines'\r\n});\r\n\r\nconst machinesOffline = new client.Gauge({\r\n  name: 'vhm24_machines_offline',\r\n  help: 'Number of offline vending machines'\r\n});\r\n\r\nconst machinesError = new client.Gauge({\r\n  name: 'vhm24_machines_error',\r\n  help: 'Number of vending machines with errors'\r\n});\r\n\r\nconst tasksOpen = new client.Gauge({\r\n  name: 'vhm24_tasks_open',\r\n  help: 'Number of open tasks'\r\n});\r\n\r\nconst tasksCompleted = new client.Counter({\r\n  name: 'vhm24_tasks_completed_total',\r\n  help: 'Total number of completed tasks'\r\n});\r\n\r\nconst inventoryLowStock = new client.Gauge({\r\n  name: 'vhm24_inventory_low_stock',\r\n  help: 'Number of items with low stock'\r\n});\r\n\r\nconst transactionsTotal = new client.Counter({\r\n  name: 'vhm24_transactions_total',\r\n  help: 'Total number of transactions',\r\n  labelNames: ['status', 'payment_type']\r\n});\r\n\r\nconst transactionsAmount = new client.Counter({\r\n  name: 'vhm24_transactions_amount_total',\r\n  help: 'Total amount of transactions',\r\n  labelNames: ['currency']\r\n});\r\n\r\nconst activeUsers = new client.Gauge({\r\n  name: 'vhm24_users_active',\r\n  help: 'Number of active users'\r\n});\r\n\r\nconst databaseConnections = new client.Gauge({\r\n  name: 'vhm24_database_connections',\r\n  help: 'Number of database connections'\r\n});\r\n\r\nconst apiErrors = new client.Counter({\r\n  name: 'vhm24_api_errors_total',\r\n  help: 'Total number of API errors',\r\n  labelNames: ['service', 'error_type']\r\n});\r\n\r\n// Регистрируем все метрики\r\nregister.registerMetric(httpRequestDuration);\r\nregister.registerMetric(httpRequestTotal);\r\nregister.registerMetric(machinesOnline);\r\nregister.registerMetric(machinesOffline);\r\nregister.registerMetric(machinesError);\r\nregister.registerMetric(tasksOpen);\r\nregister.registerMetric(tasksCompleted);\r\nregister.registerMetric(inventoryLowStock);\r\nregister.registerMetric(transactionsTotal);\r\nregister.registerMetric(transactionsAmount);\r\nregister.registerMetric(activeUsers);\r\nregister.registerMetric(databaseConnections);\r\nregister.registerMetric(apiErrors);\r\n\r\n// CORS\r\nfastify.register(cors, {\r\n  origin: (origin, cb) => {\r\n    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'];\r\n    if (!origin || allowedOrigins.includes(origin)) {\r\n      cb(null, true);\r\n    } else {\r\n      cb(new Error('Not allowed by CORS'));\r\n    }\r\n  },\r\n  credentials: true\r\n});\r\n\r\n// JWT\r\nfastify.register(jwt, {\r\n  secret: process.env.JWT_SECRET,\r\n  verify: {\r\n    issuer: ['vhm24-gateway', 'vhm24-auth']\r\n  }\r\n});\r\n\r\n// Декоратор для проверки авторизации\r\nfastify.decorate('authenticate', async function(request, reply) {\r\n  try {\r\n    await request.jwtVerify();\r\n  } catch (err) {\r\n    reply.code(401).send({ \r\n      success: false,\r\n      error: 'Unauthorized',\r\n      message: err.message || 'Invalid or expired token'\r\n    });\r\n  }\r\n});\r\n\r\n// Health check\r\nfastify.get('/health', async (request, reply) => {\r\n  return { \r\n    status: 'ok', \r\n    service: 'monitoring',\r\n    metrics: {\r\n      prometheus: 'enabled',\r\n      endpoint: '/metrics'\r\n    }\r\n  };\r\n});\r\n\r\n// Prometheus метрики endpoint\r\nfastify.get('/metrics', async (request, reply) => {\r\n  try {\r\n    // Обновляем метрики из базы данных\r\n    await updateMetrics();\r\n    \r\n    // Возвращаем метрики в формате Prometheus\r\n    reply.type('text/plain');\r\n    return register.metrics();\r\n  } catch (error) {\r\n    fastify.log.error('Failed to collect metrics:', error);\r\n    reply.code(500).send('Failed to collect metrics');\r\n  }\r\n});\r\n\r\n// Функция обновления метрик\r\nasync function updateMetrics() {\r\n  try {\r\n    // Метрики машин\r\n    const [onlineCount, offlineCount, errorCount] = await Promise.all([\r\n      prisma.machine.count({ where: { status: 'ONLINE' } }),\r\n      prisma.machine.count({ where: { status: 'OFFLINE' } }),\r\n      prisma.machine.count({ where: { status: 'ERROR' } })\r\n    ]);\r\n    \r\n    machinesOnline.set(onlineCount);\r\n    machinesOffline.set(offlineCount);\r\n    machinesError.set(errorCount);\r\n    \r\n    // Метрики задач\r\n    const openTasksCount = await prisma.task.count({\r\n      where: {\r\n        status: { in: ['CREATED', 'ASSIGNED', 'IN_PROGRESS'] }\r\n      }\r\n    });\r\n    \r\n    tasksOpen.set(openTasksCount);\r\n    \r\n    // Метрики инвентаря\r\n    const lowStockCount = await prisma.inventoryItem.count({\r\n      where: {\r\n        quantity: { lte: 10 } // TODO: Использовать minQuantity\r\n      }\r\n    });\r\n    \r\n    inventoryLowStock.set(lowStockCount);\r\n    \r\n    // Метрики пользователей\r\n    const activeUsersCount = await prisma.user.count({\r\n      where: { isActive: true }\r\n    });\r\n    \r\n    activeUsers.set(activeUsersCount);\r\n    \r\n  } catch (error) {\r\n    fastify.log.error('Failed to update metrics:', error);\r\n    apiErrors.inc({ service: 'monitoring', error_type: 'metrics_update' });\r\n  }\r\n}\r\n\r\n// API для получения детальной статистики\r\nfastify.get('/api/v1/monitoring/stats', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const stats = {\r\n      machines: {\r\n        total: await prisma.machine.count(),\r\n        online: await prisma.machine.count({ where: { status: 'ONLINE' } }),\r\n        offline: await prisma.machine.count({ where: { status: 'OFFLINE' } }),\r\n        maintenance: await prisma.machine.count({ where: { status: 'MAINTENANCE' } }),\r\n        error: await prisma.machine.count({ where: { status: 'ERROR' } })\r\n      },\r\n      tasks: {\r\n        total: await prisma.task.count(),\r\n        created: await prisma.task.count({ where: { status: 'CREATED' } }),\r\n        assigned: await prisma.task.count({ where: { status: 'ASSIGNED' } }),\r\n        inProgress: await prisma.task.count({ where: { status: 'IN_PROGRESS' } }),\r\n        completed: await prisma.task.count({ where: { status: 'COMPLETED' } }),\r\n        cancelled: await prisma.task.count({ where: { status: 'CANCELLED' } })\r\n      },\r\n      inventory: {\r\n        totalItems: await prisma.inventoryItem.count(),\r\n        activeItems: await prisma.inventoryItem.count({ where: { isActive: true } }),\r\n        lowStock: await prisma.inventoryItem.count({ where: { quantity: { lte: 10 } } }),\r\n        outOfStock: await prisma.inventoryItem.count({ where: { quantity: 0 } })\r\n      },\r\n      users: {\r\n        total: await prisma.user.count(),\r\n        active: await prisma.user.count({ where: { isActive: true } }),\r\n        byRole: await prisma.user.groupBy({\r\n          by: ['roles'],\r\n          _count: true\r\n        })\r\n      },\r\n      transactions: {\r\n        today: await prisma.transaction.count({\r\n          where: {\r\n            createdAt: {\r\n              gte: new Date(new Date().setHours(0, 0, 0, 0))\r\n            }\r\n          }\r\n        }),\r\n        todayAmount: await prisma.transaction.aggregate({\r\n          where: {\r\n            createdAt: {\r\n              gte: new Date(new Date().setHours(0, 0, 0, 0))\r\n            },\r\n            status: 'SUCCESS'\r\n          },\r\n          _sum: { amount: true }\r\n        }),\r\n        last24h: await prisma.transaction.count({\r\n          where: {\r\n            createdAt: {\r\n              gte: new Date(Date.now() - 24 * 60 * 60 * 1000)\r\n            }\r\n          }\r\n        })\r\n      },\r\n      system: {\r\n        uptime: process.uptime(),\r\n        memory: process.memoryUsage(),\r\n        cpu: process.cpuUsage()\r\n      }\r\n    };\r\n    \r\n    return {\r\n      success: true,\r\n      data: stats\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    apiErrors.inc({ service: 'monitoring', error_type: 'stats_fetch' });\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch statistics'\r\n    });\r\n  }\r\n});\r\n\r\n// API для получения истории метрик\r\nfastify.get('/api/v1/monitoring/history', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    querystring: {\r\n      type: 'object',\r\n      properties: {\r\n        metric: { type: 'string' },\r\n        from: { type: 'string', format: 'date-time' },\r\n        to: { type: 'string', format: 'date-time' },\r\n        interval: { type: 'string', enum: ['1m', '5m', '15m', '1h', '1d'], default: '5m' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { metric, from, to, interval } = request.query;\r\n  \r\n  // TODO: Интеграция с системой хранения временных рядов (InfluxDB, TimescaleDB)\r\n  \r\n  return {\r\n    success: false,\r\n    error: 'History storage not implemented yet',\r\n    message: 'Please use Prometheus with Grafana for historical data'\r\n  };\r\n});\r\n\r\n// API для настройки алертов\r\nfastify.post('/api/v1/monitoring/alerts', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['name', 'condition', 'threshold', 'action'],\r\n      properties: {\r\n        name: { type: 'string' },\r\n        description: { type: 'string' },\r\n        metric: { type: 'string' },\r\n        condition: { type: 'string', enum: ['gt', 'lt', 'eq', 'ne'] },\r\n        threshold: { type: 'number' },\r\n        action: {\r\n          type: 'object',\r\n          properties: {\r\n            type: { type: 'string', enum: ['email', 'telegram', 'webhook'] },\r\n            target: { type: 'string' }\r\n          }\r\n        },\r\n        enabled: { type: 'boolean', default: true }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  // TODO: Реализовать систему алертов\r\n  \r\n  return {\r\n    success: false,\r\n    error: 'Alerts not implemented yet',\r\n    message: 'Please use Prometheus AlertManager for alerts'\r\n  };\r\n});\r\n\r\n// Middleware для отслеживания HTTP запросов\r\nfastify.addHook('onRequest', async (request, reply) => {\r\n  request.startTime = Date.now();\r\n});\r\n\r\nfastify.addHook('onResponse', async (request, reply) => {\r\n  const duration = (Date.now() - request.startTime) / 1000;\r\n  const labels = {\r\n    method: request.method,\r\n    route: request.routerPath || request.url,\r\n    status_code: reply.statusCode,\r\n    service: 'monitoring'\r\n  };\r\n  \r\n  httpRequestDuration.observe(labels, duration);\r\n  httpRequestTotal.inc(labels);\r\n});\r\n\r\n// Периодическое обновление метрик\r\nsetInterval(async () => {\r\n  try {\r\n    await updateMetrics();\r\n  } catch (error) {\r\n    fastify.log.error('Failed to update metrics:', error);\r\n  }\r\n}, 30000); // Каждые 30 секунд\r\n\r\n// Start server\r\nconst start = async () => {\r\n  try {\r\n    await fastify.listen({ \r\n      port: process.env.MONITORING_PORT || 3008,\r\n      host: '0.0.0.0'\r\n    });\r\n    console.log('VHM24 Monitoring Service running 24/7 on port', process.env.MONITORING_PORT || 3008);\r\n    console.log('Prometheus metrics available at /metrics');\r\n    \r\n    // Первоначальное обновление метрик\r\n    await updateMetrics();\r\n  } catch (err) {\r\n    fastify.log.error(err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\nstart();\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGTERM', async () => {\r\n  await fastify.close();\r\n  await prisma.$disconnect();\r\n  process.exit(0);\r\n});\r\n",
  "services/notifications/src/index.js": "/**\r\n * VHM24 - VendHub Manager 24/7\r\n * Notifications Service\r\n * Управление уведомлениями через различные каналы\r\n */\r\n\r\nrequire('dotenv').config({ path: require('path').join(__dirname, '../../../.env') });\r\nconst Fastify = require('fastify');\r\nconst cors = require('@fastify/cors');\r\nconst jwt = require('@fastify/jwt');\r\nconst rateLimit = require('@fastify/rate-limit');\r\nconst helmet = require('@fastify/helmet');\r\nconst nodemailer = require('nodemailer');\r\nconst { getPrismaClient } = require('@vhm24/database');\r\nconst { sanitizeInput, validateEmail } = require('@vhm24/shared-types/src/security');\r\nconst NotificationService = require('./services/notificationService');\r\n\r\nconst prisma = getPrismaClient();\r\nconst notificationService = new NotificationService();\r\nconst fastify = Fastify({ \r\n  logger: true,\r\n  trustProxy: true\r\n});\r\n\r\n// Проверка обязательных переменных окружения\r\nif (!process.env.JWT_SECRET) {\r\n  throw new Error('JWT_SECRET must be set in environment variables');\r\n}\r\n\r\n// Email транспорт\r\nlet emailTransporter = null;\r\nif (process.env.SMTP_HOST && process.env.SMTP_USER && process.env.SMTP_PASS) {\r\n  emailTransporter = nodemailer.createTransport({\r\n    host: process.env.SMTP_HOST,\r\n    port: parseInt(process.env.SMTP_PORT) || 587,\r\n    secure: false,\r\n    auth: {\r\n      user: process.env.SMTP_USER,\r\n      pass: process.env.SMTP_PASS\r\n    }\r\n  });\r\n}\r\n\r\n// Security headers\r\nfastify.register(helmet);\r\n\r\n// Rate limiting\r\nfastify.register(rateLimit, {\r\n  max: parseInt(process.env.RATE_LIMIT_MAX) || 100,\r\n  timeWindow: parseInt(process.env.RATE_LIMIT_WINDOW) || 60000\r\n});\r\n\r\n// CORS\r\nfastify.register(cors, {\r\n  origin: (origin, cb) => {\r\n    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'];\r\n    if (!origin || allowedOrigins.includes(origin)) {\r\n      cb(null, true);\r\n    } else {\r\n      cb(new Error('Not allowed by CORS'));\r\n    }\r\n  },\r\n  credentials: true\r\n});\r\n\r\n// JWT\r\nfastify.register(jwt, {\r\n  secret: process.env.JWT_SECRET,\r\n  verify: {\r\n    issuer: ['vhm24-gateway', 'vhm24-auth']\r\n  }\r\n});\r\n\r\n// Декоратор для проверки авторизации\r\nfastify.decorate('authenticate', async function(request, reply) {\r\n  try {\r\n    await request.jwtVerify();\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: request.user.id },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        roles: true,\r\n        isActive: true\r\n      }\r\n    });\r\n    \r\n    if (!user || !user.isActive) {\r\n      throw new Error('User not found or inactive');\r\n    }\r\n    \r\n    request.user = user;\r\n  } catch (err) {\r\n    reply.code(401).send({ \r\n      success: false,\r\n      error: 'Unauthorized',\r\n      message: err.message || 'Invalid or expired token'\r\n    });\r\n  }\r\n});\r\n\r\n// Health check\r\nfastify.get('/health', async (request, reply) => {\r\n  return { \r\n    status: 'ok', \r\n    service: 'notifications',\r\n    channels: {\r\n      email: emailTransporter ? 'configured' : 'not configured',\r\n      telegram: process.env.TELEGRAM_BOT_TOKEN ? 'configured' : 'not configured',\r\n      push: process.env.FCM_SERVER_KEY ? 'configured' : 'not configured'\r\n    }\r\n  };\r\n});\r\n\r\n// Отправить email уведомление\r\nfastify.post('/api/v1/notifications/email', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['to', 'subject', 'text'],\r\n      properties: {\r\n        to: { type: 'string', format: 'email' },\r\n        subject: { type: 'string', minLength: 1 },\r\n        text: { type: 'string', minLength: 1 },\r\n        html: { type: 'string' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { to, subject, text, html } = request.body;\r\n  \r\n  try {\r\n    if (!emailTransporter) {\r\n      return reply.code(503).send({\r\n        success: false,\r\n        error: 'Email service not configured'\r\n      });\r\n    }\r\n    \r\n    // Валидация email\r\n    if (!validateEmail(to)) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'Invalid email address'\r\n      });\r\n    }\r\n    \r\n    // Санитизация данных\r\n    const sanitizedSubject = sanitizeInput(subject);\r\n    const sanitizedText = sanitizeInput(text);\r\n    \r\n    // Отправка email\r\n    const info = await emailTransporter.sendMail({\r\n      from: process.env.EMAIL_FROM || 'noreply@vhm24.ru',\r\n      to,\r\n      subject: sanitizedSubject,\r\n      text: sanitizedText,\r\n      html: html || sanitizedText\r\n    });\r\n    \r\n    // Логируем отправку\r\n    await prisma.auditLog.create({\r\n      data: {\r\n        userId: request.user.id,\r\n        action: 'EMAIL_SENT',\r\n        entity: 'Notification',\r\n        entityId: info.messageId,\r\n        changes: {\r\n          to,\r\n          subject: sanitizedSubject,\r\n          channel: 'email'\r\n        },\r\n        ipAddress: request.ip\r\n      }\r\n    });\r\n    \r\n    return {\r\n      success: true,\r\n      data: {\r\n        messageId: info.messageId,\r\n        accepted: info.accepted,\r\n        rejected: info.rejected\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to send email'\r\n    });\r\n  }\r\n});\r\n\r\n// Отправить Telegram уведомление\r\nfastify.post('/api/v1/notifications/telegram', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['chatId', 'message'],\r\n      properties: {\r\n        chatId: { type: 'string' },\r\n        message: { type: 'string', minLength: 1 },\r\n        parseMode: { type: 'string', enum: ['Markdown', 'HTML'] }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { chatId, message, parseMode } = request.body;\r\n  \r\n  try {\r\n    if (!process.env.TELEGRAM_BOT_TOKEN) {\r\n      return reply.code(503).send({\r\n        success: false,\r\n        error: 'Telegram service not configured'\r\n      });\r\n    }\r\n    \r\n    // Отправка через Telegram Bot API\r\n    const response = await fetch(\r\n      `https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/sendMessage`,\r\n      {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify({\r\n          chat_id: chatId,\r\n          text: message,\r\n          parse_mode: parseMode || 'Markdown'\r\n        })\r\n      }\r\n    );\r\n    \r\n    const result = await response.json();\r\n    \r\n    if (!result.ok) {\r\n      throw new Error(result.description || 'Telegram API error');\r\n    }\r\n    \r\n    // Логируем отправку\r\n    await prisma.auditLog.create({\r\n      data: {\r\n        userId: request.user.id,\r\n        action: 'TELEGRAM_SENT',\r\n        entity: 'Notification',\r\n        entityId: result.result.message_id.toString(),\r\n        changes: {\r\n          chatId,\r\n          channel: 'telegram'\r\n        },\r\n        ipAddress: request.ip\r\n      }\r\n    });\r\n    \r\n    return {\r\n      success: true,\r\n      data: {\r\n        messageId: result.result.message_id,\r\n        chatId: result.result.chat.id\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to send Telegram message'\r\n    });\r\n  }\r\n});\r\n\r\n// Массовая рассылка уведомлений\r\nfastify.post('/api/v1/notifications/broadcast', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['channels', 'message'],\r\n      properties: {\r\n        channels: { \r\n          type: 'array', \r\n          items: { \r\n            type: 'string', \r\n            enum: ['email', 'telegram', 'push'] \r\n          }\r\n        },\r\n        message: {\r\n          type: 'object',\r\n          required: ['subject', 'text'],\r\n          properties: {\r\n            subject: { type: 'string' },\r\n            text: { type: 'string' },\r\n            html: { type: 'string' }\r\n          }\r\n        },\r\n        filters: {\r\n          type: 'object',\r\n          properties: {\r\n            roles: { \r\n              type: 'array', \r\n              items: { type: 'string' }\r\n            },\r\n            isActive: { type: 'boolean' }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { channels, message, filters } = request.body;\r\n  \r\n  try {\r\n    // Проверяем права доступа - только ADMIN может делать массовую рассылку\r\n    if (!request.user.roles.includes('ADMIN')) {\r\n      return reply.code(403).send({\r\n        success: false,\r\n        error: 'Only administrators can send broadcast notifications'\r\n      });\r\n    }\r\n    \r\n    // Получаем пользователей по фильтрам\r\n    const where = {};\r\n    if (filters?.roles) {\r\n      where.roles = { hasSome: filters.roles };\r\n    }\r\n    if (filters?.isActive !== undefined) {\r\n      where.isActive = filters.isActive;\r\n    }\r\n    \r\n    const users = await prisma.user.findMany({\r\n      where,\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        telegramId: true,\r\n        name: true\r\n      }\r\n    });\r\n    \r\n    const results = {\r\n      total: users.length,\r\n      sent: 0,\r\n      failed: 0,\r\n      channels: {}\r\n    };\r\n    \r\n    // Отправляем уведомления по каналам\r\n    for (const channel of channels) {\r\n      results.channels[channel] = { sent: 0, failed: 0 };\r\n      \r\n      for (const user of users) {\r\n        try {\r\n          switch (channel) {\r\n            case 'email':\r\n              if (user.email && emailTransporter) {\r\n                await emailTransporter.sendMail({\r\n                  from: process.env.EMAIL_FROM || 'noreply@vhm24.ru',\r\n                  to: user.email,\r\n                  subject: message.subject,\r\n                  text: message.text,\r\n                  html: message.html || message.text\r\n                });\r\n                results.channels[channel].sent++;\r\n                results.sent++;\r\n              }\r\n              break;\r\n              \r\n            case 'telegram':\r\n              if (user.telegramId && process.env.TELEGRAM_BOT_TOKEN) {\r\n                const response = await fetch(\r\n                  `https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/sendMessage`,\r\n                  {\r\n                    method: 'POST',\r\n                    headers: {\r\n                      'Content-Type': 'application/json'\r\n                    },\r\n                    body: JSON.stringify({\r\n                      chat_id: user.telegramId,\r\n                      text: `*${message.subject}*\\n\\n${message.text}`,\r\n                      parse_mode: 'Markdown'\r\n                    })\r\n                  }\r\n                );\r\n                \r\n                const result = await response.json();\r\n                if (result.ok) {\r\n                  results.channels[channel].sent++;\r\n                  results.sent++;\r\n                } else {\r\n                  results.channels[channel].failed++;\r\n                  results.failed++;\r\n                }\r\n              }\r\n              break;\r\n          }\r\n        } catch (error) {\r\n          fastify.log.error(`Failed to send ${channel} to user ${user.id}:`, error);\r\n          results.channels[channel].failed++;\r\n          results.failed++;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Логируем массовую рассылку\r\n    await prisma.auditLog.create({\r\n      data: {\r\n        userId: request.user.id,\r\n        action: 'BROADCAST_SENT',\r\n        entity: 'Notification',\r\n        entityId: 'broadcast',\r\n        changes: {\r\n          channels,\r\n          filters,\r\n          results\r\n        },\r\n        ipAddress: request.ip\r\n      }\r\n    });\r\n    \r\n    return {\r\n      success: true,\r\n      data: results\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to send broadcast'\r\n    });\r\n  }\r\n});\r\n\r\n// Отправить уведомление через NotificationService\r\nfastify.post('/api/v1/notifications/send', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['type', 'recipients', 'data'],\r\n      properties: {\r\n        type: { \r\n          type: 'string',\r\n          enum: [\r\n            'TASK_OVERDUE', 'LOW_STOCK', 'MACHINE_OFFLINE', 'ROUTE_COMPLETED',\r\n            'MAINTENANCE_DUE', 'INCOMPLETE_DATA', 'SYSTEM_ALERT', 'FUEL_REPORT',\r\n            'ARRIVAL_CONFIRMATION', 'WAREHOUSE_RECEIPT'\r\n          ]\r\n        },\r\n        recipients: {\r\n          oneOf: [\r\n            { type: 'string' },\r\n            { type: 'array', items: { type: 'string' } }\r\n          ]\r\n        },\r\n        data: { type: 'object' },\r\n        options: {\r\n          type: 'object',\r\n          properties: {\r\n            channels: {\r\n              type: 'array',\r\n              items: { type: 'string', enum: ['telegram', 'email', 'sms'] }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { type, recipients, data, options } = request.body;\r\n  \r\n  try {\r\n    const result = await notificationService.sendNotification(type, recipients, data, options);\r\n    \r\n    return {\r\n      success: true,\r\n      data: result\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error('Send notification error:', error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: error.message || 'Failed to send notification'\r\n    });\r\n  }\r\n});\r\n\r\n// Запустить проверку запланированных уведомлений\r\nfastify.post('/api/v1/notifications/check-scheduled', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    // Проверяем права доступа - только ADMIN или SYSTEM\r\n    if (!request.user.roles.includes('ADMIN') && !request.user.roles.includes('SYSTEM')) {\r\n      return reply.code(403).send({\r\n        success: false,\r\n        error: 'Only administrators can trigger scheduled notifications check'\r\n      });\r\n    }\r\n    \r\n    await notificationService.sendScheduledNotifications();\r\n    \r\n    return {\r\n      success: true,\r\n      message: 'Scheduled notifications check completed'\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error('Scheduled notifications error:', error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to check scheduled notifications'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить статистику уведомлений\r\nfastify.get('/api/v1/notifications/stats', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    querystring: {\r\n      type: 'object',\r\n      properties: {\r\n        period: { type: 'string', enum: ['7d', '30d', '1y'], default: '7d' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { period } = request.query;\r\n  \r\n  try {\r\n    const stats = await notificationService.getNotificationStats(period);\r\n    \r\n    return {\r\n      success: true,\r\n      data: stats\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error('Get notification stats error:', error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to get notification statistics'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить историю уведомлений\r\nfastify.get('/api/v1/notifications/history', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    querystring: {\r\n      type: 'object',\r\n      properties: {\r\n        channel: { type: 'string', enum: ['email', 'telegram', 'push'] },\r\n        from: { type: 'string', format: 'date-time' },\r\n        to: { type: 'string', format: 'date-time' },\r\n        skip: { type: 'integer', minimum: 0, default: 0 },\r\n        take: { type: 'integer', minimum: 1, maximum: 100, default: 20 }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { channel, from, to, skip, take } = request.query;\r\n  \r\n  try {\r\n    const where = {\r\n      action: { in: ['EMAIL_SENT', 'TELEGRAM_SENT', 'BROADCAST_SENT'] }\r\n    };\r\n    \r\n    // Фильтр по пользователю (не-админы видят только свои)\r\n    if (!request.user.roles.includes('ADMIN')) {\r\n      where.userId = request.user.id;\r\n    }\r\n    \r\n    // Фильтр по каналу\r\n    if (channel) {\r\n      where.changes = {\r\n        path: ['channel'],\r\n        equals: channel\r\n      };\r\n    }\r\n    \r\n    // Фильтр по времени\r\n    if (from || to) {\r\n      where.createdAt = {};\r\n      if (from) where.createdAt.gte = new Date(from);\r\n      if (to) where.createdAt.lte = new Date(to);\r\n    }\r\n    \r\n    const [notifications, total] = await Promise.all([\r\n      prisma.auditLog.findMany({\r\n        where,\r\n        skip,\r\n        take,\r\n        orderBy: { createdAt: 'desc' },\r\n        include: {\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true\r\n            }\r\n          }\r\n        }\r\n      }),\r\n      prisma.auditLog.count({ where })\r\n    ]);\r\n    \r\n    return {\r\n      success: true,\r\n      data: {\r\n        items: notifications,\r\n        total,\r\n        skip,\r\n        take\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch notification history'\r\n    });\r\n  }\r\n});\r\n\r\n// Start server\r\nconst start = async () => {\r\n  try {\r\n    await fastify.listen({ \r\n      port: process.env.NOTIFICATIONS_PORT || 3006,\r\n      host: '0.0.0.0'\r\n    });\r\n    console.log('VHM24 Notifications Service running 24/7 on port', process.env.NOTIFICATIONS_PORT || 3006);\r\n  } catch (err) {\r\n    fastify.log.error(err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\nstart();\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGTERM', async () => {\r\n  await fastify.close();\r\n  await prisma.$disconnect();\r\n  process.exit(0);\r\n});\r\n",
  "services/tasks/src/index.js": "require('dotenv').config({ path: require('path').join(__dirname, '../../../.env') });\r\nconst Fastify = require('fastify');\r\nconst cors = require('@fastify/cors');\r\nconst jwt = require('@fastify/jwt');\r\nconst { getTasksClient } = require('@vhm24/database');\r\nconst { TaskStatus } = require('@prisma/client');\r\nconst scheduledTasks = require('./scheduledTasks');\r\n\r\nconst prisma = getTasksClient();\r\nconst fastify = Fastify({ logger: true });\r\n\r\n// Plugins\r\nfastify.register(cors, {\r\n  origin: true,\r\n  credentials: true\r\n});\r\n\r\nfastify.register(jwt, {\r\n  secret: process.env.JWT_SECRET || 'your-secret-key'\r\n});\r\n\r\n// Декоратор для проверки авторизации\r\nfastify.decorate('authenticate', async function(request, reply) {\r\n  try {\r\n    await request.jwtVerify();\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: request.user.id },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        roles: true,\r\n        isActive: true\r\n      }\r\n    });\r\n    \r\n    if (!user || !user.isActive) {\r\n      throw new Error('User not found or inactive');\r\n    }\r\n    \r\n    request.user = user;\r\n  } catch (err) {\r\n    reply.code(401).send({ \r\n      success: false,\r\n      error: 'Unauthorized',\r\n      message: err.message || 'Invalid or expired token'\r\n    });\r\n  }\r\n});\r\n\r\n// Health check\r\nfastify.get('/health', async (request, reply) => {\r\n  return { status: 'ok', service: 'tasks' };\r\n});\r\n\r\n// Получить все задачи с фильтрами\r\nfastify.get('/api/v1/tasks', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    querystring: {\r\n      type: 'object',\r\n      properties: {\r\n        status: { type: 'string', enum: ['CREATED', 'ASSIGNED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'] },\r\n        assignedToId: { type: 'string' },\r\n        machineId: { type: 'string' },\r\n        skip: { type: 'integer', minimum: 0, default: 0 },\r\n        take: { type: 'integer', minimum: 1, maximum: 100, default: 20 },\r\n        orderBy: { type: 'string', enum: ['createdAt', 'updatedAt', 'priority'], default: 'createdAt' },\r\n        order: { type: 'string', enum: ['asc', 'desc'], default: 'desc' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { status, assignedToId, machineId, skip, take, orderBy, order } = request.query;\r\n  \r\n  try {\r\n    const where = {};\r\n    if (status) where.status = status;\r\n    if (assignedToId) where.assignedToId = assignedToId;\r\n    if (machineId) where.machineId = machineId;\r\n\r\n    const [tasks, total] = await Promise.all([\r\n      prisma.task.findMany({\r\n        where,\r\n        skip,\r\n        take,\r\n        orderBy: { [orderBy]: order },\r\n        include: {\r\n          machine: {\r\n            select: {\r\n              id: true,\r\n              code: true,\r\n              name: true,\r\n              location: true\r\n            }\r\n          },\r\n          assignedTo: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true\r\n            }\r\n          },\r\n          createdBy: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true\r\n            }\r\n          }\r\n        }\r\n      }),\r\n      prisma.task.count({ where })\r\n    ]);\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        items: tasks,\r\n        total,\r\n        skip,\r\n        take\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch tasks'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить задачу по ID\r\nfastify.get('/api/v1/tasks/:id', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    params: {\r\n      type: 'object',\r\n      properties: {\r\n        id: { type: 'string' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { id } = request.params;\r\n  \r\n  try {\r\n    const task = await prisma.task.findUnique({\r\n      where: { id },\r\n      include: {\r\n        machine: true,\r\n        assignedTo: true,\r\n        createdBy: true,\r\n        actions: {\r\n          orderBy: { createdAt: 'desc' },\r\n          include: {\r\n            user: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                email: true\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (!task) {\r\n      return reply.code(404).send({\r\n        success: false,\r\n        error: 'Task not found'\r\n      });\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      data: task\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch task'\r\n    });\r\n  }\r\n});\r\n\r\n// Создать новую задачу\r\nfastify.post('/api/v1/tasks', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['title', 'machineId', 'priority'],\r\n      properties: {\r\n        title: { type: 'string', minLength: 1 },\r\n        description: { type: 'string' },\r\n        machineId: { type: 'string' },\r\n        assignedToId: { type: 'string' },\r\n        priority: { type: 'string', enum: ['LOW', 'MEDIUM', 'HIGH', 'URGENT'] },\r\n        dueDate: { type: 'string', format: 'date-time' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { title, description, machineId, assignedToId, priority, dueDate } = request.body;\r\n  const userId = request.user.id;\r\n  \r\n  try {\r\n    // Проверяем существование машины\r\n    const machine = await prisma.machine.findUnique({\r\n      where: { id: machineId }\r\n    });\r\n\r\n    if (!machine) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'Machine not found'\r\n      });\r\n    }\r\n\r\n    // Создаем задачу\r\n    const task = await prisma.task.create({\r\n      data: {\r\n        title,\r\n        description: description || '',\r\n        machineId,\r\n        assignedToId,\r\n        createdById: userId,\r\n        status: assignedToId ? 'ASSIGNED' : 'CREATED',\r\n        priority: priority || 'MEDIUM',\r\n        dueDate: dueDate ? new Date(dueDate) : null\r\n      },\r\n      include: {\r\n        machine: true,\r\n        assignedTo: true,\r\n        createdBy: true\r\n      }\r\n    });\r\n\r\n    // Добавляем запись в историю действий\r\n    await prisma.taskAction.create({\r\n      data: {\r\n        taskId: task.id,\r\n        userId,\r\n        action: 'CREATED',\r\n        comment: `Task created: ${title}`\r\n      }\r\n    });\r\n\r\n    // TODO: Отправить уведомление назначенному пользователю\r\n\r\n    return {\r\n      success: true,\r\n      data: task\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to create task'\r\n    });\r\n  }\r\n});\r\n\r\n// Обновить задачу\r\nfastify.patch('/api/v1/tasks/:id', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    params: {\r\n      type: 'object',\r\n      properties: {\r\n        id: { type: 'string' }\r\n      }\r\n    },\r\n    body: {\r\n      type: 'object',\r\n      properties: {\r\n        title: { type: 'string', minLength: 1 },\r\n        description: { type: 'string' },\r\n        status: { type: 'string', enum: ['CREATED', 'ASSIGNED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'] },\r\n        assignedToId: { type: 'string' },\r\n        priority: { type: 'string', enum: ['LOW', 'MEDIUM', 'HIGH', 'URGENT'] },\r\n        dueDate: { type: 'string', format: 'date-time' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { id } = request.params;\r\n  const updates = request.body;\r\n  const userId = request.user.id;\r\n  \r\n  try {\r\n    // Проверяем существование задачи\r\n    const existingTask = await prisma.task.findUnique({\r\n      where: { id }\r\n    });\r\n\r\n    if (!existingTask) {\r\n      return reply.code(404).send({\r\n        success: false,\r\n        error: 'Task not found'\r\n      });\r\n    }\r\n\r\n    // Обновляем задачу\r\n    const task = await prisma.task.update({\r\n      where: { id },\r\n      data: {\r\n        ...updates,\r\n        dueDate: updates.dueDate ? new Date(updates.dueDate) : undefined,\r\n        updatedAt: new Date()\r\n      },\r\n      include: {\r\n        machine: true,\r\n        assignedTo: true,\r\n        createdBy: true\r\n      }\r\n    });\r\n\r\n    // Логируем изменения\r\n    const changes = [];\r\n    for (const [key, value] of Object.entries(updates)) {\r\n      if (existingTask[key] !== value) {\r\n        changes.push(`${key}: ${existingTask[key]} → ${value}`);\r\n      }\r\n    }\r\n\r\n    if (changes.length > 0) {\r\n      await prisma.taskAction.create({\r\n        data: {\r\n          taskId: task.id,\r\n          userId,\r\n          action: 'UPDATED',\r\n          comment: `Updated: ${changes.join(', ')}`\r\n        }\r\n      });\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      data: task\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to update task'\r\n    });\r\n  }\r\n});\r\n\r\n// Добавить действие к задаче\r\nfastify.post('/api/v1/tasks/:id/actions', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    params: {\r\n      type: 'object',\r\n      properties: {\r\n        id: { type: 'string' }\r\n      }\r\n    },\r\n    body: {\r\n      type: 'object',\r\n      required: ['action', 'comment'],\r\n      properties: {\r\n        action: { type: 'string', enum: ['COMMENT', 'STATUS_CHANGE', 'ASSIGNED', 'STARTED', 'COMPLETED', 'CANCELLED'] },\r\n        comment: { type: 'string', minLength: 1 },\r\n        location: {\r\n          type: 'object',\r\n          properties: {\r\n            latitude: { type: 'number' },\r\n            longitude: { type: 'number' }\r\n          }\r\n        },\r\n        photoUrls: { type: 'array', items: { type: 'string' } }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { id } = request.params;\r\n  const { action, comment, location, photoUrls } = request.body;\r\n  const userId = request.user.id;\r\n  \r\n  try {\r\n    // Проверяем существование задачи\r\n    const task = await prisma.task.findUnique({\r\n      where: { id }\r\n    });\r\n\r\n    if (!task) {\r\n      return reply.code(404).send({\r\n        success: false,\r\n        error: 'Task not found'\r\n      });\r\n    }\r\n\r\n    // Создаем действие\r\n    const taskAction = await prisma.taskAction.create({\r\n      data: {\r\n        taskId: id,\r\n        userId,\r\n        action,\r\n        comment,\r\n        location: location ? `${location.latitude},${location.longitude}` : null,\r\n        photoUrls: photoUrls || []\r\n      },\r\n      include: {\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            email: true\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    // Обновляем статус задачи при необходимости\r\n    if (action === 'STARTED' && task.status !== 'IN_PROGRESS') {\r\n      await prisma.task.update({\r\n        where: { id },\r\n        data: { status: 'IN_PROGRESS' }\r\n      });\r\n    } else if (action === 'COMPLETED' && task.status !== 'COMPLETED') {\r\n      await prisma.task.update({\r\n        where: { id },\r\n        data: { \r\n          status: 'COMPLETED',\r\n          completedAt: new Date()\r\n        }\r\n      });\r\n    } else if (action === 'CANCELLED' && task.status !== 'CANCELLED') {\r\n      await prisma.task.update({\r\n        where: { id },\r\n        data: { status: 'CANCELLED' }\r\n      });\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      data: taskAction\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to add action'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить статистику задач\r\nfastify.get('/api/v1/tasks/stats', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const [\r\n      totalTasks,\r\n      tasksByStatus,\r\n      tasksByPriority,\r\n      overdueTasks\r\n    ] = await Promise.all([\r\n      prisma.task.count(),\r\n      prisma.task.groupBy({\r\n        by: ['status'],\r\n        _count: true\r\n      }),\r\n      prisma.task.groupBy({\r\n        by: ['priority'],\r\n        _count: true\r\n      }),\r\n      prisma.task.count({\r\n        where: {\r\n          dueDate: { lt: new Date() },\r\n          status: { not: 'COMPLETED' }\r\n        }\r\n      })\r\n    ]);\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        total: totalTasks,\r\n        byStatus: tasksByStatus.reduce((acc, item) => {\r\n          acc[item.status] = item._count;\r\n          return acc;\r\n        }, {}),\r\n        byPriority: tasksByPriority.reduce((acc, item) => {\r\n          acc[item.priority] = item._count;\r\n          return acc;\r\n        }, {}),\r\n        overdue: overdueTasks\r\n      }\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to fetch statistics'\r\n    });\r\n  }\r\n});\r\n\r\n// API endpoints для ручного запуска задач по расписанию\r\nfastify.post('/api/v1/tasks/scheduled/inventory-check', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    description: 'Manually trigger inventory check',\r\n    tags: ['Scheduled Tasks']\r\n  }\r\n}, async (request, reply) => {\r\n  try {\r\n    // Проверяем, что пользователь - администратор\r\n    if (!request.user.roles.includes('ADMIN')) {\r\n      return reply.code(403).send({\r\n        success: false,\r\n        error: 'Only administrators can trigger scheduled tasks'\r\n      });\r\n    }\r\n\r\n    const result = await scheduledTasks.manualCheckInventory();\r\n\r\n    return {\r\n      success: result,\r\n      message: result ? 'Inventory check triggered successfully' : 'Failed to trigger inventory check'\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to trigger inventory check'\r\n    });\r\n  }\r\n});\r\n\r\nfastify.post('/api/v1/tasks/scheduled/maintenance', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    description: 'Manually trigger maintenance tasks creation',\r\n    tags: ['Scheduled Tasks']\r\n  }\r\n}, async (request, reply) => {\r\n  try {\r\n    // Проверяем, что пользователь - администратор\r\n    if (!request.user.roles.includes('ADMIN')) {\r\n      return reply.code(403).send({\r\n        success: false,\r\n        error: 'Only administrators can trigger scheduled tasks'\r\n      });\r\n    }\r\n\r\n    const result = await scheduledTasks.manualCreateMaintenanceTasks();\r\n\r\n    return {\r\n      success: result,\r\n      message: result ? 'Maintenance tasks created successfully' : 'Failed to create maintenance tasks'\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to create maintenance tasks'\r\n    });\r\n  }\r\n});\r\n\r\nfastify.post('/api/v1/tasks/scheduled/inventory', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    description: 'Manually trigger inventory tasks creation',\r\n    tags: ['Scheduled Tasks']\r\n  }\r\n}, async (request, reply) => {\r\n  try {\r\n    // Проверяем, что пользователь - администратор\r\n    if (!request.user.roles.includes('ADMIN')) {\r\n      return reply.code(403).send({\r\n        success: false,\r\n        error: 'Only administrators can trigger scheduled tasks'\r\n      });\r\n    }\r\n\r\n    const result = await scheduledTasks.manualCreateInventoryTasks();\r\n\r\n    return {\r\n      success: result,\r\n      message: result ? 'Inventory tasks created successfully' : 'Failed to create inventory tasks'\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    reply.code(500).send({\r\n      success: false,\r\n      error: 'Failed to create inventory tasks'\r\n    });\r\n  }\r\n});\r\n\r\n// Start server\r\nconst start = async () => {\r\n  try {\r\n    await fastify.listen({ \r\n      port: process.env.PORT || 3004,\r\n      host: '0.0.0.0'\r\n    });\r\n    console.log('Tasks service is running on port', process.env.PORT || 3004);\r\n    \r\n    // Инициализируем расписания задач\r\n    if (process.env.ENABLE_SCHEDULED_TASKS !== 'false') {\r\n      scheduledTasks.initScheduledTasks();\r\n      console.log('Scheduled tasks initialized');\r\n    } else {\r\n      console.log('Scheduled tasks disabled');\r\n    }\r\n  } catch (err) {\r\n    fastify.log.error(err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\nstart();\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGTERM', async () => {\r\n  await fastify.close();\r\n  await prisma.$disconnect();\r\n  process.exit(0);\r\n});\r\n",
  "update-fastify-dependencies.js": "/**\r\n * VHM24 - Update Fastify Dependencies\r\n * Обновление всех Fastify зависимостей до совместимых с версией 5.x\r\n */\r\n\r\nconst { spawn } = require('child_process');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n\r\n// Список сервисов для обновления\r\nconst services = [\r\n  'services/gateway',\r\n  'services/auth', \r\n  'services/machines',\r\n  'services/inventory',\r\n  'services/tasks',\r\n  'services/bunkers',\r\n  'services/notifications',\r\n  'services/backup',\r\n  'services/monitoring'\r\n];\r\n\r\n// Зависимости для обновления\r\nconst dependencies = [\r\n  '@fastify/helmet@^12.0.0',\r\n  '@fastify/cors@^10.0.0', \r\n  '@fastify/rate-limit@^10.0.0',\r\n  '@fastify/jwt@^9.0.0',\r\n  '@fastify/multipart@^9.0.0',\r\n  '@fastify/http-proxy@^11.0.0',\r\n  '@fastify/websocket@^11.0.0',\r\n  '@fastify/static@^8.0.0'\r\n];\r\n\r\nfunction log(message, type = 'info') {\r\n  const timestamp = new Date().toISOString();\r\n  const colors = {\r\n    info: '\\x1b[36m',\r\n    success: '\\x1b[32m',\r\n    warning: '\\x1b[33m',\r\n    error: '\\x1b[31m',\r\n    reset: '\\x1b[0m'\r\n  };\r\n  \r\n  console.log(`${colors[type]}[${timestamp}] ${message}${colors.reset}`);\r\n}\r\n\r\nasync function updateService(servicePath) {\r\n  return new Promise((resolve, reject) => {\r\n    const fullPath = path.join(__dirname, servicePath);\r\n    \r\n    // Проверяем существование package.json\r\n    const packageJsonPath = path.join(fullPath, 'package.json');\r\n    if (!fs.existsSync(packageJsonPath)) {\r\n      log(`⚠️  Skipping ${servicePath} - no package.json found`, 'warning');\r\n      resolve(false);\r\n      return;\r\n    }\r\n\r\n    log(`🔄 Updating dependencies for ${servicePath}...`, 'info');\r\n\r\n    const installProcess = spawn('npm', ['install', ...dependencies], {\r\n      cwd: fullPath,\r\n      stdio: ['pipe', 'pipe', 'pipe']\r\n    });\r\n\r\n    let output = '';\r\n    let errorOutput = '';\r\n\r\n    installProcess.stdout.on('data', (data) => {\r\n      output += data.toString();\r\n    });\r\n\r\n    installProcess.stderr.on('data', (data) => {\r\n      errorOutput += data.toString();\r\n    });\r\n\r\n    installProcess.on('close', (code) => {\r\n      if (code === 0) {\r\n        log(`✅ Successfully updated ${servicePath}`, 'success');\r\n        resolve(true);\r\n      } else {\r\n        log(`❌ Failed to update ${servicePath}: ${errorOutput}`, 'error');\r\n        resolve(false);\r\n      }\r\n    });\r\n\r\n    installProcess.on('error', (error) => {\r\n      log(`❌ Error updating ${servicePath}: ${error.message}`, 'error');\r\n      resolve(false);\r\n    });\r\n  });\r\n}\r\n\r\nasync function updateAllServices() {\r\n  log('🚀 Starting Fastify dependencies update...', 'info');\r\n  log('=' .repeat(60), 'info');\r\n\r\n  const results = [];\r\n  \r\n  for (const service of services) {\r\n    const result = await updateService(service);\r\n    results.push({ service, success: result });\r\n    \r\n    // Небольшая пауза между обновлениями\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n  }\r\n\r\n  // Показываем результаты\r\n  log('\\n📊 Update Results:', 'info');\r\n  log('=' .repeat(60), 'info');\r\n  \r\n  let successCount = 0;\r\n  results.forEach(result => {\r\n    if (result.success) {\r\n      log(`✅ ${result.service} - Updated`, 'success');\r\n      successCount++;\r\n    } else {\r\n      log(`❌ ${result.service} - Failed`, 'error');\r\n    }\r\n  });\r\n\r\n  log(`\\n🎯 Summary: ${successCount}/${services.length} services updated`, \r\n      successCount === services.length ? 'success' : 'warning');\r\n\r\n  if (successCount > 0) {\r\n    log('\\n💡 Next steps:', 'info');\r\n    log('1. Restart services: node start-all-services.js', 'info');\r\n    log('2. Test system: node test-system-comprehensive.js', 'info');\r\n    log('3. Start web dashboard: node start-dashboard.js', 'info');\r\n  }\r\n\r\n  return successCount;\r\n}\r\n\r\n// Запускаем обновление\r\nif (require.main === module) {\r\n  updateAllServices().catch(error => {\r\n    log(`❌ Failed to update services: ${error.message}`, 'error');\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nmodule.exports = { updateAllServices };\r\n",
  "update-fastify.js": "/**\r\n * VHM24 - Update Fastify Dependencies\r\n * \r\n * Этот скрипт обновляет fastify и его плагины во всех сервисах\r\n * для обеспечения совместимости версий\r\n */\r\n\r\nconst { execSync } = require('child_process');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n// Список сервисов\r\nconst services = [\r\n  'auth',\r\n  'machines',\r\n  'inventory',\r\n  'tasks',\r\n  'bunkers',\r\n  'gateway'\r\n];\r\n\r\n// Зависимости для обновления\r\nconst dependencies = [\r\n  'fastify@5.x',\r\n  '@fastify/jwt@latest',\r\n  '@fastify/cors@latest',\r\n  '@fastify/helmet@latest',\r\n  '@fastify/rate-limit@latest',\r\n  '@fastify/swagger@latest'\r\n];\r\n\r\nconsole.log('🔄 Обновление зависимостей Fastify для всех сервисов...\\n');\r\n\r\n// Обновляем зависимости для каждого сервиса\r\nservices.forEach(service => {\r\n  const servicePath = path.join(__dirname, 'services', service);\r\n  \r\n  // Проверяем существование директории сервиса\r\n  if (!fs.existsSync(servicePath)) {\r\n    console.log(`⚠️ Сервис ${service} не найден, пропускаем...`);\r\n    return;\r\n  }\r\n  \r\n  // Проверяем наличие package.json\r\n  const packageJsonPath = path.join(servicePath, 'package.json');\r\n  if (!fs.existsSync(packageJsonPath)) {\r\n    console.log(`⚠️ package.json для сервиса ${service} не найден, пропускаем...`);\r\n    return;\r\n  }\r\n  \r\n  console.log(`\\n📦 Обновление зависимостей для сервиса ${service}...`);\r\n  \r\n  try {\r\n    // Устанавливаем зависимости\r\n    const command = `cd ${servicePath} && npm install ${dependencies.join(' ')} --save`;\r\n    execSync(command, { stdio: 'inherit' });\r\n    console.log(`✅ Зависимости для сервиса ${service} успешно обновлены`);\r\n  } catch (error) {\r\n    console.error(`❌ Ошибка при обновлении зависимостей для сервиса ${service}:`, error.message);\r\n  }\r\n});\r\n\r\nconsole.log('\\n✅ Обновление зависимостей завершено!');\r\n",
  "apps/web-dashboard/next.config.js": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  env: {\r\n    NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000',\r\n  },\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/api/:path*',\r\n        destination: `${process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000'}/api/:path*`,\r\n      },\r\n    ];\r\n  },\r\n  // Отключаем строгий режим для совместимости с некоторыми библиотеками\r\n  reactStrictMode: false,\r\n  \r\n  // Настройки для production\r\n  swcMinify: true,\r\n  \r\n  // Настройки изображений\r\n  images: {\r\n    domains: ['localhost'],\r\n  },\r\n  \r\n  // Экспериментальные функции\r\n  experimental: {\r\n    appDir: true,\r\n  },\r\n};\r\n\r\nmodule.exports = nextConfig;\r\n",
  "packages/shared/middleware/index.js": "/**\r\n * VHM24 Shared Middleware\r\n * Экспорт всех middleware для использования в сервисах\r\n */\r\n\r\nconst security = require('./security');\r\nconst validation = require('./validation');\r\nconst errorHandler = require('./errorHandler');\r\n\r\nmodule.exports = {\r\n  // Security middleware\r\n  ...security,\r\n  \r\n  // Validation middleware\r\n  ...validation,\r\n  \r\n  // Error handling middleware\r\n  ...errorHandler,\r\n  \r\n  // Удобные алиасы\r\n  auth: security.authenticate,\r\n  authorize: security.authorize,\r\n  validate: {\r\n    body: validation.validateBody,\r\n    query: validation.validateQuery,\r\n    params: validation.validateParams,\r\n    id: validation.validateId,\r\n    file: validation.validateFile\r\n  },\r\n  errors: {\r\n    handler: errorHandler.errorHandler,\r\n    async: errorHandler.asyncHandler,\r\n    create: errorHandler.createError,\r\n    register: errorHandler.registerErrorHandlers,\r\n    setupGlobal: errorHandler.setupGlobalErrorHandlers\r\n  }\r\n};\r\n",
  "packages/shared/middleware/railway.js": "// Railway-specific middleware\nconst railwayMiddleware = (fastify, options, done) => {\n  // Добавляем Railway health check headers\n  fastify.addHook('onRequest', async (request, reply) => {\n    if (request.url === '/health') {\n      reply.header('X-Railway-Health', 'ok');\n    }\n  });\n  \n  // Обработка Railway внутренних запросов\n  fastify.addHook('preHandler', async (request, reply) => {\n    // Добавляем Railway request ID если есть\n    if (request.headers['x-railway-request-id']) {\n      request.railwayRequestId = request.headers['x-railway-request-id'];\n    }\n  });\n  \n  // Graceful shutdown для Railway\n  const gracefulShutdown = () => {\n    console.log('🛑 Received shutdown signal, closing server gracefully...');\n    fastify.close(() => {\n      console.log('✅ Server closed successfully');\n      process.exit(0);\n    });\n  };\n  \n  process.on('SIGTERM', gracefulShutdown);\n  process.on('SIGINT', gracefulShutdown);\n  \n  done();\n};\n\nmodule.exports = railwayMiddleware;",
  "packages/shared/utils/pagination.js": "/**\r\n * VHM24 Pagination Utility\r\n * Утилиты для пагинации данных\r\n */\r\n\r\n/**\r\n * Создание параметров пагинации для Prisma\r\n */\r\nconst createPaginationParams = (page = 1, limit = 20) => {\r\n  const pageNum = Math.max(1, parseInt(page, 10));\r\n  const limitNum = Math.min(100, Math.max(1, parseInt(limit, 10))); // Максимум 100 записей\r\n  \r\n  const skip = (pageNum - 1) * limitNum;\r\n  \r\n  return {\r\n    skip,\r\n    take: limitNum,\r\n    page: pageNum,\r\n    limit: limitNum\r\n  };\r\n};\r\n\r\n/**\r\n * Создание метаданных пагинации\r\n */\r\nconst createPaginationMeta = (totalCount, page, limit) => {\r\n  const totalPages = Math.ceil(totalCount / limit);\r\n  const hasNextPage = page < totalPages;\r\n  const hasPrevPage = page > 1;\r\n  \r\n  return {\r\n    currentPage: page,\r\n    totalPages,\r\n    totalCount,\r\n    limit,\r\n    hasNextPage,\r\n    hasPrevPage,\r\n    nextPage: hasNextPage ? page + 1 : null,\r\n    prevPage: hasPrevPage ? page - 1 : null\r\n  };\r\n};\r\n\r\n/**\r\n * Создание полного ответа с пагинацией\r\n */\r\nconst createPaginatedResponse = (data, totalCount, page, limit, additionalMeta = {}) => {\r\n  const meta = createPaginationMeta(totalCount, page, limit);\r\n  \r\n  return {\r\n    data,\r\n    meta: {\r\n      ...meta,\r\n      ...additionalMeta\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Middleware для автоматической пагинации\r\n */\r\nconst paginationMiddleware = (defaultLimit = 20, maxLimit = 100) => {\r\n  return async (request, reply) => {\r\n    const page = Math.max(1, parseInt(request.query.page, 10) || 1);\r\n    const limit = Math.min(maxLimit, Math.max(1, parseInt(request.query.limit, 10) || defaultLimit));\r\n    \r\n    // Добавляем параметры пагинации в request\r\n    request.pagination = createPaginationParams(page, limit);\r\n    \r\n    // Добавляем helper функцию для создания ответа\r\n    request.createPaginatedResponse = (data, totalCount, additionalMeta = {}) => {\r\n      return createPaginatedResponse(data, totalCount, page, limit, additionalMeta);\r\n    };\r\n  };\r\n};\r\n\r\n/**\r\n * Утилита для пагинации массивов (для случаев когда нельзя использовать БД пагинацию)\r\n */\r\nconst paginateArray = (array, page = 1, limit = 20) => {\r\n  const { skip, take } = createPaginationParams(page, limit);\r\n  const totalCount = array.length;\r\n  const data = array.slice(skip, skip + take);\r\n  \r\n  return createPaginatedResponse(data, totalCount, page, limit);\r\n};\r\n\r\n/**\r\n * Создание параметров сортировки для Prisma\r\n */\r\nconst createSortParams = (sortBy, sortOrder = 'desc', allowedFields = []) => {\r\n  // Проверяем разрешенные поля для сортировки\r\n  if (sortBy && allowedFields.length > 0 && !allowedFields.includes(sortBy)) {\r\n    sortBy = allowedFields[0]; // Используем первое разрешенное поле по умолчанию\r\n  }\r\n  \r\n  if (!sortBy) {\r\n    return { createdAt: 'desc' }; // Сортировка по умолчанию\r\n  }\r\n  \r\n  const order = ['asc', 'desc'].includes(sortOrder.toLowerCase()) ? sortOrder.toLowerCase() : 'desc';\r\n  \r\n  return { [sortBy]: order };\r\n};\r\n\r\n/**\r\n * Комбинированная утилита для пагинации и сортировки\r\n */\r\nconst createQueryParams = (query = {}, allowedSortFields = []) => {\r\n  const { page, limit, sortBy, sortOrder, ...filters } = query;\r\n  \r\n  const pagination = createPaginationParams(page, limit);\r\n  const sorting = createSortParams(sortBy, sortOrder, allowedSortFields);\r\n  \r\n  return {\r\n    ...pagination,\r\n    orderBy: sorting,\r\n    filters\r\n  };\r\n};\r\n\r\n/**\r\n * Middleware для валидации параметров пагинации\r\n */\r\nconst validatePaginationParams = (maxLimit = 100) => {\r\n  return async (request, reply) => {\r\n    const { page, limit } = request.query;\r\n    \r\n    // Валидация page\r\n    if (page !== undefined) {\r\n      const pageNum = parseInt(page, 10);\r\n      if (isNaN(pageNum) || pageNum < 1) {\r\n        return reply.code(400).send({\r\n          error: 'Validation Error',\r\n          message: 'Page must be a positive integer',\r\n          statusCode: 400\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Валидация limit\r\n    if (limit !== undefined) {\r\n      const limitNum = parseInt(limit, 10);\r\n      if (isNaN(limitNum) || limitNum < 1 || limitNum > maxLimit) {\r\n        return reply.code(400).send({\r\n          error: 'Validation Error',\r\n          message: `Limit must be between 1 and ${maxLimit}`,\r\n          statusCode: 400\r\n        });\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Создание ссылок для пагинации (для REST API)\r\n */\r\nconst createPaginationLinks = (baseUrl, page, limit, totalPages) => {\r\n  const createUrl = (pageNum) => {\r\n    const url = new URL(baseUrl);\r\n    url.searchParams.set('page', pageNum.toString());\r\n    url.searchParams.set('limit', limit.toString());\r\n    return url.toString();\r\n  };\r\n  \r\n  const links = {\r\n    self: createUrl(page),\r\n    first: createUrl(1),\r\n    last: createUrl(totalPages)\r\n  };\r\n  \r\n  if (page > 1) {\r\n    links.prev = createUrl(page - 1);\r\n  }\r\n  \r\n  if (page < totalPages) {\r\n    links.next = createUrl(page + 1);\r\n  }\r\n  \r\n  return links;\r\n};\r\n\r\n/**\r\n * Cursor-based пагинация (для больших датасетов)\r\n */\r\nconst createCursorPagination = (cursor, limit = 20, direction = 'forward') => {\r\n  const limitNum = Math.min(100, Math.max(1, parseInt(limit, 10)));\r\n  \r\n  const params = {\r\n    take: direction === 'forward' ? limitNum : -limitNum\r\n  };\r\n  \r\n  if (cursor) {\r\n    params.cursor = { id: cursor };\r\n    params.skip = 1; // Пропускаем сам cursor\r\n  }\r\n  \r\n  return params;\r\n};\r\n\r\n/**\r\n * Создание ответа для cursor-based пагинации\r\n */\r\nconst createCursorResponse = (data, hasMore = false, additionalMeta = {}) => {\r\n  const response = {\r\n    data,\r\n    meta: {\r\n      hasMore,\r\n      count: data.length,\r\n      ...additionalMeta\r\n    }\r\n  };\r\n  \r\n  // Добавляем cursors если есть данные\r\n  if (data.length > 0) {\r\n    response.meta.startCursor = data[0].id;\r\n    response.meta.endCursor = data[data.length - 1].id;\r\n  }\r\n  \r\n  return response;\r\n};\r\n\r\n/**\r\n * Утилита для поиска с пагинацией\r\n */\r\nconst createSearchParams = (searchQuery, searchFields = [], page = 1, limit = 20) => {\r\n  const pagination = createPaginationParams(page, limit);\r\n  \r\n  let where = {};\r\n  \r\n  if (searchQuery && searchFields.length > 0) {\r\n    where = {\r\n      OR: searchFields.map(field => ({\r\n        [field]: {\r\n          contains: searchQuery,\r\n          mode: 'insensitive'\r\n        }\r\n      }))\r\n    };\r\n  }\r\n  \r\n  return {\r\n    ...pagination,\r\n    where\r\n  };\r\n};\r\n\r\n/**\r\n * Агрегация данных для пагинации (например, для дашбордов)\r\n */\r\nconst createAggregatedPagination = async (model, aggregateFields = [], page = 1, limit = 20, where = {}) => {\r\n  const { skip, take } = createPaginationParams(page, limit);\r\n  \r\n  // Получаем общее количество\r\n  const totalCount = await model.count({ where });\r\n  \r\n  // Получаем агрегированные данные\r\n  const aggregateData = await model.aggregate({\r\n    where,\r\n    _count: { _all: true },\r\n    ...aggregateFields.reduce((acc, field) => {\r\n      acc[`_${field.type}`] = { [field.field]: true };\r\n      return acc;\r\n    }, {})\r\n  });\r\n  \r\n  // Получаем данные с пагинацией\r\n  const data = await model.findMany({\r\n    where,\r\n    skip,\r\n    take,\r\n    orderBy: { createdAt: 'desc' }\r\n  });\r\n  \r\n  return {\r\n    data,\r\n    meta: createPaginationMeta(totalCount, page, limit),\r\n    aggregates: aggregateData\r\n  };\r\n};\r\n\r\nmodule.exports = {\r\n  // Основные функции пагинации\r\n  createPaginationParams,\r\n  createPaginationMeta,\r\n  createPaginatedResponse,\r\n  paginateArray,\r\n  \r\n  // Сортировка\r\n  createSortParams,\r\n  createQueryParams,\r\n  \r\n  // Middleware\r\n  paginationMiddleware,\r\n  validatePaginationParams,\r\n  \r\n  // REST API утилиты\r\n  createPaginationLinks,\r\n  \r\n  // Cursor-based пагинация\r\n  createCursorPagination,\r\n  createCursorResponse,\r\n  \r\n  // Поиск\r\n  createSearchParams,\r\n  \r\n  // Агрегация\r\n  createAggregatedPagination\r\n};\r\n",
  "quick-start.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Quick Start\r\n * Быстрый запуск системы VHM24\r\n */\r\n\r\nconst { spawn } = require('child_process');\r\nconst path = require('path');\r\n\r\nconsole.log('🚀 Быстрый запуск VHM24...\\n');\r\n\r\n// Сервисы для запуска\r\nconst services = [\r\n  {\r\n    name: 'Gateway',\r\n    script: 'services/gateway/src/index.js',\r\n    port: 8000,\r\n    color: '\\x1b[36m' // cyan\r\n  },\r\n  {\r\n    name: 'Auth',\r\n    script: 'services/auth/src/index.js',\r\n    port: 3001,\r\n    color: '\\x1b[32m' // green\r\n  },\r\n  {\r\n    name: 'Machines',\r\n    script: 'services/machines/src/index.js',\r\n    port: 3002,\r\n    color: '\\x1b[33m' // yellow\r\n  },\r\n  {\r\n    name: 'Notifications',\r\n    script: 'services/notifications/src/index.js',\r\n    port: 3006,\r\n    color: '\\x1b[35m' // magenta\r\n  },\r\n  {\r\n    name: 'Audit',\r\n    script: 'services/audit/src/index.js',\r\n    port: 3007,\r\n    color: '\\x1b[34m' // blue\r\n  }\r\n];\r\n\r\nconst processes = [];\r\n\r\n// Функция для запуска сервиса\r\nfunction startService(service) {\r\n  return new Promise((resolve) => {\r\n    console.log(`${service.color}🔧 Запуск ${service.name}...\\x1b[0m`);\r\n    \r\n    const childProcess = spawn('node', [service.script], {\r\n      cwd: __dirname,\r\n      stdio: 'pipe',\r\n      env: {\r\n        ...process.env,\r\n        PORT: service.port\r\n      }\r\n    });\r\n\r\n    let started = false;\r\n\r\n    childProcess.stdout.on('data', (data) => {\r\n      const output = data.toString();\r\n      console.log(`${service.color}[${service.name}]\\x1b[0m ${output.trim()}`);\r\n      \r\n      if (!started && (output.includes('listening') || output.includes('running') || output.includes('started'))) {\r\n        started = true;\r\n        console.log(`${service.color}✅ ${service.name} запущен на порту ${service.port}\\x1b[0m`);\r\n        resolve(childProcess);\r\n      }\r\n    });\r\n\r\n    childProcess.stderr.on('data', (data) => {\r\n      const output = data.toString();\r\n      if (!output.includes('ExperimentalWarning')) {\r\n        console.log(`${service.color}[${service.name} ERROR]\\x1b[0m ${output.trim()}`);\r\n      }\r\n    });\r\n\r\n    childProcess.on('close', (code) => {\r\n      console.log(`${service.color}❌ ${service.name} завершен с кодом ${code}\\x1b[0m`);\r\n    });\r\n\r\n    childProcess.on('error', (error) => {\r\n      console.log(`${service.color}💥 Ошибка запуска ${service.name}: ${error.message}\\x1b[0m`);\r\n      if (!started) {\r\n        resolve(null);\r\n      }\r\n    });\r\n\r\n    processes.push(childProcess);\r\n\r\n    // Таймаут для запуска\r\n    setTimeout(() => {\r\n      if (!started) {\r\n        console.log(`${service.color}⚠️  ${service.name} запускается медленно...\\x1b[0m`);\r\n        resolve(childProcess);\r\n      }\r\n    }, 5000);\r\n  });\r\n}\r\n\r\n// Основная функция\r\nasync function main() {\r\n  console.log('🔧 Запуск основных сервисов VHM24...\\n');\r\n\r\n  // Запускаем сервисы последовательно\r\n  for (const service of services) {\r\n    await startService(service);\r\n    // Небольшая пауза между запусками\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n  }\r\n\r\n  console.log('\\n🎉 Все сервисы запущены!');\r\n  console.log('\\n📋 Доступные endpoints:');\r\n  console.log('   🌐 API Gateway: http://localhost:8000');\r\n  console.log('   🔐 Auth Service: http://localhost:3001');\r\n  console.log('   🤖 Machines Service: http://localhost:3002');\r\n  console.log('   🔔 Notifications Service: http://localhost:3006');\r\n  console.log('   🔍 Audit Service: http://localhost:3007');\r\n  \r\n  console.log('\\n🧪 Для тестирования запустите:');\r\n  console.log('   node test-complete-system-with-notifications.js');\r\n  \r\n  console.log('\\n📊 Для веб-интерфейса запустите:');\r\n  console.log('   npm run dashboard');\r\n  \r\n  console.log('\\n⚠️  Для остановки нажмите Ctrl+C');\r\n}\r\n\r\n// Обработка сигналов завершения\r\nprocess.on('SIGINT', () => {\r\n  console.log('\\n🛑 Остановка всех сервисов...');\r\n  \r\n  processes.forEach((proc, index) => {\r\n    if (proc && !proc.killed) {\r\n      console.log(`🔴 Остановка ${services[index]?.name || 'сервиса'}...`);\r\n      proc.kill('SIGTERM');\r\n    }\r\n  });\r\n  \r\n  setTimeout(() => {\r\n    console.log('👋 Все сервисы остановлены');\r\n    process.exit(0);\r\n  }, 2000);\r\n});\r\n\r\nprocess.on('SIGTERM', () => {\r\n  console.log('\\n🛑 Получен сигнал завершения...');\r\n  process.exit(0);\r\n});\r\n\r\n// Запуск\r\nmain().catch(error => {\r\n  console.error('💥 Критическая ошибка:', error);\r\n  process.exit(1);\r\n});\r\n",
  "start-all-services-with-audit.js": "#!/usr/bin/env node\r\n\r\nconst { spawn } = require('child_process');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n\r\nconsole.log('🚀 Запуск всех сервисов VHM24 с системой аудита...\\n');\r\n\r\n// Список всех сервисов с их портами и путями\r\nconst services = [\r\n  {\r\n    name: 'Gateway',\r\n    path: 'services/gateway',\r\n    port: process.env.GATEWAY_PORT || 8000,\r\n    env: { PORT: process.env.GATEWAY_PORT || 8000 },\r\n    icon: '🌐'\r\n  },\r\n  {\r\n    name: 'Auth',\r\n    path: 'services/auth',\r\n    port: process.env.AUTH_PORT || 3001,\r\n    env: { PORT: process.env.AUTH_PORT || 3001 },\r\n    icon: '🔐'\r\n  },\r\n  {\r\n    name: 'Machines',\r\n    path: 'services/machines',\r\n    port: process.env.MACHINES_PORT || 3002,\r\n    env: { PORT: process.env.MACHINES_PORT || 3002 },\r\n    icon: '🤖'\r\n  },\r\n  {\r\n    name: 'Inventory',\r\n    path: 'services/inventory',\r\n    port: process.env.INVENTORY_PORT || 3003,\r\n    env: { PORT: process.env.INVENTORY_PORT || 3003 },\r\n    icon: '📦'\r\n  },\r\n  {\r\n    name: 'Tasks',\r\n    path: 'services/tasks',\r\n    port: process.env.TASKS_PORT || 3004,\r\n    env: { PORT: process.env.TASKS_PORT || 3004 },\r\n    icon: '✅'\r\n  },\r\n  {\r\n    name: 'Routes',\r\n    path: 'services/routes',\r\n    port: process.env.ROUTES_PORT || 3005,\r\n    env: { PORT: process.env.ROUTES_PORT || 3005 },\r\n    icon: '🛣️'\r\n  },\r\n  {\r\n    name: 'Warehouse',\r\n    path: 'services/warehouse',\r\n    port: process.env.WAREHOUSE_PORT || 3006,\r\n    env: { PORT: process.env.WAREHOUSE_PORT || 3006 },\r\n    icon: '🏭'\r\n  },\r\n  {\r\n    name: 'Recipes',\r\n    path: 'services/recipes',\r\n    port: process.env.RECIPES_PORT || 3007,\r\n    env: { PORT: process.env.RECIPES_PORT || 3007 },\r\n    icon: '📋'\r\n  },\r\n  {\r\n    name: 'Notifications',\r\n    path: 'services/notifications',\r\n    port: process.env.NOTIFICATIONS_PORT || 3008,\r\n    env: { PORT: process.env.NOTIFICATIONS_PORT || 3008 },\r\n    icon: '🔔'\r\n  },\r\n  {\r\n    name: 'Audit',\r\n    path: 'services/audit',\r\n    port: process.env.AUDIT_SERVICE_PORT || 3009,\r\n    env: { \r\n      PORT: process.env.AUDIT_SERVICE_PORT || 3009,\r\n      AUDIT_SERVICE_PORT: process.env.AUDIT_SERVICE_PORT || 3009\r\n    },\r\n    icon: '🔍'\r\n  },\r\n  {\r\n    name: 'Monitoring',\r\n    path: 'services/monitoring',\r\n    port: process.env.MONITORING_PORT || 3010,\r\n    env: { PORT: process.env.MONITORING_PORT || 3010 },\r\n    icon: '📊'\r\n  },\r\n  {\r\n    name: 'Backup',\r\n    path: 'services/backup',\r\n    port: process.env.BACKUP_PORT || 3011,\r\n    env: { PORT: process.env.BACKUP_PORT || 3011 },\r\n    icon: '💾'\r\n  },\r\n  {\r\n    name: 'Data Import',\r\n    path: 'services/data-import',\r\n    port: process.env.DATA_IMPORT_PORT || 3012,\r\n    env: { PORT: process.env.DATA_IMPORT_PORT || 3012 },\r\n    icon: '📥'\r\n  }\r\n];\r\n\r\nconst runningProcesses = [];\r\n\r\n// Функция для установки зависимостей сервиса\r\nasync function installDependencies(service) {\r\n  return new Promise((resolve, reject) => {\r\n    const servicePath = path.join(__dirname, service.path);\r\n    \r\n    if (!fs.existsSync(servicePath)) {\r\n      console.log(`⚠️  Сервис ${service.name} не найден по пути ${servicePath}`);\r\n      resolve();\r\n      return;\r\n    }\r\n\r\n    console.log(`📦 Установка зависимостей для ${service.name}...`);\r\n    \r\n    const installProcess = spawn('npm', ['install'], {\r\n      cwd: servicePath,\r\n      stdio: 'pipe',\r\n      shell: true\r\n    });\r\n\r\n    let output = '';\r\n    installProcess.stdout.on('data', (data) => {\r\n      output += data.toString();\r\n    });\r\n\r\n    installProcess.stderr.on('data', (data) => {\r\n      output += data.toString();\r\n    });\r\n\r\n    installProcess.on('close', (code) => {\r\n      if (code === 0) {\r\n        console.log(`✅ Зависимости для ${service.name} установлены`);\r\n        resolve();\r\n      } else {\r\n        console.log(`❌ Ошибка установки зависимостей для ${service.name}:`, output);\r\n        resolve(); // Продолжаем даже при ошибке\r\n      }\r\n    });\r\n\r\n    installProcess.on('error', (error) => {\r\n      console.log(`❌ Ошибка запуска установки для ${service.name}:`, error.message);\r\n      resolve();\r\n    });\r\n  });\r\n}\r\n\r\n// Функция для запуска сервиса\r\nfunction startService(service) {\r\n  return new Promise((resolve) => {\r\n    const servicePath = path.join(__dirname, service.path);\r\n    \r\n    if (!fs.existsSync(servicePath)) {\r\n      console.log(`⚠️  Пропуск ${service.name} - сервис не найден`);\r\n      resolve();\r\n      return;\r\n    }\r\n\r\n    console.log(`${service.icon} Запуск ${service.name} на порту ${service.port}...`);\r\n    \r\n    const serviceProcess = spawn('npm', ['start'], {\r\n      cwd: servicePath,\r\n      stdio: 'pipe',\r\n      shell: true,\r\n      env: {\r\n        ...process.env,\r\n        ...service.env,\r\n        NODE_ENV: process.env.NODE_ENV || 'development'\r\n      }\r\n    });\r\n\r\n    // Логирование вывода сервиса\r\n    serviceProcess.stdout.on('data', (data) => {\r\n      const output = data.toString().trim();\r\n      if (output) {\r\n        console.log(`[${service.name}] ${output}`);\r\n      }\r\n    });\r\n\r\n    serviceProcess.stderr.on('data', (data) => {\r\n      const output = data.toString().trim();\r\n      if (output && !output.includes('ExperimentalWarning')) {\r\n        console.log(`[${service.name}] ⚠️  ${output}`);\r\n      }\r\n    });\r\n\r\n    serviceProcess.on('close', (code) => {\r\n      console.log(`[${service.name}] 🛑 Сервис завершен с кодом ${code}`);\r\n      // Удаляем из списка запущенных процессов\r\n      const index = runningProcesses.indexOf(serviceProcess);\r\n      if (index > -1) {\r\n        runningProcesses.splice(index, 1);\r\n      }\r\n    });\r\n\r\n    serviceProcess.on('error', (error) => {\r\n      console.log(`[${service.name}] ❌ Ошибка запуска: ${error.message}`);\r\n    });\r\n\r\n    // Добавляем в список запущенных процессов\r\n    runningProcesses.push(serviceProcess);\r\n    \r\n    // Даем время на запуск\r\n    setTimeout(() => {\r\n      resolve();\r\n    }, 2000);\r\n  });\r\n}\r\n\r\n// Функция для проверки доступности порта\r\nfunction checkPort(port) {\r\n  return new Promise((resolve) => {\r\n    const net = require('net');\r\n    const server = net.createServer();\r\n    \r\n    server.listen(port, () => {\r\n      server.once('close', () => {\r\n        resolve(true); // Порт свободен\r\n      });\r\n      server.close();\r\n    });\r\n    \r\n    server.on('error', () => {\r\n      resolve(false); // Порт занят\r\n    });\r\n  });\r\n}\r\n\r\n// Функция для отображения статуса сервисов\r\nasync function showStatus() {\r\n  console.log('\\n📊 Статус сервисов:');\r\n  console.log('━'.repeat(50));\r\n  \r\n  for (const service of services) {\r\n    const isPortFree = await checkPort(service.port);\r\n    const status = isPortFree ? '❌ Остановлен' : '✅ Запущен';\r\n    console.log(`${service.icon} ${service.name.padEnd(15)} ${service.port.toString().padEnd(6)} ${status}`);\r\n  }\r\n  \r\n  console.log('━'.repeat(50));\r\n  console.log(`📈 Запущено сервисов: ${runningProcesses.length}/${services.length}`);\r\n}\r\n\r\n// Основная функция запуска\r\nasync function startAllServices() {\r\n  console.log('🔧 Установка зависимостей для всех сервисов...\\n');\r\n  \r\n  // Устанавливаем зависимости параллельно\r\n  const installPromises = services.map(service => installDependencies(service));\r\n  await Promise.all(installPromises);\r\n  \r\n  console.log('\\n🚀 Запуск всех сервисов...\\n');\r\n  \r\n  // Запускаем сервисы последовательно с задержкой\r\n  for (const service of services) {\r\n    await startService(service);\r\n  }\r\n  \r\n  console.log('\\n🎉 Все доступные сервисы запущены!\\n');\r\n  \r\n  // Показываем статус\r\n  await showStatus();\r\n  \r\n  console.log('\\n🌐 Основные URL:');\r\n  console.log(`   Gateway:    http://localhost:${services[0].port}`);\r\n  console.log(`   Dashboard:  http://localhost:3000 (запустите отдельно)`);\r\n  console.log(`   Audit:      http://localhost:${services.find(s => s.name === 'Audit').port}`);\r\n  console.log(`   WebSocket:  ws://localhost:${services[0].port}/ws`);\r\n  \r\n  console.log('\\n📝 Команды:');\r\n  console.log('   Ctrl+C     - Остановить все сервисы');\r\n  console.log('   npm run dashboard - Запустить веб-дашборд');\r\n  console.log('   npm run test-audit - Тестировать систему аудита');\r\n  \r\n  // Периодически показываем статус\r\n  setInterval(async () => {\r\n    await showStatus();\r\n  }, 30000); // Каждые 30 секунд\r\n}\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGINT', () => {\r\n  console.log('\\n🛑 Остановка всех сервисов...');\r\n  \r\n  runningProcesses.forEach((proc, index) => {\r\n    if (proc && !proc.killed) {\r\n      console.log(`🛑 Остановка сервиса ${services[index]?.name || index}...`);\r\n      proc.kill('SIGINT');\r\n    }\r\n  });\r\n  \r\n  setTimeout(() => {\r\n    console.log('👋 Все сервисы остановлены');\r\n    process.exit(0);\r\n  }, 3000);\r\n});\r\n\r\nprocess.on('SIGTERM', () => {\r\n  console.log('\\n🛑 Получен сигнал SIGTERM, остановка сервисов...');\r\n  runningProcesses.forEach(proc => {\r\n    if (proc && !proc.killed) {\r\n      proc.kill('SIGTERM');\r\n    }\r\n  });\r\n  process.exit(0);\r\n});\r\n\r\n// Обработка необработанных ошибок\r\nprocess.on('uncaughtException', (error) => {\r\n  console.error('💥 Необработанная ошибка:', error);\r\n});\r\n\r\nprocess.on('unhandledRejection', (reason, promise) => {\r\n  console.error('💥 Необработанное отклонение промиса:', reason);\r\n});\r\n\r\n// Запуск\r\nstartAllServices().catch((error) => {\r\n  console.error('💥 Критическая ошибка при запуске сервисов:', error);\r\n  process.exit(1);\r\n});\r\n",
  "start-all-services.js": "/**\r\n * VHM24 - Start All Services\r\n * Запуск всех микросервисов системы\r\n */\r\n\r\nconst { spawn } = require('child_process');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n\r\n// Конфигурация сервисов\r\nconst services = [\r\n  { name: 'gateway', port: 8000, path: 'services/gateway/src/index.js' },\r\n  { name: 'auth', port: 3001, path: 'services/auth/src/index.js' },\r\n  { name: 'machines', port: 3002, path: 'services/machines/src/index.js' },\r\n  { name: 'inventory', port: 3003, path: 'services/inventory/src/index.js' },\r\n  { name: 'tasks', port: 3004, path: 'services/tasks/src/index.js' },\r\n  { name: 'bunkers', port: 3005, path: 'services/bunkers/src/index.js' },\r\n  { name: 'notifications', port: 3006, path: 'services/notifications/src/index.js' },\r\n  { name: 'backup', port: 3007, path: 'services/backup/src/index.js' },\r\n  { name: 'monitoring', port: 3008, path: 'services/monitoring/src/index.js' }\r\n];\r\n\r\nconst processes = [];\r\n\r\nfunction log(message, type = 'info') {\r\n  const timestamp = new Date().toISOString();\r\n  const colors = {\r\n    info: '\\x1b[36m',\r\n    success: '\\x1b[32m',\r\n    warning: '\\x1b[33m',\r\n    error: '\\x1b[31m',\r\n    reset: '\\x1b[0m'\r\n  };\r\n  \r\n  console.log(`${colors[type]}[${timestamp}] ${message}${colors.reset}`);\r\n}\r\n\r\nfunction startService(service) {\r\n  return new Promise((resolve, reject) => {\r\n    const servicePath = path.join(__dirname, service.path);\r\n    \r\n    // Проверяем существование файла\r\n    if (!fs.existsSync(servicePath)) {\r\n      log(`❌ Service file not found: ${servicePath}`, 'error');\r\n      resolve(false);\r\n      return;\r\n    }\r\n\r\n    log(`🚀 Starting ${service.name} service on port ${service.port}...`, 'info');\r\n\r\n    const child = spawn('node', [servicePath], {\r\n      stdio: ['pipe', 'pipe', 'pipe'],\r\n      env: {\r\n        ...process.env,\r\n        PORT: service.port,\r\n        [`${service.name.toUpperCase()}_PORT`]: service.port\r\n      }\r\n    });\r\n\r\n    let started = false;\r\n    const timeout = setTimeout(() => {\r\n      if (!started) {\r\n        log(`⚠️  ${service.name} service startup timeout`, 'warning');\r\n        resolve(true); // Считаем запущенным, даже если нет подтверждения\r\n      }\r\n    }, 5000);\r\n\r\n    child.stdout.on('data', (data) => {\r\n      const output = data.toString();\r\n      if (output.includes('running') || output.includes('listening') || output.includes('started')) {\r\n        if (!started) {\r\n          started = true;\r\n          clearTimeout(timeout);\r\n          log(`✅ ${service.name} service started successfully`, 'success');\r\n          resolve(true);\r\n        }\r\n      }\r\n      // Показываем вывод сервиса с префиксом\r\n      output.split('\\n').forEach(line => {\r\n        if (line.trim()) {\r\n          console.log(`[${service.name}] ${line}`);\r\n        }\r\n      });\r\n    });\r\n\r\n    child.stderr.on('data', (data) => {\r\n      const error = data.toString();\r\n      error.split('\\n').forEach(line => {\r\n        if (line.trim()) {\r\n          console.log(`[${service.name}] ERROR: ${line}`);\r\n        }\r\n      });\r\n    });\r\n\r\n    child.on('error', (error) => {\r\n      log(`❌ Failed to start ${service.name}: ${error.message}`, 'error');\r\n      resolve(false);\r\n    });\r\n\r\n    child.on('exit', (code) => {\r\n      if (code !== 0) {\r\n        log(`❌ ${service.name} exited with code ${code}`, 'error');\r\n      }\r\n    });\r\n\r\n    processes.push({ name: service.name, process: child });\r\n  });\r\n}\r\n\r\nasync function startAllServices() {\r\n  log('🚀 Starting VHM24 Services...', 'info');\r\n  log('=' .repeat(50), 'info');\r\n\r\n  const results = [];\r\n  \r\n  // Запускаем сервисы последовательно с небольшой задержкой\r\n  for (const service of services) {\r\n    const result = await startService(service);\r\n    results.push({ name: service.name, started: result });\r\n    \r\n    // Небольшая пауза между запусками\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n  }\r\n\r\n  // Показываем результаты\r\n  log('\\n📊 Services Status:', 'info');\r\n  log('=' .repeat(50), 'info');\r\n  \r\n  let successCount = 0;\r\n  results.forEach(result => {\r\n    if (result.started) {\r\n      log(`✅ ${result.name} - Running`, 'success');\r\n      successCount++;\r\n    } else {\r\n      log(`❌ ${result.name} - Failed`, 'error');\r\n    }\r\n  });\r\n\r\n  log(`\\n🎯 Summary: ${successCount}/${services.length} services started`, \r\n      successCount === services.length ? 'success' : 'warning');\r\n\r\n  if (successCount > 0) {\r\n    log('\\n🌐 Available endpoints:', 'info');\r\n    log('• Gateway: http://localhost:8000', 'info');\r\n    log('• Health Check: http://localhost:8000/health', 'info');\r\n    log('• API: http://localhost:8000/api/v1', 'info');\r\n    \r\n    log('\\n💡 Next steps:', 'info');\r\n    log('1. Test services: node test-system-comprehensive.js', 'info');\r\n    log('2. Start web dashboard: cd apps/web-dashboard && npm run dev', 'info');\r\n    log('3. Press Ctrl+C to stop all services', 'info');\r\n  }\r\n\r\n  return successCount;\r\n}\r\n\r\n// Обработка завершения\r\nprocess.on('SIGINT', () => {\r\n  log('\\n🛑 Stopping all services...', 'warning');\r\n  \r\n  processes.forEach(({ name, process }) => {\r\n    log(`Stopping ${name}...`, 'info');\r\n    process.kill('SIGTERM');\r\n  });\r\n\r\n  setTimeout(() => {\r\n    log('All services stopped.', 'success');\r\n    process.exit(0);\r\n  }, 2000);\r\n});\r\n\r\nprocess.on('SIGTERM', () => {\r\n  processes.forEach(({ process }) => {\r\n    process.kill('SIGTERM');\r\n  });\r\n  process.exit(0);\r\n});\r\n\r\n// Запускаем сервисы\r\nif (require.main === module) {\r\n  startAllServices().catch(error => {\r\n    log(`❌ Failed to start services: ${error.message}`, 'error');\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nmodule.exports = { startAllServices, services };\r\n",
  "start-dashboard.js": "/**\r\n * VHM24 - Start Web Dashboard\r\n * Запуск веб-дашборда\r\n */\r\n\r\nconst { spawn } = require('child_process');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n\r\nfunction log(message, type = 'info') {\r\n  const timestamp = new Date().toISOString();\r\n  const colors = {\r\n    info: '\\x1b[36m',\r\n    success: '\\x1b[32m',\r\n    warning: '\\x1b[33m',\r\n    error: '\\x1b[31m',\r\n    reset: '\\x1b[0m'\r\n  };\r\n  \r\n  console.log(`${colors[type]}[${timestamp}] ${message}${colors.reset}`);\r\n}\r\n\r\nasync function startDashboard() {\r\n  const dashboardPath = path.join(__dirname, 'apps', 'web-dashboard');\r\n  \r\n  // Проверяем существование директории\r\n  if (!fs.existsSync(dashboardPath)) {\r\n    log('❌ Web dashboard directory not found', 'error');\r\n    return false;\r\n  }\r\n\r\n  // Проверяем package.json\r\n  const packageJsonPath = path.join(dashboardPath, 'package.json');\r\n  if (!fs.existsSync(packageJsonPath)) {\r\n    log('❌ package.json not found in web dashboard', 'error');\r\n    return false;\r\n  }\r\n\r\n  // Проверяем node_modules\r\n  const nodeModulesPath = path.join(dashboardPath, 'node_modules');\r\n  if (!fs.existsSync(nodeModulesPath)) {\r\n    log('⚠️  node_modules not found, installing dependencies...', 'warning');\r\n    \r\n    // Устанавливаем зависимости\r\n    const installProcess = spawn('npm', ['install'], {\r\n      cwd: dashboardPath,\r\n      stdio: 'inherit'\r\n    });\r\n\r\n    await new Promise((resolve, reject) => {\r\n      installProcess.on('close', (code) => {\r\n        if (code === 0) {\r\n          log('✅ Dependencies installed successfully', 'success');\r\n          resolve();\r\n        } else {\r\n          log('❌ Failed to install dependencies', 'error');\r\n          reject(new Error(`npm install failed with code ${code}`));\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  log('🚀 Starting web dashboard...', 'info');\r\n\r\n  // Запускаем dev сервер\r\n  const devProcess = spawn('npm', ['run', 'dev'], {\r\n    cwd: dashboardPath,\r\n    stdio: 'inherit'\r\n  });\r\n\r\n  devProcess.on('error', (error) => {\r\n    log(`❌ Failed to start dashboard: ${error.message}`, 'error');\r\n  });\r\n\r\n  // Обработка завершения\r\n  process.on('SIGINT', () => {\r\n    log('\\n🛑 Stopping dashboard...', 'warning');\r\n    devProcess.kill('SIGTERM');\r\n    process.exit(0);\r\n  });\r\n\r\n  return true;\r\n}\r\n\r\nif (require.main === module) {\r\n  startDashboard().catch(error => {\r\n    log(`❌ Failed to start dashboard: ${error.message}`, 'error');\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nmodule.exports = { startDashboard };\r\n",
  "fix-all-errors.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 - Система комплексного исправления ошибок\r\n * \r\n * Этот скрипт последовательно запускает:\r\n * 1. Анализ проекта\r\n * 2. Исправление найденных проблем\r\n * 3. Тестирование после исправлений\r\n * \r\n * Использование:\r\n * node fix-all-errors.js\r\n */\r\n\r\nconst { execSync } = require('child_process');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst readline = require('readline');\r\n\r\nconst rl = readline.createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout\r\n});\r\n\r\n// Цвета для консоли\r\nconst colors = {\r\n  reset: '\\x1b[0m',\r\n  bright: '\\x1b[1m',\r\n  red: '\\x1b[31m',\r\n  green: '\\x1b[32m',\r\n  yellow: '\\x1b[33m',\r\n  blue: '\\x1b[34m',\r\n  magenta: '\\x1b[35m',\r\n  cyan: '\\x1b[36m'\r\n};\r\n\r\n// Функция для форматированного вывода\r\nfunction log(message, color = 'reset') {\r\n  console.log(`${colors[color]}${message}${colors.reset}`);\r\n}\r\n\r\n// Функция для запроса подтверждения\r\nfunction confirm(message) {\r\n  return new Promise((resolve) => {\r\n    rl.question(`${colors.yellow}${message} (y/n): ${colors.reset}`, (answer) => {\r\n      resolve(answer.toLowerCase() === 'y');\r\n    });\r\n  });\r\n}\r\n\r\n// Функция для создания резервной копии всего проекта\r\nfunction createBackup() {\r\n  const backupDir = path.join(__dirname, 'backups', `backup-${Date.now()}`);\r\n  fs.mkdirSync(backupDir, { recursive: true });\r\n  \r\n  log('📦 Создание резервной копии проекта...', 'cyan');\r\n  \r\n  // Копируем все файлы, кроме node_modules и backups\r\n  execSync(`xcopy . \"${backupDir}\" /E /H /C /I /Y /EXCLUDE:backups,node_modules,.git`, { stdio: 'inherit' });\r\n  \r\n  log(`✅ Резервная копия создана в ${backupDir}`, 'green');\r\n  return backupDir;\r\n}\r\n\r\n// Основная функция\r\nasync function main() {\r\n  log('\\n🔧 VHM24 - СИСТЕМА КОМПЛЕКСНОГО ИСПРАВЛЕНИЯ ОШИБОК 🔧\\n', 'bright');\r\n  \r\n  // Создаем резервную копию\r\n  const backupDir = createBackup();\r\n  \r\n  // Шаг 1: Анализ проекта\r\n  log('\\n📊 ШАГ 1: АНАЛИЗ ПРОЕКТА', 'magenta');\r\n  const analyzeConfirm = await confirm('Запустить анализ проекта?');\r\n  \r\n  if (analyzeConfirm) {\r\n    try {\r\n      log('\\nЗапуск анализатора...', 'cyan');\r\n      execSync('node scripts/project-analyzer.js', { stdio: 'inherit' });\r\n      \r\n      log('\\n✅ Анализ завершен успешно!', 'green');\r\n      log('📄 Отчет сохранен в ANALYSIS_REPORT.md и analysis-report.json', 'green');\r\n      \r\n      // Показываем краткую статистику\r\n      if (fs.existsSync('analysis-report.json')) {\r\n        const report = JSON.parse(fs.readFileSync('analysis-report.json', 'utf8'));\r\n        log('\\n📊 Статистика проблем:', 'cyan');\r\n        log(`🚨 Критические: ${report.summary.critical}`, report.summary.critical > 0 ? 'red' : 'green');\r\n        log(`⚠️ Высокий приоритет: ${report.summary.high}`, report.summary.high > 0 ? 'yellow' : 'green');\r\n        log(`📝 Средний приоритет: ${report.summary.medium}`, 'cyan');\r\n        log(`ℹ️ Низкий приоритет: ${report.summary.low}`, 'blue');\r\n        log(`📈 Всего проблем: ${report.summary.total}`, 'magenta');\r\n      }\r\n    } catch (error) {\r\n      log(`\\n❌ Ошибка при анализе: ${error.message}`, 'red');\r\n      const continueAnyway = await confirm('Продолжить несмотря на ошибку?');\r\n      if (!continueAnyway) {\r\n        log('\\n🛑 Процесс остановлен пользователем.', 'yellow');\r\n        rl.close();\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Шаг 2: Исправление проблем\r\n  log('\\n🔧 ШАГ 2: ИСПРАВЛЕНИЕ ПРОБЛЕМ', 'magenta');\r\n  const fixConfirm = await confirm('Запустить автоматическое исправление проблем?');\r\n  \r\n  if (fixConfirm) {\r\n    try {\r\n      log('\\nЗапуск автоматического фиксера...', 'cyan');\r\n      execSync('node scripts/auto-fixer.js', { stdio: 'inherit' });\r\n      \r\n      log('\\n✅ Исправление завершено!', 'green');\r\n      log('📄 Отчет сохранен в fix-report.json', 'green');\r\n      \r\n      // Показываем краткую статистику\r\n      if (fs.existsSync('fix-report.json')) {\r\n        const report = JSON.parse(fs.readFileSync('fix-report.json', 'utf8'));\r\n        log('\\n📊 Статистика исправлений:', 'cyan');\r\n        log(`✅ Исправлено: ${report.summary.totalFixed}`, 'green');\r\n        log(`❌ Не удалось исправить: ${report.summary.totalFailed}`, report.summary.totalFailed > 0 ? 'red' : 'green');\r\n        log(`📈 Успешность: ${report.summary.successRate}%`, 'magenta');\r\n      }\r\n    } catch (error) {\r\n      log(`\\n❌ Ошибка при исправлении: ${error.message}`, 'red');\r\n      const continueAnyway = await confirm('Продолжить несмотря на ошибку?');\r\n      if (!continueAnyway) {\r\n        log('\\n🛑 Процесс остановлен пользователем.', 'yellow');\r\n        rl.close();\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Шаг 3: Тестирование\r\n  log('\\n🧪 ШАГ 3: ТЕСТИРОВАНИЕ', 'magenta');\r\n  const testConfirm = await confirm('Запустить тестирование после исправлений?');\r\n  \r\n  if (testConfirm) {\r\n    try {\r\n      log('\\nЗапуск тестов...', 'cyan');\r\n      execSync('node scripts/test-after-fixes.js', { stdio: 'inherit' });\r\n      \r\n      log('\\n✅ Тестирование завершено!', 'green');\r\n    } catch (error) {\r\n      log(`\\n❌ Ошибка при тестировании: ${error.message}`, 'red');\r\n      const rollbackConfirm = await confirm('Откатить все изменения?');\r\n      \r\n      if (rollbackConfirm) {\r\n        log('\\n🔄 Откат изменений...', 'yellow');\r\n        execSync(`xcopy \"${backupDir}\" . /E /H /C /I /Y`, { stdio: 'inherit' });\r\n        log('\\n✅ Изменения откачены!', 'green');\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Завершение\r\n  log('\\n🎉 ПРОЦЕСС ЗАВЕРШЕН!', 'bright');\r\n  log('📝 Проверьте результаты и при необходимости внесите ручные исправления.', 'cyan');\r\n  log('📋 Используйте VHM24_FIX_CHECKLIST.md для финальной проверки.', 'cyan');\r\n  log('🔒 Резервная копия сохранена в ' + backupDir, 'green');\r\n  \r\n  rl.close();\r\n}\r\n\r\n// Запуск основной функции\r\nmain().catch(error => {\r\n  log(`\\n❌ Критическая ошибка: ${error.message}`, 'red');\r\n  log('🔄 Рекомендуется восстановить проект из резервной копии.', 'yellow');\r\n  rl.close();\r\n});\r\n",
  "packages/shared/storage/s3.js": "// S3 Storage Adapter for Railway deployment\nconst AWS = require('aws-sdk');\nconst fs = require('fs');\nconst path = require('path');\n\nclass S3StorageAdapter {\n  constructor() {\n    this.s3 = new AWS.S3({\n      endpoint: process.env.S3_ENDPOINT || 'https://s3.amazonaws.com',\n      accessKeyId: process.env.S3_ACCESS_KEY,\n      secretAccessKey: process.env.S3_SECRET_KEY,\n      region: process.env.S3_REGION || 'us-east-1',\n      s3ForcePathStyle: true,\n      signatureVersion: 'v4'\n    });\n    \n    this.bucket = process.env.S3_BUCKET;\n    \n    if (!this.bucket) {\n      console.warn('⚠️ S3_BUCKET not configured, using local storage fallback');\n    }\n  }\n\n  async upload(key, buffer, contentType = 'application/octet-stream') {\n    if (!this.bucket) {\n      return this.localFallback('upload', key, buffer);\n    }\n    \n    try {\n      const params = {\n        Bucket: this.bucket,\n        Key: key,\n        Body: buffer,\n        ContentType: contentType,\n        ACL: 'public-read'\n      };\n      \n      const result = await this.s3.upload(params).promise();\n      return {\n        success: true,\n        url: result.Location,\n        key: result.Key\n      };\n    } catch (error) {\n      console.error('S3 upload error:', error);\n      return this.localFallback('upload', key, buffer);\n    }\n  }\n  \n  async download(key) {\n    if (!this.bucket) {\n      return this.localFallback('download', key);\n    }\n    \n    try {\n      const params = {\n        Bucket: this.bucket,\n        Key: key\n      };\n      \n      const result = await this.s3.getObject(params).promise();\n      return {\n        success: true,\n        data: result.Body,\n        contentType: result.ContentType\n      };\n    } catch (error) {\n      console.error('S3 download error:', error);\n      return this.localFallback('download', key);\n    }\n  }\n  \n  getSignedUrl(key, expires = 3600) {\n    if (!this.bucket) {\n      return `/uploads/${key}`;\n    }\n    \n    try {\n      return this.s3.getSignedUrl('getObject', {\n        Bucket: this.bucket,\n        Key: key,\n        Expires: expires\n      });\n    } catch (error) {\n      console.error('S3 signed URL error:', error);\n      return `/uploads/${key}`;\n    }\n  }\n  \n  async delete(key) {\n    if (!this.bucket) {\n      return this.localFallback('delete', key);\n    }\n    \n    try {\n      await this.s3.deleteObject({\n        Bucket: this.bucket,\n        Key: key\n      }).promise();\n      \n      return { success: true };\n    } catch (error) {\n      console.error('S3 delete error:', error);\n      return { success: false, error: error.message };\n    }\n  }\n  \n  // Локальный fallback для разработки\n  localFallback(operation, key, data) {\n    const uploadsDir = path.join(process.cwd(), 'uploads');\n    \n    if (!fs.existsSync(uploadsDir)) {\n      fs.mkdirSync(uploadsDir, { recursive: true });\n    }\n    \n    const filePath = path.join(uploadsDir, key);\n    \n    switch (operation) {\n      case 'upload':\n        fs.writeFileSync(filePath, data);\n        return {\n          success: true,\n          url: `/uploads/${key}`,\n          key: key,\n          fallback: true\n        };\n        \n      case 'download':\n        if (fs.existsSync(filePath)) {\n          return {\n            success: true,\n            data: fs.readFileSync(filePath),\n            fallback: true\n          };\n        }\n        return { success: false, error: 'File not found' };\n        \n      case 'delete':\n        if (fs.existsSync(filePath)) {\n          fs.unlinkSync(filePath);\n        }\n        return { success: true, fallback: true };\n        \n      default:\n        return { success: false, error: 'Unknown operation' };\n    }\n  }\n}\n\nmodule.exports = S3StorageAdapter;",
  "packages/shared/storage/s3Storage.js": "const AWS = require('aws-sdk');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst { v4: uuidv4 } = require('uuid');\r\n\r\n// Конфигурация S3\r\nconst s3Config = {\r\n  endpoint: process.env.S3_ENDPOINT || 'https://fra1.digitaloceanspaces.com',\r\n  accessKeyId: process.env.S3_ACCESS_KEY,\r\n  secretAccessKey: process.env.S3_SECRET_KEY,\r\n  region: process.env.S3_REGION || 'fra1',\r\n  s3ForcePathStyle: true\r\n};\r\n\r\n// Имя бакета\r\nconst bucketName = process.env.S3_BUCKET || 'vhm24-uploads';\r\n\r\n// Создаем S3 клиент\r\nconst s3 = new AWS.S3(s3Config);\r\n\r\n/**\r\n * Загрузка файла в S3\r\n * @param {string} filePath - Путь к файлу\r\n * @param {string} key - Ключ файла в S3\r\n * @param {Object} options - Дополнительные опции\r\n * @returns {Promise<string>} - URL загруженного файла\r\n */\r\nasync function uploadFile(filePath, key, options = {}) {\r\n  try {\r\n    const fileContent = fs.readFileSync(filePath);\r\n    \r\n    const params = {\r\n      Bucket: bucketName,\r\n      Key: key,\r\n      Body: fileContent,\r\n      ACL: 'public-read',\r\n      ContentType: options.contentType || 'application/octet-stream',\r\n      ...options\r\n    };\r\n    \r\n    const result = await s3.upload(params).promise();\r\n    return result.Location;\r\n  } catch (error) {\r\n    console.error('Error uploading file to S3:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Загрузка фото в S3\r\n * @param {string} filePath - Путь к файлу\r\n * @param {string} fileName - Имя файла\r\n * @returns {Promise<string>} - URL загруженного фото\r\n */\r\nasync function uploadPhoto(filePath, fileName) {\r\n  const ext = path.extname(fileName);\r\n  const key = `photos/${uuidv4()}${ext}`;\r\n  \r\n  return uploadFile(filePath, key, {\r\n    ContentType: `image/${ext.substring(1)}` // .jpg -> image/jpg\r\n  });\r\n}\r\n\r\n/**\r\n * Загрузка документа в S3\r\n * @param {string} filePath - Путь к файлу\r\n * @param {string} fileName - Имя файла\r\n * @returns {Promise<string>} - URL загруженного документа\r\n */\r\nasync function uploadDocument(filePath, fileName) {\r\n  const ext = path.extname(fileName);\r\n  const key = `documents/${uuidv4()}${ext}`;\r\n  \r\n  let contentType = 'application/octet-stream';\r\n  \r\n  // Определяем Content-Type на основе расширения\r\n  switch (ext.toLowerCase()) {\r\n    case '.pdf':\r\n      contentType = 'application/pdf';\r\n      break;\r\n    case '.doc':\r\n    case '.docx':\r\n      contentType = 'application/msword';\r\n      break;\r\n    case '.xls':\r\n    case '.xlsx':\r\n      contentType = 'application/vnd.ms-excel';\r\n      break;\r\n    case '.txt':\r\n      contentType = 'text/plain';\r\n      break;\r\n    case '.json':\r\n      contentType = 'application/json';\r\n      break;\r\n    case '.csv':\r\n      contentType = 'text/csv';\r\n      break;\r\n  }\r\n  \r\n  return uploadFile(filePath, key, { ContentType: contentType });\r\n}\r\n\r\n/**\r\n * Загрузка отчета в S3\r\n * @param {string} filePath - Путь к файлу\r\n * @param {string} fileName - Имя файла\r\n * @returns {Promise<string>} - URL загруженного отчета\r\n */\r\nasync function uploadReport(filePath, fileName) {\r\n  const ext = path.extname(fileName);\r\n  const key = `reports/${uuidv4()}${ext}`;\r\n  \r\n  return uploadFile(filePath, key);\r\n}\r\n\r\n/**\r\n * Удаление файла из S3\r\n * @param {string} fileUrl - URL файла\r\n * @returns {Promise<boolean>} - Результат удаления\r\n */\r\nasync function deleteFile(fileUrl) {\r\n  try {\r\n    // Извлекаем ключ из URL\r\n    const key = fileUrl.split(`${bucketName}/`)[1];\r\n    \r\n    const params = {\r\n      Bucket: bucketName,\r\n      Key: key\r\n    };\r\n    \r\n    await s3.deleteObject(params).promise();\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting file from S3:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Получение информации о файле\r\n * @param {string} fileUrl - URL файла\r\n * @returns {Promise<Object>} - Информация о файле\r\n */\r\nasync function getFileInfo(fileUrl) {\r\n  try {\r\n    // Извлекаем ключ из URL\r\n    const key = fileUrl.split(`${bucketName}/`)[1];\r\n    \r\n    const params = {\r\n      Bucket: bucketName,\r\n      Key: key\r\n    };\r\n    \r\n    const result = await s3.headObject(params).promise();\r\n    return {\r\n      size: result.ContentLength,\r\n      contentType: result.ContentType,\r\n      lastModified: result.LastModified\r\n    };\r\n  } catch (error) {\r\n    console.error('Error getting file info from S3:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Создание подписанного URL для временного доступа\r\n * @param {string} key - Ключ файла в S3\r\n * @param {number} expiresIn - Время жизни URL в секундах\r\n * @returns {string} - Подписанный URL\r\n */\r\nfunction getSignedUrl(key, expiresIn = 3600) {\r\n  const params = {\r\n    Bucket: bucketName,\r\n    Key: key,\r\n    Expires: expiresIn\r\n  };\r\n  \r\n  return s3.getSignedUrl('getObject', params);\r\n}\r\n\r\nmodule.exports = {\r\n  uploadFile,\r\n  uploadPhoto,\r\n  uploadDocument,\r\n  uploadReport,\r\n  deleteFile,\r\n  getFileInfo,\r\n  getSignedUrl\r\n};\r\n",
  "quick-setup.js": "#!/usr/bin/env node\r\n\r\nconst { spawn, exec } = require('child_process');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nconsole.log('🚀 VHM24 Quick Setup & Start');\r\nconsole.log('============================\\n');\r\n\r\n// Функция для выполнения команды\r\nfunction runCommand(command, description) {\r\n  return new Promise((resolve, reject) => {\r\n    console.log(`📋 ${description}...`);\r\n    \r\n    const child = exec(command, (error, stdout, stderr) => {\r\n      if (error) {\r\n        console.error(`❌ Error: ${error.message}`);\r\n        reject(error);\r\n        return;\r\n      }\r\n      \r\n      if (stderr && !stderr.includes('warning')) {\r\n        console.error(`⚠️  Warning: ${stderr}`);\r\n      }\r\n      \r\n      if (stdout) {\r\n        console.log(stdout);\r\n      }\r\n      \r\n      console.log(`✅ ${description} completed\\n`);\r\n      resolve();\r\n    });\r\n  });\r\n}\r\n\r\n// Проверка файлов\r\nfunction checkFiles() {\r\n  console.log('🔍 Checking project files...');\r\n  \r\n  const requiredFiles = [\r\n    '.env',\r\n    'package.json',\r\n    'start.js',\r\n    'packages/database/prisma/schema.prisma'\r\n  ];\r\n  \r\n  const missingFiles = requiredFiles.filter(file => !fs.existsSync(file));\r\n  \r\n  if (missingFiles.length > 0) {\r\n    console.log('❌ Missing required files:');\r\n    missingFiles.forEach(file => console.log(`   - ${file}`));\r\n    return false;\r\n  }\r\n  \r\n  console.log('✅ All required files present\\n');\r\n  return true;\r\n}\r\n\r\n// Проверка переменных окружения\r\nfunction checkEnvironment() {\r\n  console.log('🔍 Checking environment variables...');\r\n  \r\n  const envContent = fs.readFileSync('.env', 'utf8');\r\n  const hasValidTelegramToken = envContent.includes('TELEGRAM_BOT_TOKEN=') && \r\n                                !envContent.includes('your-telegram-bot-token');\r\n  \r\n  if (!hasValidTelegramToken) {\r\n    console.log('⚠️  Telegram bot token not configured properly');\r\n    console.log('   Please update TELEGRAM_BOT_TOKEN in .env file\\n');\r\n  } else {\r\n    console.log('✅ Telegram bot token configured\\n');\r\n  }\r\n  \r\n  return hasValidTelegramToken;\r\n}\r\n\r\n// Основная функция\r\nasync function main() {\r\n  try {\r\n    // Проверяем файлы\r\n    if (!checkFiles()) {\r\n      console.log('❌ Setup failed: Missing required files');\r\n      process.exit(1);\r\n    }\r\n    \r\n    // Проверяем окружение\r\n    const envOk = checkEnvironment();\r\n    \r\n    // Устанавливаем зависимости\r\n    await runCommand('npm install', 'Installing dependencies');\r\n    \r\n    // Устанавливаем зависимости для workspaces\r\n    await runCommand('npm install --workspaces --if-present', 'Installing workspace dependencies');\r\n    \r\n    // Генерируем Prisma клиент\r\n    await runCommand('cd packages/database && npx prisma generate', 'Generating Prisma client');\r\n    \r\n    console.log('🎉 Setup completed successfully!');\r\n    console.log('=====================================\\n');\r\n    \r\n    if (envOk) {\r\n      console.log('🚀 Starting VHM24 Platform...\\n');\r\n      \r\n      // Запускаем проект\r\n      const startProcess = spawn('npm', ['start'], {\r\n        stdio: 'inherit',\r\n        shell: true\r\n      });\r\n      \r\n      startProcess.on('close', (code) => {\r\n        console.log(`\\n📊 Process exited with code ${code}`);\r\n      });\r\n      \r\n      startProcess.on('error', (error) => {\r\n        console.error(`❌ Failed to start: ${error.message}`);\r\n      });\r\n      \r\n    } else {\r\n      console.log('⚠️  Please configure environment variables in .env file before starting');\r\n      console.log('   Then run: npm start');\r\n    }\r\n    \r\n  } catch (error) {\r\n    console.error(`❌ Setup failed: ${error.message}`);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Обработка сигналов\r\nprocess.on('SIGINT', () => {\r\n  console.log('\\n🛑 Setup interrupted');\r\n  process.exit(0);\r\n});\r\n\r\n// Запускаем\r\nmain();\r\n",
  "railway-readiness-check.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Railway Readiness Check\r\n * Проверяет готовность проекта к деплою на Railway\r\n */\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n// Загружаем переменные окружения\r\ntry {\r\n  require('dotenv').config();\r\n} catch (error) {\r\n  console.log('⚠️  dotenv not available, using environment variables');\r\n}\r\n\r\nconsole.log('🔍 VHM24 Railway Readiness Check');\r\nconsole.log('================================\\n');\r\n\r\nlet allChecksPass = true;\r\nconst issues = [];\r\nconst warnings = [];\r\n\r\n// Функция для проверки\r\nfunction check(name, condition, errorMsg, warningMsg = null) {\r\n  if (condition) {\r\n    console.log(`✅ ${name}`);\r\n    return true;\r\n  } else {\r\n    console.log(`❌ ${name}`);\r\n    if (warningMsg) {\r\n      warnings.push(`⚠️  ${name}: ${warningMsg}`);\r\n    } else {\r\n      issues.push(`❌ ${name}: ${errorMsg}`);\r\n      allChecksPass = false;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n// 1. Проверка файлов\r\nconsole.log('📁 File Structure Check:');\r\ncheck('package.json exists', fs.existsSync('package.json'), 'package.json not found');\r\ncheck('railway-start-final.js exists', fs.existsSync('railway-start-final.js'), 'railway-start-final.js not found');\r\ncheck('nixpacks.toml exists', fs.existsSync('nixpacks.toml'), 'nixpacks.toml not found');\r\ncheck('.railwayignore exists', fs.existsSync('.railwayignore'), '.railwayignore not found');\r\ncheck('railway.json exists', fs.existsSync('railway.json'), 'railway.json not found');\r\n\r\n// 2. Проверка Prisma\r\nconsole.log('\\n🗄️  Database Check:');\r\nconst schemaPath = 'packages/database/prisma/schema.prisma';\r\ncheck('Prisma schema exists', fs.existsSync(schemaPath), 'Prisma schema not found');\r\n\r\n// 3. Проверка переменных окружения\r\nconsole.log('\\n🔐 Environment Variables Check:');\r\n\r\n// Критические переменные\r\nconst criticalVars = [\r\n  'DATABASE_URL',\r\n  'JWT_SECRET',\r\n  'TELEGRAM_BOT_TOKEN',\r\n  'ADMIN_IDS'\r\n];\r\n\r\ncriticalVars.forEach(varName => {\r\n  const value = process.env[varName];\r\n  check(`${varName} is set`, !!value, `${varName} is required for Railway deployment`);\r\n  \r\n  // Дополнительные проверки\r\n  if (varName === 'JWT_SECRET' && value) {\r\n    check(`${varName} is secure`, value.length >= 32, `${varName} should be at least 32 characters long`);\r\n    check(`${varName} is not default`, !value.includes('change-this'), `${varName} should be changed from default value`, 'Using default JWT secret is not secure for production');\r\n  }\r\n  \r\n  if (varName === 'DATABASE_URL' && value) {\r\n    check(`${varName} is Railway PostgreSQL`, value.includes('railway') || value.includes('postgres'), `${varName} should be Railway PostgreSQL URL`);\r\n  }\r\n  \r\n  if (varName === 'TELEGRAM_BOT_TOKEN' && value) {\r\n    check(`${varName} format is valid`, value.includes(':'), `${varName} should be in format: XXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX`);\r\n  }\r\n});\r\n\r\n// Опциональные но рекомендуемые переменные\r\nconsole.log('\\n🔧 Optional Variables Check:');\r\nconst optionalVars = [\r\n  'REDIS_URL',\r\n  'NODE_ENV',\r\n  'ALLOWED_ORIGINS'\r\n];\r\n\r\noptionalVars.forEach(varName => {\r\n  const value = process.env[varName];\r\n  check(`${varName} is set`, !!value, `${varName} is recommended but not required`, `${varName} not set - using defaults`);\r\n});\r\n\r\n// 4. Проверка package.json\r\nconsole.log('\\n📦 Package.json Check:');\r\ntry {\r\n  const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));\r\n  \r\n  check('start script exists', !!packageJson.scripts?.start, 'start script not found in package.json');\r\n  check('start script points to railway-start-final.js', \r\n    packageJson.scripts?.start === 'node railway-start-final.js', \r\n    'start script should be \"node railway-start-final.js\"');\r\n  \r\n  check('Node.js version specified', !!packageJson.engines?.node, 'Node.js version not specified in engines');\r\n  check('npm version specified', !!packageJson.engines?.npm, 'npm version not specified in engines');\r\n  \r\n} catch (error) {\r\n  issues.push('❌ Failed to parse package.json');\r\n  allChecksPass = false;\r\n}\r\n\r\n// 5. Проверка nixpacks.toml\r\nconsole.log('\\n🚂 Nixpacks Configuration Check:');\r\ntry {\r\n  const nixpacksContent = fs.readFileSync('nixpacks.toml', 'utf8');\r\n  \r\n  check('nixpacks.toml has start command', nixpacksContent.includes('[start]'), 'start section not found in nixpacks.toml');\r\n  check('start command is npm start', nixpacksContent.includes('cmd = \"npm start\"'), 'start command should be \"npm start\"');\r\n  check('Node.js setup configured', nixpacksContent.includes('nodejs'), 'Node.js not configured in nixpacks.toml');\r\n  \r\n} catch (error) {\r\n  issues.push('❌ Failed to read nixpacks.toml');\r\n  allChecksPass = false;\r\n}\r\n\r\n// 6. Проверка сервисов\r\nconsole.log('\\n🚀 Services Check:');\r\nconst services = [\r\n  'services/auth/src/index.js',\r\n  'services/gateway/src/index.js',\r\n  'services/machines/src/index.js',\r\n  'services/inventory/src/index.js',\r\n  'services/tasks/src/index.js',\r\n  'services/bunkers/src/index.js',\r\n  'services/notifications/src/index.js',\r\n  'services/telegram-bot/src/index.js'\r\n];\r\n\r\nservices.forEach(servicePath => {\r\n  const serviceName = servicePath.split('/')[1];\r\n  check(`${serviceName} service exists`, fs.existsSync(servicePath), `${servicePath} not found`);\r\n});\r\n\r\n// 7. Проверка зависимостей\r\nconsole.log('\\n📚 Dependencies Check:');\r\ncheck('node_modules exists', fs.existsSync('node_modules'), 'Dependencies not installed - run npm install');\r\n\r\n// Результаты\r\nconsole.log('\\n' + '='.repeat(50));\r\nconsole.log('📊 READINESS REPORT');\r\nconsole.log('='.repeat(50));\r\n\r\nif (allChecksPass && issues.length === 0) {\r\n  console.log('🎉 ✅ ALL CHECKS PASSED!');\r\n  console.log('🚂 Project is ready for Railway deployment!');\r\n  \r\n  if (warnings.length > 0) {\r\n    console.log('\\n⚠️  Warnings (non-critical):');\r\n    warnings.forEach(warning => console.log(warning));\r\n  }\r\n  \r\n  console.log('\\n🚀 Next steps:');\r\n  console.log('1. git add .');\r\n  console.log('2. git commit -m \"Ready for Railway deployment\"');\r\n  console.log('3. git push origin main');\r\n  console.log('4. Railway will automatically deploy');\r\n  \r\n} else {\r\n  console.log('❌ DEPLOYMENT NOT READY');\r\n  console.log('\\n🔧 Issues to fix:');\r\n  issues.forEach(issue => console.log(issue));\r\n  \r\n  if (warnings.length > 0) {\r\n    console.log('\\n⚠️  Warnings:');\r\n    warnings.forEach(warning => console.log(warning));\r\n  }\r\n  \r\n  console.log('\\n📝 Please fix the issues above before deploying to Railway.');\r\n}\r\n\r\nconsole.log('\\n📞 For help, check:');\r\nconsole.log('- RAILWAY_FINAL_SOLUTION.md');\r\nconsole.log('- ENVIRONMENT_VARIABLES_CHECK.md');\r\nconsole.log('- Railway logs: railway logs');\r\n\r\nprocess.exit(allChecksPass ? 0 : 1);\r\n",
  "scripts/check-railway-compatibility.js": "const fs = require('fs');\r\nconst path = require('path');\r\n\r\nconsole.log('🔍 Проверка совместимости с Railway...\\n');\r\n\r\nconst checks = {\r\n  'Monorepo structure': checkMonorepoStructure(),\r\n  'Package.json in root': fs.existsSync('package.json'),\r\n  'Start scripts': checkStartScripts(),\r\n  'Port configuration': checkPortConfig(),\r\n  'Database compatibility': checkDatabase(),\r\n  'File storage': checkFileStorage(),\r\n  'Environment variables': checkEnvVars(),\r\n  'Docker configuration': checkDockerConfig(),\r\n  'Service dependencies': checkServiceDependencies()\r\n};\r\n\r\nfunction checkMonorepoStructure() {\r\n  return fs.existsSync('services') && fs.existsSync('packages');\r\n}\r\n\r\nfunction checkStartScripts() {\r\n  try {\r\n    const services = fs.readdirSync('services');\r\n    let allHaveScripts = true;\r\n    const serviceScripts = {};\r\n    \r\n    services.forEach(service => {\r\n      const pkgPath = path.join('services', service, 'package.json');\r\n      if (fs.existsSync(pkgPath)) {\r\n        const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));\r\n        const hasStart = pkg.scripts && (pkg.scripts.start || pkg.scripts.dev);\r\n        serviceScripts[service] = hasStart;\r\n        if (!hasStart) allHaveScripts = false;\r\n      } else {\r\n        serviceScripts[service] = false;\r\n        allHaveScripts = false;\r\n      }\r\n    });\r\n    \r\n    console.log('📦 Service start scripts:');\r\n    Object.entries(serviceScripts).forEach(([service, hasScript]) => {\r\n      console.log(`  ${hasScript ? '✅' : '❌'} ${service}`);\r\n    });\r\n    \r\n    return allHaveScripts;\r\n  } catch (error) {\r\n    console.error('Error checking start scripts:', error.message);\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction checkPortConfig() {\r\n  try {\r\n    const services = fs.readdirSync('services');\r\n    const portIssues = [];\r\n    \r\n    services.forEach(service => {\r\n      const indexPath = path.join('services', service, 'src', 'index.js');\r\n      if (fs.existsSync(indexPath)) {\r\n        const content = fs.readFileSync(indexPath, 'utf8');\r\n        \r\n        // Проверяем на hardcoded порты\r\n        if (content.includes('const PORT =') && !content.includes('process.env.PORT')) {\r\n          portIssues.push(`${service}: hardcoded port detected`);\r\n        }\r\n      }\r\n    });\r\n    \r\n    if (portIssues.length > 0) {\r\n      console.log('⚠️ Port configuration issues:');\r\n      portIssues.forEach(issue => console.log(`  - ${issue}`));\r\n    }\r\n    \r\n    return portIssues.length === 0;\r\n  } catch (error) {\r\n    console.error('Error checking port config:', error.message);\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction checkDatabase() {\r\n  const hasEnv = fs.existsSync('.env');\r\n  const hasPrisma = fs.existsSync('packages/database/prisma/schema.prisma');\r\n  \r\n  if (hasEnv) {\r\n    const envContent = fs.readFileSync('.env', 'utf8');\r\n    const hasDatabaseUrl = envContent.includes('DATABASE_URL');\r\n    \r\n    console.log('🗄️ Database configuration:');\r\n    console.log(`  ${hasDatabaseUrl ? '✅' : '❌'} DATABASE_URL found`);\r\n    console.log(`  ${hasPrisma ? '✅' : '❌'} Prisma schema exists`);\r\n    \r\n    return hasDatabaseUrl && hasPrisma;\r\n  }\r\n  \r\n  return false;\r\n}\r\n\r\nfunction checkFileStorage() {\r\n  // MinIO не будет работать на Railway - нужен внешний S3\r\n  const hasMinIO = fs.existsSync('docker-compose.yml') && \r\n    fs.readFileSync('docker-compose.yml', 'utf8').includes('minio');\r\n  \r\n  const hasS3Adapter = fs.existsSync('packages/shared/storage') ||\r\n    fs.existsSync('packages/shared/utils') && \r\n    fs.readFileSync('packages/shared/utils/index.js', 'utf8').includes('s3');\r\n  \r\n  console.log('📁 File storage:');\r\n  console.log(`  ${hasMinIO ? '⚠️' : '✅'} MinIO detected (needs S3 replacement)`);\r\n  console.log(`  ${hasS3Adapter ? '✅' : '❌'} S3 adapter available`);\r\n  \r\n  return !hasMinIO || hasS3Adapter;\r\n}\r\n\r\nfunction checkEnvVars() {\r\n  const required = [\r\n    'DATABASE_URL',\r\n    'JWT_SECRET',\r\n    'REDIS_URL'\r\n  ];\r\n  \r\n  const optional = [\r\n    'TELEGRAM_BOT_TOKEN',\r\n    'S3_BUCKET',\r\n    'S3_ACCESS_KEY',\r\n    'S3_SECRET_KEY'\r\n  ];\r\n  \r\n  if (!fs.existsSync('.env')) {\r\n    console.log('❌ .env file not found');\r\n    return false;\r\n  }\r\n  \r\n  const env = fs.readFileSync('.env', 'utf8');\r\n  const missing = required.filter(v => !env.includes(v));\r\n  const missingOptional = optional.filter(v => !env.includes(v));\r\n  \r\n  console.log('🔐 Environment variables:');\r\n  required.forEach(v => {\r\n    console.log(`  ${env.includes(v) ? '✅' : '❌'} ${v} (required)`);\r\n  });\r\n  \r\n  optional.forEach(v => {\r\n    console.log(`  ${env.includes(v) ? '✅' : '⚠️'} ${v} (optional)`);\r\n  });\r\n  \r\n  return missing.length === 0;\r\n}\r\n\r\nfunction checkDockerConfig() {\r\n  const hasDockerCompose = fs.existsSync('docker-compose.yml');\r\n  const hasDockerfile = fs.existsSync('Dockerfile');\r\n  \r\n  console.log('🐳 Docker configuration:');\r\n  console.log(`  ${hasDockerCompose ? '✅' : '❌'} docker-compose.yml`);\r\n  console.log(`  ${hasDockerfile ? '✅' : '❌'} Dockerfile`);\r\n  \r\n  return hasDockerCompose;\r\n}\r\n\r\nfunction checkServiceDependencies() {\r\n  try {\r\n    const services = fs.readdirSync('services');\r\n    const dependencyIssues = [];\r\n    \r\n    services.forEach(service => {\r\n      const pkgPath = path.join('services', service, 'package.json');\r\n      if (fs.existsSync(pkgPath)) {\r\n        const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));\r\n        \r\n        // Проверяем на устаревшие зависимости\r\n        if (pkg.dependencies) {\r\n          Object.entries(pkg.dependencies).forEach(([dep, version]) => {\r\n            if (version.includes('^0.') || version.includes('~0.')) {\r\n              dependencyIssues.push(`${service}: ${dep}@${version} (potentially unstable)`);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    });\r\n    \r\n    if (dependencyIssues.length > 0) {\r\n      console.log('⚠️ Dependency issues:');\r\n      dependencyIssues.forEach(issue => console.log(`  - ${issue}`));\r\n    }\r\n    \r\n    return dependencyIssues.length === 0;\r\n  } catch (error) {\r\n    console.error('Error checking dependencies:', error.message);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Вывод результатов\r\nconsole.log('\\n📊 Railway Compatibility Report:');\r\nconsole.log('================================');\r\n\r\nObject.entries(checks).forEach(([check, passed]) => {\r\n  console.log(`${passed ? '✅' : '❌'} ${check}`);\r\n});\r\n\r\n// Подсчет совместимости\r\nconst passedChecks = Object.values(checks).filter(Boolean).length;\r\nconst totalChecks = Object.keys(checks).length;\r\nconst compatibilityScore = Math.round((passedChecks / totalChecks) * 100);\r\n\r\nconsole.log(`\\n🎯 Compatibility Score: ${compatibilityScore}%`);\r\n\r\nif (compatibilityScore >= 80) {\r\n  console.log('✅ Project is ready for Railway deployment with minor fixes');\r\n} else if (compatibilityScore >= 60) {\r\n  console.log('⚠️ Project needs moderate changes for Railway deployment');\r\n} else {\r\n  console.log('❌ Project needs significant changes for Railway deployment');\r\n}\r\n\r\n// Сохранение результатов\r\nconst report = {\r\n  timestamp: new Date().toISOString(),\r\n  compatibilityScore,\r\n  checks,\r\n  recommendations: generateRecommendations(checks)\r\n};\r\n\r\nfs.writeFileSync('railway-compatibility-report.json', JSON.stringify(report, null, 2));\r\nconsole.log('\\n📄 Detailed report saved to: railway-compatibility-report.json');\r\n\r\nfunction generateRecommendations(checks) {\r\n  const recommendations = [];\r\n  \r\n  if (!checks['Port configuration']) {\r\n    recommendations.push('Fix hardcoded ports to use process.env.PORT');\r\n  }\r\n  \r\n  if (!checks['File storage']) {\r\n    recommendations.push('Replace MinIO with external S3 service');\r\n  }\r\n  \r\n  if (!checks['Environment variables']) {\r\n    recommendations.push('Add missing environment variables');\r\n  }\r\n  \r\n  if (!checks['Start scripts']) {\r\n    recommendations.push('Add start scripts to all services');\r\n  }\r\n  \r\n  return recommendations;\r\n}\r\n",
  "scripts/safe-fixes.js": "const fs = require('fs');\r\nconst path = require('path');\r\n\r\nclass SafeFixer {\r\n  constructor() {\r\n    this.backups = [];\r\n    this.changes = [];\r\n  }\r\n\r\n  // Создание резервных копий перед изменениями\r\n  backup(filePath) {\r\n    if (!fs.existsSync(filePath)) {\r\n      console.log(`⚠️ File not found: ${filePath}`);\r\n      return false;\r\n    }\r\n    \r\n    const content = fs.readFileSync(filePath, 'utf8');\r\n    const backupPath = `${filePath}.backup.${Date.now()}`;\r\n    fs.writeFileSync(backupPath, content);\r\n    this.backups.push({ original: filePath, backup: backupPath });\r\n    console.log(`📦 Backup created: ${backupPath}`);\r\n    return true;\r\n  }\r\n\r\n  // Безопасное изменение файла\r\n  safeModify(filePath, modifier, description) {\r\n    try {\r\n      if (!this.backup(filePath)) {\r\n        this.changes.push({ file: filePath, success: false, error: 'File not found' });\r\n        return;\r\n      }\r\n      \r\n      const content = fs.readFileSync(filePath, 'utf8');\r\n      const modified = modifier(content);\r\n      \r\n      if (content === modified) {\r\n        console.log(`ℹ️ No changes needed: ${filePath}`);\r\n        this.changes.push({ file: filePath, success: true, description, noChanges: true });\r\n        return;\r\n      }\r\n      \r\n      fs.writeFileSync(filePath, modified);\r\n      this.changes.push({ file: filePath, success: true, description });\r\n      console.log(`✅ Modified: ${filePath} - ${description}`);\r\n    } catch (error) {\r\n      console.error(`❌ Failed to modify ${filePath}: ${error.message}`);\r\n      this.changes.push({ file: filePath, success: false, error: error.message, description });\r\n    }\r\n  }\r\n\r\n  // Откат изменений\r\n  rollback() {\r\n    console.log('🔄 Rolling back changes...');\r\n    for (const { original, backup } of this.backups.reverse()) {\r\n      try {\r\n        fs.copyFileSync(backup, original);\r\n        fs.unlinkSync(backup);\r\n        console.log(`↩️ Restored: ${original}`);\r\n      } catch (error) {\r\n        console.error(`❌ Failed to restore ${original}: ${error.message}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Исправление PORT для Railway\r\n  fixPortConfiguration() {\r\n    console.log('\\n🔧 Fixing PORT configuration for Railway...');\r\n    \r\n    const services = fs.readdirSync('services');\r\n    \r\n    for (const service of services) {\r\n      const indexPath = path.join('services', service, 'src', 'index.js');\r\n      \r\n      if (fs.existsSync(indexPath)) {\r\n        this.safeModify(indexPath, (content) => {\r\n          // Заменяем фиксированные порты на process.env.PORT\r\n          if (content.includes('const PORT =') && !content.includes('process.env.PORT')) {\r\n            const servicePortMap = {\r\n              'gateway': '8000',\r\n              'auth': '3001',\r\n              'machines': '3002',\r\n              'inventory': '3003',\r\n              'tasks': '3004',\r\n              'telegram-bot': '3005',\r\n              'notifications': '3006',\r\n              'audit': '3007',\r\n              'data-import': '3008',\r\n              'backup': '3009',\r\n              'monitoring': '3010',\r\n              'routes': '3011',\r\n              'warehouse': '3012',\r\n              'recipes': '3013',\r\n              'bunkers': '3014',\r\n              'reconciliation': '3015'\r\n            };\r\n            \r\n            const defaultPort = servicePortMap[service] || '3000';\r\n            return content.replace(\r\n              /const PORT = \\d+;?/g,\r\n              `const PORT = process.env.PORT || ${defaultPort};`\r\n            );\r\n          }\r\n          return content;\r\n        }, `Fixed PORT configuration for ${service}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Добавление health checks\r\n  addHealthChecks() {\r\n    console.log('\\n🏥 Adding health checks...');\r\n    \r\n    const services = fs.readdirSync('services');\r\n    \r\n    for (const service of services) {\r\n      const indexPath = path.join('services', service, 'src', 'index.js');\r\n      \r\n      if (fs.existsSync(indexPath)) {\r\n        this.safeModify(indexPath, (content) => {\r\n          if (!content.includes(\"'/health'\") && !content.includes('\"/health\"')) {\r\n            // Определяем тип сервиса для правильного health check\r\n            const isTelegramBot = service === 'telegram-bot';\r\n            const usesFastify = content.includes('fastify');\r\n            \r\n            let healthCheck;\r\n            \r\n            if (isTelegramBot && !usesFastify) {\r\n              // Для Telegram Bot без Fastify\r\n              healthCheck = `\r\n// Health check endpoint for Railway\r\nconst express = require('express');\r\nconst healthApp = express();\r\nconst healthPort = process.env.PORT || 3005;\r\n\r\nhealthApp.get('/health', (req, res) => {\r\n  res.json({\r\n    status: 'ok',\r\n    service: '${service}',\r\n    timestamp: new Date().toISOString(),\r\n    uptime: process.uptime(),\r\n    bot: bot ? 'connected' : 'disconnected'\r\n  });\r\n});\r\n\r\nhealthApp.listen(healthPort, () => {\r\n  console.log(\\`Health check server running on port \\${healthPort}\\`);\r\n});\r\n\r\n`;\r\n            } else if (usesFastify) {\r\n              // Для сервисов с Fastify\r\n              healthCheck = `\r\n// Health check endpoint for Railway\r\nfastify.get('/health', async (request, reply) => {\r\n  try {\r\n    // Проверка подключения к БД если есть prisma\r\n    ${content.includes('prisma') ? 'await prisma.$queryRaw`SELECT 1`;' : ''}\r\n    \r\n    return {\r\n      status: 'ok',\r\n      service: '${service}',\r\n      timestamp: new Date().toISOString(),\r\n      uptime: process.uptime()\r\n    };\r\n  } catch (error) {\r\n    reply.code(503).send({\r\n      status: 'error',\r\n      service: '${service}',\r\n      error: 'Service health check failed',\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  }\r\n});\r\n\r\n`;\r\n            } else {\r\n              // Базовый health check\r\n              healthCheck = `\r\n// Health check endpoint for Railway\r\napp.get('/health', (req, res) => {\r\n  res.json({\r\n    status: 'ok',\r\n    service: '${service}',\r\n    timestamp: new Date().toISOString(),\r\n    uptime: process.uptime()\r\n  });\r\n});\r\n\r\n`;\r\n            }\r\n            \r\n            // Вставляем health check перед запуском сервера\r\n            const patterns = [\r\n              /(fastify\\.listen\\()/,\r\n              /(app\\.listen\\()/,\r\n              /(bot\\.launch\\(\\))/,\r\n              /(console\\.log.*started)/i\r\n            ];\r\n            \r\n            for (const pattern of patterns) {\r\n              if (pattern.test(content)) {\r\n                return content.replace(pattern, healthCheck + '$1');\r\n              }\r\n            }\r\n            \r\n            // Если не нашли подходящее место, добавляем в конец\r\n            return content + '\\n' + healthCheck;\r\n          }\r\n          return content;\r\n        }, `Added health check for ${service}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Исправление start script для reconciliation\r\n  fixReconciliationStartScript() {\r\n    console.log('\\n📝 Fixing reconciliation start script...');\r\n    \r\n    const reconciliationPkgPath = 'services/reconciliation/package.json';\r\n    \r\n    if (fs.existsSync(reconciliationPkgPath)) {\r\n      this.safeModify(reconciliationPkgPath, (content) => {\r\n        const pkg = JSON.parse(content);\r\n        \r\n        if (!pkg.scripts) {\r\n          pkg.scripts = {};\r\n        }\r\n        \r\n        if (!pkg.scripts.start) {\r\n          pkg.scripts.start = 'node src/index.js';\r\n          pkg.scripts.dev = 'nodemon src/index.js';\r\n        }\r\n        \r\n        return JSON.stringify(pkg, null, 2);\r\n      }, 'Added start script to reconciliation service');\r\n    } else {\r\n      console.log('⚠️ Reconciliation service package.json not found');\r\n    }\r\n  }\r\n\r\n  // Создание S3 адаптера\r\n  createS3Adapter() {\r\n    console.log('\\n☁️ Creating S3 adapter...');\r\n    \r\n    const storageDir = 'packages/shared/storage';\r\n    if (!fs.existsSync(storageDir)) {\r\n      fs.mkdirSync(storageDir, { recursive: true });\r\n    }\r\n    \r\n    const s3AdapterContent = `\r\n// S3 Storage Adapter for Railway deployment\r\nconst AWS = require('aws-sdk');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nclass S3StorageAdapter {\r\n  constructor() {\r\n    this.s3 = new AWS.S3({\r\n      endpoint: process.env.S3_ENDPOINT || 'https://s3.amazonaws.com',\r\n      accessKeyId: process.env.S3_ACCESS_KEY,\r\n      secretAccessKey: process.env.S3_SECRET_KEY,\r\n      region: process.env.S3_REGION || 'us-east-1',\r\n      s3ForcePathStyle: true,\r\n      signatureVersion: 'v4'\r\n    });\r\n    \r\n    this.bucket = process.env.S3_BUCKET;\r\n    \r\n    if (!this.bucket) {\r\n      console.warn('⚠️ S3_BUCKET not configured, using local storage fallback');\r\n    }\r\n  }\r\n\r\n  async upload(key, buffer, contentType = 'application/octet-stream') {\r\n    if (!this.bucket) {\r\n      return this.localFallback('upload', key, buffer);\r\n    }\r\n    \r\n    try {\r\n      const params = {\r\n        Bucket: this.bucket,\r\n        Key: key,\r\n        Body: buffer,\r\n        ContentType: contentType,\r\n        ACL: 'public-read'\r\n      };\r\n      \r\n      const result = await this.s3.upload(params).promise();\r\n      return {\r\n        success: true,\r\n        url: result.Location,\r\n        key: result.Key\r\n      };\r\n    } catch (error) {\r\n      console.error('S3 upload error:', error);\r\n      return this.localFallback('upload', key, buffer);\r\n    }\r\n  }\r\n  \r\n  async download(key) {\r\n    if (!this.bucket) {\r\n      return this.localFallback('download', key);\r\n    }\r\n    \r\n    try {\r\n      const params = {\r\n        Bucket: this.bucket,\r\n        Key: key\r\n      };\r\n      \r\n      const result = await this.s3.getObject(params).promise();\r\n      return {\r\n        success: true,\r\n        data: result.Body,\r\n        contentType: result.ContentType\r\n      };\r\n    } catch (error) {\r\n      console.error('S3 download error:', error);\r\n      return this.localFallback('download', key);\r\n    }\r\n  }\r\n  \r\n  getSignedUrl(key, expires = 3600) {\r\n    if (!this.bucket) {\r\n      return \\`/uploads/\\${key}\\`;\r\n    }\r\n    \r\n    try {\r\n      return this.s3.getSignedUrl('getObject', {\r\n        Bucket: this.bucket,\r\n        Key: key,\r\n        Expires: expires\r\n      });\r\n    } catch (error) {\r\n      console.error('S3 signed URL error:', error);\r\n      return \\`/uploads/\\${key}\\`;\r\n    }\r\n  }\r\n  \r\n  async delete(key) {\r\n    if (!this.bucket) {\r\n      return this.localFallback('delete', key);\r\n    }\r\n    \r\n    try {\r\n      await this.s3.deleteObject({\r\n        Bucket: this.bucket,\r\n        Key: key\r\n      }).promise();\r\n      \r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('S3 delete error:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n  }\r\n  \r\n  // Локальный fallback для разработки\r\n  localFallback(operation, key, data) {\r\n    const uploadsDir = path.join(process.cwd(), 'uploads');\r\n    \r\n    if (!fs.existsSync(uploadsDir)) {\r\n      fs.mkdirSync(uploadsDir, { recursive: true });\r\n    }\r\n    \r\n    const filePath = path.join(uploadsDir, key);\r\n    \r\n    switch (operation) {\r\n      case 'upload':\r\n        fs.writeFileSync(filePath, data);\r\n        return {\r\n          success: true,\r\n          url: \\`/uploads/\\${key}\\`,\r\n          key: key,\r\n          fallback: true\r\n        };\r\n        \r\n      case 'download':\r\n        if (fs.existsSync(filePath)) {\r\n          return {\r\n            success: true,\r\n            data: fs.readFileSync(filePath),\r\n            fallback: true\r\n          };\r\n        }\r\n        return { success: false, error: 'File not found' };\r\n        \r\n      case 'delete':\r\n        if (fs.existsSync(filePath)) {\r\n          fs.unlinkSync(filePath);\r\n        }\r\n        return { success: true, fallback: true };\r\n        \r\n      default:\r\n        return { success: false, error: 'Unknown operation' };\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = S3StorageAdapter;\r\n`;\r\n    \r\n    const s3AdapterPath = path.join(storageDir, 's3.js');\r\n    fs.writeFileSync(s3AdapterPath, s3AdapterContent.trim());\r\n    this.changes.push({ \r\n      file: s3AdapterPath, \r\n      success: true, \r\n      description: 'Created S3 storage adapter',\r\n      created: true \r\n    });\r\n    console.log(`✅ Created S3 adapter: ${s3AdapterPath}`);\r\n    \r\n    // Создаем индексный файл для storage\r\n    const indexContent = `\r\nconst S3StorageAdapter = require('./s3');\r\n\r\nmodule.exports = {\r\n  S3StorageAdapter,\r\n  // Создаем singleton instance\r\n  storage: new S3StorageAdapter()\r\n};\r\n`;\r\n    \r\n    const indexPath = path.join(storageDir, 'index.js');\r\n    fs.writeFileSync(indexPath, indexContent.trim());\r\n    this.changes.push({ \r\n      file: indexPath, \r\n      success: true, \r\n      description: 'Created storage index file',\r\n      created: true \r\n    });\r\n    console.log(`✅ Created storage index: ${indexPath}`);\r\n  }\r\n\r\n  // Обновление зависимостей\r\n  updateDependencies() {\r\n    console.log('\\n📦 Updating problematic dependencies...');\r\n    \r\n    const problematicServices = [\r\n      { service: 'data-import', dependency: 'xlsx', currentVersion: '^0.18.5', newVersion: '^0.20.0' },\r\n      { service: 'notifications', dependency: 'node-telegram-bot-api', currentVersion: '^0.64.0', newVersion: '^0.66.0' },\r\n      { service: 'telegram-bot', dependency: 'node-telegram-bot-api', currentVersion: '^0.63.0', newVersion: '^0.66.0' },\r\n      { service: 'telegram-bot', dependency: 'pdfkit', currentVersion: '^0.14.0', newVersion: '^0.15.0' }\r\n    ];\r\n    \r\n    for (const { service, dependency, currentVersion, newVersion } of problematicServices) {\r\n      const pkgPath = path.join('services', service, 'package.json');\r\n      \r\n      if (fs.existsSync(pkgPath)) {\r\n        this.safeModify(pkgPath, (content) => {\r\n          const pkg = JSON.parse(content);\r\n          \r\n          if (pkg.dependencies && pkg.dependencies[dependency] === currentVersion) {\r\n            pkg.dependencies[dependency] = newVersion;\r\n            console.log(`  📈 ${service}: ${dependency} ${currentVersion} → ${newVersion}`);\r\n          }\r\n          \r\n          return JSON.stringify(pkg, null, 2);\r\n        }, `Updated ${dependency} in ${service}`);\r\n      }\r\n    }\r\n    \r\n    // Добавляем aws-sdk если его нет в shared пакете\r\n    const sharedPkgPath = 'packages/shared/package.json';\r\n    if (fs.existsSync(sharedPkgPath)) {\r\n      this.safeModify(sharedPkgPath, (content) => {\r\n        const pkg = JSON.parse(content);\r\n        \r\n        if (!pkg.dependencies) {\r\n          pkg.dependencies = {};\r\n        }\r\n        \r\n        if (!pkg.dependencies['aws-sdk']) {\r\n          pkg.dependencies['aws-sdk'] = '^2.1691.0';\r\n          console.log('  📈 Added aws-sdk to shared package');\r\n        }\r\n        \r\n        return JSON.stringify(pkg, null, 2);\r\n      }, 'Added aws-sdk dependency');\r\n    }\r\n  }\r\n\r\n  // Создание отчета об изменениях\r\n  generateReport() {\r\n    const report = {\r\n      timestamp: new Date().toISOString(),\r\n      backups: this.backups,\r\n      changes: this.changes,\r\n      summary: {\r\n        total: this.changes.length,\r\n        successful: this.changes.filter(c => c.success).length,\r\n        failed: this.changes.filter(c => !c.success).length,\r\n        created: this.changes.filter(c => c.created).length,\r\n        noChanges: this.changes.filter(c => c.noChanges).length\r\n      }\r\n    };\r\n    \r\n    fs.writeFileSync('safe-fixes-report.json', JSON.stringify(report, null, 2));\r\n    console.log('\\n📄 Report saved: safe-fixes-report.json');\r\n    \r\n    // Вывод статистики\r\n    console.log('\\n📊 Summary:');\r\n    console.log(`  ✅ Successful changes: ${report.summary.successful}`);\r\n    console.log(`  ❌ Failed changes: ${report.summary.failed}`);\r\n    console.log(`  📁 Files created: ${report.summary.created}`);\r\n    console.log(`  ℹ️ No changes needed: ${report.summary.noChanges}`);\r\n    \r\n    if (report.summary.failed > 0) {\r\n      console.log('\\n❌ Failed changes:');\r\n      this.changes.filter(c => !c.success).forEach(change => {\r\n        console.log(`  - ${change.file}: ${change.error}`);\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\n// Запуск безопасных исправлений\r\nconst fixer = new SafeFixer();\r\n\r\n// Обработка rollback\r\nif (process.argv.includes('--rollback')) {\r\n  console.log('🔄 Rollback mode activated');\r\n  // Загружаем предыдущий отчет для rollback\r\n  if (fs.existsSync('safe-fixes-report.json')) {\r\n    const report = JSON.parse(fs.readFileSync('safe-fixes-report.json', 'utf8'));\r\n    fixer.backups = report.backups;\r\n    fixer.rollback();\r\n  } else {\r\n    console.log('❌ No backup report found');\r\n  }\r\n  process.exit(0);\r\n}\r\n\r\ntry {\r\n  console.log('🚀 Starting safe fixes for Railway deployment...\\n');\r\n  \r\n  // 1. Исправление конфигурации портов\r\n  fixer.fixPortConfiguration();\r\n  \r\n  // 2. Добавление health checks\r\n  fixer.addHealthChecks();\r\n  \r\n  // 3. Исправление reconciliation start script\r\n  fixer.fixReconciliationStartScript();\r\n  \r\n  // 4. Создание S3 адаптера\r\n  fixer.createS3Adapter();\r\n  \r\n  // 5. Обновление зависимостей\r\n  fixer.updateDependencies();\r\n  \r\n  // 6. Генерация отчета\r\n  fixer.generateReport();\r\n  \r\n  console.log('\\n✅ Safe fixes completed successfully!');\r\n  console.log('💡 To rollback changes, run: node scripts/safe-fixes.js --rollback');\r\n  console.log('🔍 Next step: Run comprehensive test to verify changes');\r\n  \r\n} catch (error) {\r\n  console.error('\\n❌ Error during fixes:', error);\r\n  console.log('🔄 Rolling back changes...');\r\n  fixer.rollback();\r\n  process.exit(1);\r\n}\r\n",
  "services/auth/src/index.js": "/**\r\n * VHM24 - VendHub Manager 24/7\r\n * Authentication Service - PRODUCTION READY\r\n * Provides secure 24/7 authentication for vending machine operators\r\n */\r\n\r\nrequire('dotenv').config({ path: require('path').join(__dirname, '../../../.env') });\r\n\r\n// Устанавливаем SERVICE_NAME для конфигурации\r\nprocess.env.SERVICE_NAME = 'auth';\r\n\r\nconst Fastify = require('fastify');\r\nconst bcrypt = require('bcrypt');\r\nconst { getAuthClient } = require('@vhm24/database');\r\n\r\n// Импортируем наш новый shared пакет\r\nconst {\r\n  // Middleware\r\n  setupCORS,\r\n  setupHelmet,\r\n  setupRateLimit,\r\n  setupJWT,\r\n  authenticate,\r\n  authorize,\r\n  sanitizeInputs,\r\n  securityLogger,\r\n  healthCheck,\r\n  \r\n  // Validation\r\n  validateBody,\r\n  validateQuery,\r\n  validateId,\r\n  \r\n  // Error handling\r\n  registerErrorHandlers,\r\n  setupGlobalErrorHandlers,\r\n  createError,\r\n  asyncHandler,\r\n  \r\n  // Utils\r\n  logger,\r\n  config,\r\n  createFastifyConfig\r\n} = require('@vhm24/shared');\r\n\r\n// Security utilities\r\nconst { \r\n  validateEmail, \r\n  validatePhoneNumber, \r\n  validateTelegramId,\r\n  validatePasswordStrength,\r\n  sanitizeInput,\r\n  maskSensitiveData\r\n} = require('@vhm24/shared-types/src/security');\r\n\r\n// Настройка глобальных обработчиков ошибок\r\nsetupGlobalErrorHandlers();\r\n\r\n// Создаем Fastify с безопасной конфигурацией\r\nconst fastify = Fastify(createFastifyConfig());\r\n\r\n// Получаем Prisma клиент\r\nconst prisma = getAuthClient();\r\n\r\n// Регистрируем обработчики ошибок\r\nregisterErrorHandlers(fastify);\r\n\r\n// Настройка безопасности\r\nsetupHelmet(fastify);\r\nsetupCORS(fastify);\r\nsetupRateLimit(fastify, {\r\n  max: 50, // Более строгий лимит для auth сервиса\r\n  timeWindow: '1 minute'\r\n});\r\nsetupJWT(fastify);\r\n\r\n// Middleware для логирования и санитизации\r\nfastify.addHook('preHandler', securityLogger);\r\nfastify.addHook('preHandler', sanitizeInputs);\r\n\r\n// Декоратор для проверки авторизации\r\nfastify.decorate('authenticate', async function(request, reply) {\r\n  try {\r\n    await request.jwtVerify();\r\n    // Добавляем информацию о пользователе в request\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: request.user.id },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        roles: true,\r\n        isActive: true\r\n      }\r\n    });\r\n    \r\n    if (!user || !user.isActive) {\r\n      throw new Error('User not found or inactive');\r\n    }\r\n    \r\n    request.user = user;\r\n  } catch (err) {\r\n    reply.code(401).send({ \r\n      success: false,\r\n      error: 'Unauthorized',\r\n      message: err.message || 'Invalid or expired token'\r\n    });\r\n  }\r\n});\r\n\r\n// Health check\r\nfastify.get('/health', async (request, reply) => {\r\n  return { status: 'ok', service: 'auth' };\r\n});\r\n\r\n// Регистрация нового пользователя\r\nfastify.post('/api/v1/auth/register', {\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['email', 'password', 'name'],\r\n      properties: {\r\n        email: { type: 'string', format: 'email' },\r\n        password: { type: 'string', minLength: 6 },\r\n        name: { type: 'string', minLength: 2 },\r\n        phoneNumber: { type: 'string' },\r\n        roles: { \r\n          type: 'array', \r\n          items: { \r\n            type: 'string', \r\n            enum: ['ADMIN', 'MANAGER', 'WAREHOUSE', 'OPERATOR', 'TECHNICIAN', 'DRIVER'] \r\n          },\r\n          default: ['OPERATOR']\r\n        }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { email, password, name, phoneNumber, roles } = request.body;\r\n  \r\n  try {\r\n    // Валидация email\r\n    if (!validateEmail(email)) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'Invalid email format'\r\n      });\r\n    }\r\n    \r\n    // Валидация пароля\r\n    const passwordValidation = validatePasswordStrength(password);\r\n    if (!passwordValidation.valid) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: passwordValidation.message\r\n      });\r\n    }\r\n    \r\n    // Валидация телефона (если указан)\r\n    if (phoneNumber && !validatePhoneNumber(phoneNumber)) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'Invalid phone number format. Use format: +998XXXXXXXXX'\r\n      });\r\n    }\r\n    \r\n    // Санитизация имени\r\n    const sanitizedName = sanitizeInput(name);\r\n    \r\n    // Проверяем, существует ли пользователь\r\n    const existingUser = await prisma.user.findFirst({\r\n      where: {\r\n        OR: [\r\n          { email },\r\n          phoneNumber ? { phoneNumber } : {}\r\n        ].filter(Boolean)\r\n      }\r\n    });\r\n    \r\n    if (existingUser) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'User with this email or phone number already exists'\r\n      });\r\n    }\r\n    \r\n    // Хешируем пароль с более высокой стоимостью для production\r\n    const saltRounds = process.env.NODE_ENV === 'production' ? 12 : 10;\r\n    const passwordHash = await bcrypt.hash(password, saltRounds);\r\n    \r\n    // Используем транзакцию для создания пользователя и логирования\r\n    const result = await prisma.$transaction(async (tx) => {\r\n      // Создаем пользователя\r\n      const user = await tx.user.create({\r\n        data: {\r\n          email: email.toLowerCase(), // Нормализуем email\r\n          passwordHash,\r\n          name: sanitizedName,\r\n          phoneNumber,\r\n          roles: roles || ['OPERATOR']\r\n        },\r\n        select: {\r\n          id: true,\r\n          email: true,\r\n          name: true,\r\n          roles: true,\r\n          createdAt: true\r\n        }\r\n      });\r\n      \r\n      // Логируем действие\r\n      await tx.auditLog.create({\r\n        data: {\r\n          userId: user.id,\r\n          action: 'USER_REGISTERED',\r\n          entity: 'User',\r\n          entityId: user.id,\r\n          ipAddress: request.ip,\r\n          userAgent: request.headers['user-agent']\r\n        }\r\n      });\r\n      \r\n      return user;\r\n    });\r\n    \r\n    // Создаем токены\r\n    const token = fastify.jwt.sign({\r\n      id: result.id,\r\n      email: result.email,\r\n      roles: result.roles\r\n    });\r\n    \r\n    const refreshToken = fastify.jwt.sign(\r\n      { id: result.id, type: 'refresh' }, \r\n      { expiresIn: '7d' }\r\n    );\r\n    \r\n    return {\r\n      success: true,\r\n      data: {\r\n        user: {\r\n          ...result,\r\n          email: maskSensitiveData(result.email, 'email')\r\n        },\r\n        token,\r\n        refreshToken\r\n      }\r\n    };\r\n  } catch (error) {\r\n    // Обработка ошибок Prisma\r\n    if (error.code === 'P2002') {\r\n      return reply.code(409).send({\r\n        success: false,\r\n        error: 'User already exists'\r\n      });\r\n    }\r\n    \r\n    throw createError.database('Registration failed');\r\n  }\r\n});\r\n\r\n// Вход в систему\r\nfastify.post('/api/v1/auth/login', async (request, reply) => {\r\n  const { email, password, phoneNumber, telegramId } = request.body;\r\n  \r\n  try {\r\n    // Поддержка входа через email, телефон или telegram для 24/7 доступа\r\n    let where = {};\r\n    let authMethod = 'EMAIL';\r\n    \r\n    if (telegramId) {\r\n      // Валидация Telegram ID\r\n      if (!validateTelegramId(telegramId)) {\r\n        return reply.code(400).send({\r\n          success: false,\r\n          error: 'Invalid Telegram ID format'\r\n        });\r\n      }\r\n      where = { telegramId };\r\n      authMethod = 'TELEGRAM';\r\n    } else if (email) {\r\n      // Валидация email\r\n      if (!validateEmail(email)) {\r\n        return reply.code(400).send({\r\n          success: false,\r\n          error: 'Invalid email format'\r\n        });\r\n      }\r\n      where = { email: email.toLowerCase() };\r\n    } else if (phoneNumber) {\r\n      // Валидация телефона\r\n      if (!validatePhoneNumber(phoneNumber)) {\r\n        return reply.code(400).send({\r\n          success: false,\r\n          error: 'Invalid phone number format. Use format: +998XXXXXXXXX'\r\n        });\r\n      }\r\n      where = { phoneNumber };\r\n      authMethod = 'PHONE';\r\n    } else {\r\n      return reply.code(400).send({ \r\n        success: false,\r\n        error: 'Email, phone or telegram ID required for 24/7 access' \r\n      });\r\n    }\r\n\r\n    const user = await prisma.user.findFirst({\r\n      where,\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        passwordHash: true,\r\n        roles: true,\r\n        isActive: true,\r\n        phoneNumber: true,\r\n        telegramId: true\r\n      }\r\n    });\r\n\r\n    if (!user || !user.isActive) {\r\n      return reply.code(401).send({ error: 'Invalid credentials' });\r\n    }\r\n\r\n    // Для Telegram входа пароль не проверяем (для быстрого доступа 24/7)\r\n    if (authMethod !== 'TELEGRAM' && password) {\r\n      const isValidPassword = await bcrypt.compare(password, user.passwordHash);\r\n      if (!isValidPassword) {\r\n        return reply.code(401).send({ error: 'Invalid credentials' });\r\n      }\r\n    } else if (authMethod !== 'TELEGRAM' && !password) {\r\n      return reply.code(400).send({ error: 'Password required' });\r\n    }\r\n\r\n    await prisma.user.update({\r\n      where: { id: user.id },\r\n      data: { lastLogin: new Date() }\r\n    });\r\n\r\n    await prisma.auditLog.create({\r\n      data: {\r\n        userId: user.id,\r\n        action: 'USER_LOGIN',\r\n        entity: 'User',\r\n        entityId: user.id,\r\n        ipAddress: request.ip,\r\n        userAgent: request.headers['user-agent'],\r\n        changes: { authMethod }\r\n      }\r\n    });\r\n\r\n    const token = fastify.jwt.sign({\r\n      id: user.id,\r\n      email: user.email,\r\n      roles: user.roles,\r\n      name: user.name\r\n    });\r\n\r\n    fastify.log.info(`User ${user.email} logged in - VHM24 system access granted`);\r\n\r\n    return {\r\n      success: true,\r\n      token,\r\n      user: {\r\n        id: user.id,\r\n        email: user.email,\r\n        name: user.name,\r\n        roles: user.roles,\r\n        phoneNumber: user.phoneNumber\r\n      },\r\n      message: 'Welcome to VHM24 - 24/7 Access Granted'\r\n    };\r\n  } catch (error) {\r\n    throw createError.authentication('Login failed');\r\n  }\r\n});\r\n\r\n// Обновление токена\r\nfastify.post('/api/v1/auth/refresh', {\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['refreshToken'],\r\n      properties: {\r\n        refreshToken: { type: 'string' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { refreshToken } = request.body;\r\n  \r\n  try {\r\n    // Проверяем refresh token\r\n    const decoded = fastify.jwt.verify(refreshToken);\r\n    \r\n    // Находим пользователя\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: decoded.id },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        roles: true,\r\n        isActive: true\r\n      }\r\n    });\r\n    \r\n    if (!user || !user.isActive) {\r\n      return reply.code(401).send({\r\n        success: false,\r\n        error: 'Invalid refresh token'\r\n      });\r\n    }\r\n    \r\n    // Создаем новые токены\r\n    const token = fastify.jwt.sign({\r\n      id: user.id,\r\n      email: user.email,\r\n      roles: user.roles\r\n    });\r\n    \r\n    const newRefreshToken = fastify.jwt.sign(\r\n      { id: user.id },\r\n      { expiresIn: '7d' }\r\n    );\r\n    \r\n    return {\r\n      success: true,\r\n      data: {\r\n        token,\r\n        refreshToken: newRefreshToken\r\n      }\r\n    };\r\n  } catch (error) {\r\n    reply.code(401).send({\r\n      success: false,\r\n      error: 'Invalid refresh token'\r\n    });\r\n  }\r\n});\r\n\r\n// Получить текущего пользователя\r\nfastify.get('/api/v1/auth/me', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: request.user.id },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        roles: true,\r\n        phoneNumber: true,\r\n        isActive: true,\r\n        createdAt: true,\r\n        lastLogin: true\r\n      }\r\n    });\r\n    \r\n    if (!user) {\r\n      return reply.code(404).send({\r\n        success: false,\r\n        error: 'User not found'\r\n      });\r\n    }\r\n    \r\n    return {\r\n      success: true,\r\n      data: user\r\n    };\r\n  } catch (error) {\r\n    throw createError.database('Failed to fetch user data');\r\n  }\r\n});\r\n\r\n// Изменить пароль\r\nfastify.post('/api/v1/auth/change-password', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['currentPassword', 'newPassword'],\r\n      properties: {\r\n        currentPassword: { type: 'string' },\r\n        newPassword: { type: 'string', minLength: 6 }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { currentPassword, newPassword } = request.body;\r\n  const userId = request.user.id;\r\n  \r\n  try {\r\n    // Получаем пользователя с паролем\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: userId }\r\n    });\r\n    \r\n    // Проверяем текущий пароль\r\n    const validPassword = await bcrypt.compare(currentPassword, user.passwordHash);\r\n    \r\n    if (!validPassword) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'Current password is incorrect'\r\n      });\r\n    }\r\n    \r\n    // Хешируем новый пароль\r\n    const newPasswordHash = await bcrypt.hash(newPassword, 10);\r\n    \r\n    // Обновляем пароль\r\n    await prisma.user.update({\r\n      where: { id: userId },\r\n      data: { passwordHash: newPasswordHash }\r\n    });\r\n    \r\n    // Логируем действие\r\n    await prisma.auditLog.create({\r\n      data: {\r\n        userId,\r\n        action: 'PASSWORD_CHANGED',\r\n        entity: 'User',\r\n        entityId: userId,\r\n        ipAddress: request.ip\r\n      }\r\n    });\r\n    \r\n    return {\r\n      success: true,\r\n      message: 'Password changed successfully'\r\n    };\r\n  } catch (error) {\r\n    throw createError.database('Failed to change password');\r\n  }\r\n});\r\n\r\n// Выход (логирование)\r\nfastify.post('/api/v1/auth/logout', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    // Логируем действие\r\n    await prisma.auditLog.create({\r\n      data: {\r\n        userId: request.user.id,\r\n        action: 'USER_LOGOUT',\r\n        entity: 'User',\r\n        entityId: request.user.id,\r\n        ipAddress: request.ip\r\n      }\r\n    });\r\n    \r\n    return {\r\n      success: true,\r\n      message: 'Logged out successfully'\r\n    };\r\n  } catch (error) {\r\n    fastify.log.error(error);\r\n    return {\r\n      success: true,\r\n      message: 'Logged out successfully'\r\n    };\r\n  }\r\n});\r\n\r\n// Связывание Telegram ID с пользователем\r\nfastify.post('/api/v1/auth/link-telegram', {\r\n  preValidation: [fastify.authenticate],\r\n  schema: {\r\n    body: {\r\n      type: 'object',\r\n      required: ['telegramId'],\r\n      properties: {\r\n        telegramId: { type: 'string' }\r\n      }\r\n    }\r\n  }\r\n}, async (request, reply) => {\r\n  const { telegramId } = request.body;\r\n  const userId = request.user.id;\r\n  \r\n  try {\r\n    // Проверяем, не привязан ли уже этот Telegram ID к другому пользователю\r\n    const existingUser = await prisma.user.findFirst({\r\n      where: { telegramId }\r\n    });\r\n    \r\n    if (existingUser && existingUser.id !== userId) {\r\n      return reply.code(400).send({\r\n        success: false,\r\n        error: 'This Telegram ID is already linked to another account'\r\n      });\r\n    }\r\n    \r\n    // Обновляем пользователя\r\n    await prisma.user.update({\r\n      where: { id: userId },\r\n      data: { telegramId }\r\n    });\r\n    \r\n    // Логируем действие\r\n    await prisma.auditLog.create({\r\n      data: {\r\n        userId,\r\n        action: 'TELEGRAM_LINKED',\r\n        entity: 'User',\r\n        entityId: userId,\r\n        ipAddress: request.ip,\r\n        changes: { telegramId }\r\n      }\r\n    });\r\n    \r\n    return {\r\n      success: true,\r\n      message: 'Telegram account linked successfully'\r\n    };\r\n  } catch (error) {\r\n    throw createError.database('Failed to link Telegram account');\r\n  }\r\n});\r\n\r\n// Проверка роли (middleware helper)\r\nfastify.decorate('requireRole', (roles) => {\r\n  return async function (request, reply) {\r\n    if (!request.user) {\r\n      return reply.code(401).send({ error: 'Unauthorized' });\r\n    }\r\n    \r\n    const hasRole = roles.some(role => request.user.roles.includes(role));\r\n    \r\n    if (!hasRole) {\r\n      return reply.code(403).send({ \r\n        error: 'Forbidden',\r\n        message: `Required roles: ${roles.join(', ')}`\r\n      });\r\n    }\r\n  };\r\n});\r\n\r\n// Создание первого администратора (если нет пользователей)\r\nasync function createDefaultAdmin() {\r\n  try {\r\n    const userCount = await prisma.user.count();\r\n    \r\n    if (userCount === 0) {\r\n      const passwordHash = await bcrypt.hash('admin123', 10);\r\n      \r\n      await prisma.user.create({\r\n        data: {\r\n          email: 'admin@vhm24.ru',\r\n          name: 'System Administrator',\r\n          passwordHash,\r\n          roles: ['ADMIN'],\r\n          isActive: true\r\n        }\r\n      });\r\n      \r\n      console.log('Default admin user created: admin@vhm24.ru / admin123');\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to create default admin:', error);\r\n  }\r\n}\r\n\r\n// Start server\r\nconst start = async () => {\r\n  try {\r\n    // Создаем администратора по умолчанию\r\n    await createDefaultAdmin();\r\n    \r\n    await fastify.listen({ \r\n      port: process.env.PORT || 3001,\r\n      host: '0.0.0.0'\r\n    });\r\n    console.log('VHM24 Auth Service running 24/7 on port', process.env.PORT || 3001);\r\n  } catch (err) {\r\n    fastify.log.error(err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\nstart();\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGTERM', async () => {\r\n  await fastify.close();\r\n  await prisma.$disconnect();\r\n  process.exit(0);\r\n});\r\n",
  "services/gateway/src/index.js": "/**\r\n * VHM24 - VendHub Manager 24/7\r\n * Gateway Service - PRODUCTION READY\r\n * Secure API Gateway with WebSocket support\r\n */\r\n\r\nrequire('dotenv').config({ path: require('path').join(__dirname, '../../../.env') });\r\n\r\n// Устанавливаем SERVICE_NAME для конфигурации\r\nprocess.env.SERVICE_NAME = 'gateway';\r\n\r\nconst Fastify = require('fastify');\r\nconst httpProxy = require('@fastify/http-proxy');\r\nconst multipart = require('@fastify/multipart');\r\nconst websocket = require('@fastify/websocket');\r\nconst { getPrismaClient } = require('@vhm24/database');\r\nconst { validateFileType, sanitizeInput } = require('@vhm24/shared-types/src/security');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\nconst { v4: uuidv4 } = require('uuid');\r\n\r\n// Импортируем наш новый shared пакет\r\nconst {\r\n  // Middleware\r\n  setupCORS,\r\n  setupHelmet,\r\n  setupRateLimit,\r\n  setupJWT,\r\n  authenticate,\r\n  authorize,\r\n  sanitizeInputs,\r\n  securityLogger,\r\n  healthCheck,\r\n  \r\n  // Validation\r\n  validateBody,\r\n  validateQuery,\r\n  validateId,\r\n  \r\n  // Error handling\r\n  registerErrorHandlers,\r\n  setupGlobalErrorHandlers,\r\n  createError,\r\n  asyncHandler,\r\n  \r\n  // Utils\r\n  logger,\r\n  config: sharedConfig,\r\n  createFastifyConfig\r\n} = require('@vhm24/shared');\r\n\r\n// Импортируем middleware аудита\r\nconst AuditMiddleware = require('@vhm24/shared/middleware/auditMiddleware');\r\nconst auditMiddleware = new AuditMiddleware();\r\n\r\n// Настройка глобальных обработчиков ошибок\r\nsetupGlobalErrorHandlers();\r\n\r\n// Создаем Fastify с безопасной конфигурацией\r\nconst fastify = Fastify({\r\n  ...createFastifyConfig(),\r\n  bodyLimit: parseInt(process.env.MAX_FILE_SIZE) || 10485760 // 10MB по умолчанию\r\n});\r\n\r\nconst prisma = getPrismaClient();\r\n\r\n// Регистрируем обработчики ошибок\r\nregisterErrorHandlers(fastify);\r\n\r\n// Настройка безопасности\r\nsetupHelmet(fastify, {\r\n  contentSecurityPolicy: {\r\n    directives: {\r\n      defaultSrc: [\"'self'\"],\r\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\r\n      scriptSrc: [\"'self'\"],\r\n      imgSrc: [\"'self'\", \"data:\", \"https:\"],\r\n      connectSrc: [\"'self'\", \"ws:\", \"wss:\"],\r\n    },\r\n  },\r\n});\r\nsetupCORS(fastify);\r\nsetupRateLimit(fastify, {\r\n  max: 200, // Более высокий лимит для gateway\r\n  timeWindow: '1 minute'\r\n});\r\nsetupJWT(fastify, {\r\n  verify: {\r\n    issuer: ['vhm24-gateway', 'vhm24-auth'] // Принимаем токены от auth сервиса\r\n  }\r\n});\r\n\r\n// Middleware для логирования и санитизации\r\nfastify.addHook('preHandler', securityLogger);\r\nfastify.addHook('preHandler', sanitizeInputs);\r\n\r\n// Middleware аудита для автоматического логирования\r\nfastify.addHook('preHandler', auditMiddleware.fastifyMiddleware());\r\n\r\nfastify.register(multipart, {\r\n  limits: {\r\n    fileSize: 10 * 1024 * 1024 // 10MB\r\n  }\r\n});\r\n\r\nfastify.register(websocket);\r\n\r\n// WebSocket клиенты\r\nconst wsClients = new Set();\r\n\r\n// Декоратор для проверки авторизации (переопределяем для совместимости)\r\nfastify.decorate('authenticate', authenticate);\r\n\r\n// Health check\r\nfastify.get('/health', async (request, reply) => {\r\n  const services = {\r\n    auth: 'unknown',\r\n    machines: 'unknown',\r\n    inventory: 'unknown',\r\n    tasks: 'unknown',\r\n    bunkers: 'unknown',\r\n    notifications: 'unknown'\r\n  };\r\n  \r\n  // Проверяем каждый сервис\r\n  const checks = [\r\n    { name: 'auth', url: 'http://127.0.0.1:3001/health' },\r\n    { name: 'machines', url: 'http://127.0.0.1:3002/health' },\r\n    { name: 'inventory', url: 'http://127.0.0.1:3003/health' },\r\n    { name: 'tasks', url: 'http://127.0.0.1:3004/health' },\r\n    { name: 'bunkers', url: 'http://127.0.0.1:3005/health' },\r\n    { name: 'notifications', url: 'http://127.0.0.1:3006/health' }\r\n  ];\r\n  \r\n  for (const check of checks) {\r\n    try {\r\n      const response = await fetch(check.url);\r\n      if (response.ok) {\r\n        services[check.name] = 'ok';\r\n      } else {\r\n        services[check.name] = 'error';\r\n      }\r\n    } catch (e) {\r\n      services[check.name] = 'offline';\r\n    }\r\n  }\r\n  \r\n  // Проверяем базу данных\r\n  let dbStatus = 'unknown';\r\n  try {\r\n    await prisma.$queryRaw`SELECT 1`;\r\n    dbStatus = 'connected';\r\n  } catch (e) {\r\n    dbStatus = 'error';\r\n  }\r\n  \r\n  return { \r\n    status: 'ok', \r\n    service: 'gateway',\r\n    services,\r\n    database: process.env.DATABASE_URL ? 'supabase' : 'local',\r\n    dbStatus,\r\n    timestamp: new Date().toISOString()\r\n  };\r\n});\r\n\r\n// WebSocket endpoint для real-time обновлений\r\nfastify.register(async function (fastify) {\r\n  fastify.get('/ws', { websocket: true }, (connection, req) => {\r\n    console.log('WebSocket client connected');\r\n    \r\n    // Добавляем клиента в список\r\n    wsClients.add(connection.socket);\r\n    \r\n    // Отправляем приветствие\r\n    connection.socket.send(JSON.stringify({\r\n      type: 'connected',\r\n      message: 'Connected to VHM24 WebSocket',\r\n      timestamp: new Date()\r\n    }));\r\n    \r\n    // Обработка сообщений от клиента\r\n    connection.socket.on('message', async (message) => {\r\n      try {\r\n        const data = JSON.parse(message.toString());\r\n        console.log('WebSocket message:', data);\r\n        \r\n        // Echo обратно\r\n        connection.socket.send(JSON.stringify({\r\n          type: 'echo',\r\n          data: data,\r\n          timestamp: new Date()\r\n        }));\r\n      } catch (error) {\r\n        console.error('WebSocket message error:', error);\r\n      }\r\n    });\r\n    \r\n    // Очистка при отключении\r\n    connection.socket.on('close', () => {\r\n      console.log('WebSocket client disconnected');\r\n      wsClients.delete(connection.socket);\r\n    });\r\n  });\r\n});\r\n\r\n// Функция для broadcast сообщений всем WebSocket клиентам\r\nfunction broadcastToClients(type, data) {\r\n  const message = JSON.stringify({\r\n    type,\r\n    data,\r\n    timestamp: new Date()\r\n  });\r\n  \r\n  wsClients.forEach(client => {\r\n    if (client.readyState === 1) { // WebSocket.OPEN\r\n      client.send(message);\r\n    }\r\n  });\r\n}\r\n\r\n// Загрузка файлов с валидацией\r\nfastify.post('/api/v1/upload', {\r\n  preValidation: [fastify.authenticate],\r\n  handler: async (request, reply) => {\r\n    const parts = request.parts();\r\n    const uploadedFiles = [];\r\n    const maxFileSize = parseInt(process.env.MAX_FILE_SIZE) || 10485760; // 10MB\r\n    \r\n    for await (const part of parts) {\r\n      if (part.file) {\r\n        // Валидация типа файла\r\n        if (!validateFileType(part.mimetype)) {\r\n          return reply.code(400).send({\r\n            success: false,\r\n            error: `File type ${part.mimetype} is not allowed`\r\n          });\r\n        }\r\n        \r\n        // Санитизация имени файла\r\n        const sanitizedFilename = sanitizeInput(part.filename);\r\n        const ext = path.extname(sanitizedFilename);\r\n        const filename = `${uuidv4()}${ext}`;\r\n        const uploadDir = path.join(process.cwd(), process.env.UPLOAD_DIR || 'uploads');\r\n        const filepath = path.join(uploadDir, filename);\r\n        \r\n        // Создаем директорию если не существует\r\n        if (!fs.existsSync(uploadDir)) {\r\n          fs.mkdirSync(uploadDir, { recursive: true });\r\n        }\r\n        \r\n        // Проверяем размер файла\r\n        let fileSize = 0;\r\n        const chunks = [];\r\n        \r\n        for await (const chunk of part.file) {\r\n          fileSize += chunk.length;\r\n          if (fileSize > maxFileSize) {\r\n            return reply.code(413).send({\r\n              success: false,\r\n              error: `File size exceeds maximum allowed size of ${maxFileSize} bytes`\r\n            });\r\n          }\r\n          chunks.push(chunk);\r\n        }\r\n        \r\n        // Сохраняем файл\r\n        const buffer = Buffer.concat(chunks);\r\n        fs.writeFileSync(filepath, buffer);\r\n        \r\n        // Логируем загрузку файла\r\n        await prisma.auditLog.create({\r\n          data: {\r\n            userId: request.user.id,\r\n            action: 'FILE_UPLOADED',\r\n            entity: 'File',\r\n            entityId: filename,\r\n            changes: {\r\n              originalName: sanitizedFilename,\r\n              size: fileSize,\r\n              mimetype: part.mimetype\r\n            },\r\n            ipAddress: request.ip\r\n          }\r\n        });\r\n        \r\n        uploadedFiles.push({\r\n          originalName: sanitizedFilename,\r\n          filename: filename,\r\n          mimetype: part.mimetype,\r\n          size: fileSize,\r\n          url: `/uploads/${filename}`\r\n        });\r\n        \r\n        // TODO: Интеграция с MinIO для постоянного хранения\r\n      }\r\n    }\r\n    \r\n    return {\r\n      success: true,\r\n      data: uploadedFiles\r\n    };\r\n  }\r\n});\r\n\r\n// Статика для загруженных файлов\r\n// TODO: Временно отключено из-за несовместимости версий\r\n// fastify.register(require('@fastify/static'), {\r\n//   root: path.join(process.cwd(), 'uploads'),\r\n//   prefix: '/uploads/',\r\n//   decorateReply: false\r\n// });\r\n\r\n// Загружаем конфигурацию\r\nconst config = require('./config');\r\n\r\n// Proxy к сервисам\r\n// Auth service\r\nfastify.register(httpProxy, {\r\n  upstream: config.services.auth.url,\r\n  prefix: config.services.auth.prefix,\r\n  rewritePrefix: config.services.auth.prefix\r\n});\r\n\r\n// Machines service\r\nfastify.register(httpProxy, {\r\n  upstream: config.services.machines.url,\r\n  prefix: config.services.machines.prefix,\r\n  rewritePrefix: config.services.machines.prefix\r\n});\r\n\r\n// Inventory service\r\nfastify.register(httpProxy, {\r\n  upstream: config.services.inventory.url,\r\n  prefix: config.services.inventory.prefix,\r\n  rewritePrefix: config.services.inventory.prefix\r\n});\r\n\r\n// Tasks service\r\nfastify.register(httpProxy, {\r\n  upstream: config.services.tasks.url,\r\n  prefix: config.services.tasks.prefix,\r\n  rewritePrefix: config.services.tasks.prefix\r\n});\r\n\r\n// Bunkers service\r\nfastify.register(httpProxy, {\r\n  upstream: config.services.bunkers.url,\r\n  prefix: config.services.bunkers.prefix,\r\n  rewritePrefix: config.services.bunkers.prefix\r\n});\r\n\r\n// Routes service\r\nfastify.register(httpProxy, {\r\n  upstream: config.services.routes.url,\r\n  prefix: config.services.routes.prefix,\r\n  rewritePrefix: config.services.routes.prefix\r\n});\r\n\r\n// Warehouse service\r\nfastify.register(httpProxy, {\r\n  upstream: config.services.warehouse.url,\r\n  prefix: config.services.warehouse.prefix,\r\n  rewritePrefix: config.services.warehouse.prefix\r\n});\r\n\r\n// Notifications service\r\nfastify.register(httpProxy, {\r\n  upstream: config.services.notifications.url,\r\n  prefix: config.services.notifications.prefix,\r\n  rewritePrefix: config.services.notifications.prefix\r\n});\r\n\r\n// Monitoring service\r\nfastify.register(httpProxy, {\r\n  upstream: config.services.monitoring.url,\r\n  prefix: config.services.monitoring.prefix,\r\n  rewritePrefix: config.services.monitoring.prefix\r\n});\r\n\r\n// Backup service\r\nfastify.register(httpProxy, {\r\n  upstream: config.services.backup.url,\r\n  prefix: config.services.backup.prefix,\r\n  rewritePrefix: config.services.backup.prefix\r\n});\r\n\r\n// Audit service\r\nfastify.register(httpProxy, {\r\n  upstream: config.services.audit.url,\r\n  prefix: config.services.audit.prefix,\r\n  rewritePrefix: config.services.audit.prefix\r\n});\r\n\r\n// Dashboard stats endpoint\r\nfastify.get('/api/v1/dashboard/stats', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const [\r\n      totalMachines,\r\n      onlineMachines,\r\n      totalTasks,\r\n      pendingTasks,\r\n      totalUsers,\r\n      activeUsers,\r\n      inventoryItems,\r\n      lowStockItems\r\n    ] = await Promise.all([\r\n      prisma.machine.count(),\r\n      prisma.machine.count({ where: { status: 'ONLINE' } }),\r\n      prisma.task.count(),\r\n      prisma.task.count({ where: { status: { in: ['CREATED', 'ASSIGNED'] } } }),\r\n      prisma.user.count(),\r\n      prisma.user.count({ where: { isActive: true } }),\r\n      prisma.inventoryItem.count(),\r\n      prisma.inventoryItem.count({ \r\n        where: { \r\n          quantity: { lte: 10 } // TODO: Сделать динамическим из поля minQuantity\r\n        } \r\n      })\r\n    ]);\r\n    \r\n    // Получаем последние транзакции\r\n    const recentTransactions = await prisma.transaction.findMany({\r\n      take: 5,\r\n      orderBy: { createdAt: 'desc' }\r\n    });\r\n    \r\n    // Считаем выручку за сегодня\r\n    const todayStart = new Date();\r\n    todayStart.setHours(0, 0, 0, 0);\r\n    \r\n    const todayRevenue = await prisma.transaction.aggregate({\r\n      where: {\r\n        createdAt: { gte: todayStart },\r\n        status: 'SUCCESS'\r\n      },\r\n      _sum: { amount: true }\r\n    });\r\n    \r\n    const stats = {\r\n      totalMachines,\r\n      onlineMachines,\r\n      totalTasks,\r\n      pendingTasks,\r\n      totalUsers,\r\n      activeUsers,\r\n      inventoryItems,\r\n      lowStockItems,\r\n      todayRevenue: todayRevenue._sum.amount || 0,\r\n      totalRevenue: 156789.50, // TODO: Вычислить из БД\r\n      recentTransactions\r\n    };\r\n    \r\n    // Отправляем обновление через WebSocket\r\n    broadcastToClients('stats_update', stats);\r\n    \r\n    return {\r\n      success: true,\r\n      data: stats\r\n    };\r\n  } catch (error) {\r\n    throw createError.database('Failed to fetch dashboard stats');\r\n  }\r\n});\r\n\r\n// Тестовый endpoint для проверки базы данных\r\nfastify.get('/api/v1/test-db', async (request, reply) => {\r\n  try {\r\n    const [machines, tasks, users] = await Promise.all([\r\n      prisma.machine.count(),\r\n      prisma.task.count(),\r\n      prisma.user.count()\r\n    ]);\r\n    \r\n    return {\r\n      success: true,\r\n      data: {\r\n        machines,\r\n        tasks,\r\n        users,\r\n        database: 'connected'\r\n      }\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error.message\r\n    };\r\n  }\r\n});\r\n\r\n// Audit log endpoint\r\nfastify.get('/api/v1/audit-log', {\r\n  preValidation: [fastify.authenticate]\r\n}, async (request, reply) => {\r\n  try {\r\n    const { entity, entityId, userId, from, to, skip = 0, take = 50 } = request.query;\r\n    \r\n    const where = {};\r\n    if (entity) where.entity = entity;\r\n    if (entityId) where.entityId = entityId;\r\n    if (userId) where.userId = userId;\r\n    \r\n    if (from || to) {\r\n      where.createdAt = {};\r\n      if (from) where.createdAt.gte = new Date(from);\r\n      if (to) where.createdAt.lte = new Date(to);\r\n    }\r\n    \r\n    const [logs, total] = await Promise.all([\r\n      prisma.auditLog.findMany({\r\n        where,\r\n        skip: parseInt(skip),\r\n        take: parseInt(take),\r\n        orderBy: { createdAt: 'desc' },\r\n        include: {\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true\r\n            }\r\n          }\r\n        }\r\n      }),\r\n      prisma.auditLog.count({ where })\r\n    ]);\r\n    \r\n    return {\r\n      success: true,\r\n      data: {\r\n        items: logs,\r\n        total,\r\n        skip: parseInt(skip),\r\n        take: parseInt(take)\r\n      }\r\n    };\r\n  } catch (error) {\r\n    throw createError.database('Failed to fetch audit logs');\r\n  }\r\n});\r\n\r\n// Start server\r\nconst start = async () => {\r\n  try {\r\n    // Создаем директорию для загрузок\r\n    const uploadDir = path.join(process.cwd(), 'uploads');\r\n    if (!fs.existsSync(uploadDir)) {\r\n      fs.mkdirSync(uploadDir, { recursive: true });\r\n    }\r\n    \r\n    const port = process.env.PORT || process.env.GATEWAY_PORT || 8000;\r\n    await fastify.listen({ \r\n      port: port,\r\n      host: '0.0.0.0'\r\n    });\r\n    console.log('Gateway is running on port', port);\r\n    console.log('WebSocket available at ws://localhost:' + port + '/ws');\r\n    \r\n    // Railway specific logging\r\n    if (process.env.RAILWAY_ENVIRONMENT) {\r\n      console.log('Running on Railway:', process.env.RAILWAY_STATIC_URL);\r\n    }\r\n  } catch (err) {\r\n    fastify.log.error(err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\nstart();\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGTERM', async () => {\r\n  // Закрываем все WebSocket соединения\r\n  wsClients.forEach(client => {\r\n    client.close();\r\n  });\r\n  \r\n  await fastify.close();\r\n  await prisma.$disconnect();\r\n  process.exit(0);\r\n});\r\n\r\n// Экспорт функции broadcast для использования в других модулях\r\nmodule.exports = { broadcastToClients };\r\n",
  "services/notifications/src/services/notificationService.js": "/**\r\n * VHM24 Notification Service\r\n * Централизованная система уведомлений с поддержкой различных каналов\r\n */\r\n\r\nconst { getPrismaClient } = require('@vhm24/database');\r\nconst TelegramBot = require('node-telegram-bot-api');\r\nconst nodemailer = require('nodemailer');\r\nconst winston = require('winston');\r\n\r\nclass NotificationService {\r\n  constructor() {\r\n    this.prisma = getPrismaClient();\r\n    this.logger = winston.createLogger({\r\n      level: 'info',\r\n      format: winston.format.combine(\r\n        winston.format.timestamp(),\r\n        winston.format.json()\r\n      ),\r\n      transports: [\r\n        new winston.transports.Console(),\r\n        new winston.transports.File({ filename: 'notifications.log' })\r\n      ]\r\n    });\r\n\r\n    // Инициализация Telegram бота для уведомлений\r\n    if (process.env.TELEGRAM_BOT_TOKEN) {\r\n      this.telegramBot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN);\r\n    }\r\n\r\n    // Инициализация email транспорта\r\n    this.emailTransporter = nodemailer.createTransport({\r\n      host: process.env.SMTP_HOST || 'smtp.gmail.com',\r\n      port: process.env.SMTP_PORT || 587,\r\n      secure: false,\r\n      auth: {\r\n        user: process.env.SMTP_USER,\r\n        pass: process.env.SMTP_PASS\r\n      }\r\n    });\r\n\r\n    // Типы уведомлений\r\n    this.notificationTypes = {\r\n      TASK_OVERDUE: {\r\n        priority: 'HIGH',\r\n        channels: ['telegram', 'email'],\r\n        template: 'task_overdue'\r\n      },\r\n      LOW_STOCK: {\r\n        priority: 'MEDIUM',\r\n        channels: ['telegram'],\r\n        template: 'low_stock'\r\n      },\r\n      MACHINE_OFFLINE: {\r\n        priority: 'HIGH',\r\n        channels: ['telegram', 'email'],\r\n        template: 'machine_offline'\r\n      },\r\n      ROUTE_COMPLETED: {\r\n        priority: 'LOW',\r\n        channels: ['telegram'],\r\n        template: 'route_completed'\r\n      },\r\n      MAINTENANCE_DUE: {\r\n        priority: 'MEDIUM',\r\n        channels: ['telegram', 'email'],\r\n        template: 'maintenance_due'\r\n      },\r\n      INCOMPLETE_DATA: {\r\n        priority: 'MEDIUM',\r\n        channels: ['telegram'],\r\n        template: 'incomplete_data'\r\n      },\r\n      SYSTEM_ALERT: {\r\n        priority: 'HIGH',\r\n        channels: ['telegram', 'email'],\r\n        template: 'system_alert'\r\n      },\r\n      FUEL_REPORT: {\r\n        priority: 'LOW',\r\n        channels: ['telegram'],\r\n        template: 'fuel_report'\r\n      },\r\n      ARRIVAL_CONFIRMATION: {\r\n        priority: 'LOW',\r\n        channels: ['telegram'],\r\n        template: 'arrival_confirmation'\r\n      },\r\n      WAREHOUSE_RECEIPT: {\r\n        priority: 'MEDIUM',\r\n        channels: ['telegram'],\r\n        template: 'warehouse_receipt'\r\n      }\r\n    };\r\n\r\n    // Шаблоны сообщений\r\n    this.templates = {\r\n      task_overdue: {\r\n        telegram: '⚠️ *Просроченная задача*\\n\\n📋 {taskTitle}\\n👤 Исполнитель: {assignee}\\n⏰ Просрочена на: {overdueDays} дн.\\n\\n🔗 Перейти к задаче: /task_{taskId}',\r\n        email: {\r\n          subject: 'Просроченная задача: {taskTitle}',\r\n          html: '<h2>Просроченная задача</h2><p><strong>Задача:</strong> {taskTitle}</p><p><strong>Исполнитель:</strong> {assignee}</p><p><strong>Просрочена на:</strong> {overdueDays} дней</p>'\r\n        }\r\n      },\r\n      low_stock: {\r\n        telegram: '📦 *Низкий остаток товара*\\n\\n🏷️ {itemName}\\n📊 Остаток: {quantity} {unit}\\n⚠️ Минимум: {minQuantity} {unit}\\n📍 Склад: {warehouse}',\r\n        email: {\r\n          subject: 'Низкий остаток: {itemName}',\r\n          html: '<h2>Низкий остаток товара</h2><p><strong>Товар:</strong> {itemName}</p><p><strong>Остаток:</strong> {quantity} {unit}</p>'\r\n        }\r\n      },\r\n      machine_offline: {\r\n        telegram: '🚨 *Автомат не в сети*\\n\\n🤖 {machineName}\\n📍 {location}\\n⏰ Не в сети: {offlineTime}\\n\\n🔧 Требуется проверка',\r\n        email: {\r\n          subject: 'Автомат не в сети: {machineName}',\r\n          html: '<h2>Автомат не в сети</h2><p><strong>Автомат:</strong> {machineName}</p><p><strong>Адрес:</strong> {location}</p>'\r\n        }\r\n      },\r\n      route_completed: {\r\n        telegram: '✅ *Маршрут завершен*\\n\\n🚛 {routeName}\\n👤 Водитель: {driverName}\\n⏰ Время: {completionTime}\\n📊 Остановок: {stopsCount}',\r\n        email: {\r\n          subject: 'Маршрут завершен: {routeName}',\r\n          html: '<h2>Маршрут завершен</h2><p><strong>Маршрут:</strong> {routeName}</p><p><strong>Водитель:</strong> {driverName}</p>'\r\n        }\r\n      },\r\n      maintenance_due: {\r\n        telegram: '🔧 *Требуется техобслуживание*\\n\\n🤖 {machineName}\\n📍 {location}\\n📅 Плановая дата: {dueDate}\\n⚠️ Просрочка: {overdueDays} дн.',\r\n        email: {\r\n          subject: 'Требуется ТО: {machineName}',\r\n          html: '<h2>Требуется техническое обслуживание</h2><p><strong>Автомат:</strong> {machineName}</p><p><strong>Плановая дата:</strong> {dueDate}</p>'\r\n        }\r\n      },\r\n      incomplete_data: {\r\n        telegram: '📝 *Незаполненные данные*\\n\\n👤 Пользователь: {userName}\\n📋 Поля: {missingFields}\\n⏰ Время: {timestamp}',\r\n        email: {\r\n          subject: 'Незаполненные данные от {userName}',\r\n          html: '<h2>Незаполненные данные</h2><p><strong>Пользователь:</strong> {userName}</p><p><strong>Поля:</strong> {missingFields}</p>'\r\n        }\r\n      },\r\n      system_alert: {\r\n        telegram: '🚨 *Системное уведомление*\\n\\n⚠️ {alertType}\\n📝 {message}\\n⏰ {timestamp}',\r\n        email: {\r\n          subject: 'Системное уведомление: {alertType}',\r\n          html: '<h2>Системное уведомление</h2><p><strong>Тип:</strong> {alertType}</p><p><strong>Сообщение:</strong> {message}</p>'\r\n        }\r\n      },\r\n      fuel_report: {\r\n        telegram: '⛽ *Отчет о заправке*\\n\\n🚛 Водитель: {driverName}\\n💰 Сумма: {amount} сум\\n📍 Локация: {location}\\n⏰ {timestamp}',\r\n        email: {\r\n          subject: 'Отчет о заправке от {driverName}',\r\n          html: '<h2>Отчет о заправке</h2><p><strong>Водитель:</strong> {driverName}</p><p><strong>Сумма:</strong> {amount} сум</p>'\r\n        }\r\n      },\r\n      arrival_confirmation: {\r\n        telegram: '📍 *Подтверждение прибытия*\\n\\n👤 {driverName}\\n🎯 {stopName}\\n📍 {location}\\n⏰ {arrivalTime}',\r\n        email: {\r\n          subject: 'Прибытие: {driverName} - {stopName}',\r\n          html: '<h2>Подтверждение прибытия</h2><p><strong>Водитель:</strong> {driverName}</p><p><strong>Остановка:</strong> {stopName}</p>'\r\n        }\r\n      },\r\n      warehouse_receipt: {\r\n        telegram: '📦 *Поступление на склад*\\n\\n🏷️ {itemName}\\n📊 Количество: {quantity} {unit}\\n👤 Принял: {receiverName}\\n⏰ {timestamp}',\r\n        email: {\r\n          subject: 'Поступление: {itemName}',\r\n          html: '<h2>Поступление на склад</h2><p><strong>Товар:</strong> {itemName}</p><p><strong>Количество:</strong> {quantity} {unit}</p>'\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Отправка уведомления\r\n   */\r\n  async sendNotification(type, recipients, data, options = {}) {\r\n    try {\r\n      const notificationConfig = this.notificationTypes[type];\r\n      if (!notificationConfig) {\r\n        throw new Error(`Unknown notification type: ${type}`);\r\n      }\r\n\r\n      // Создаем запись в базе данных (если таблица существует)\r\n      let notification = null;\r\n      try {\r\n        notification = await this.prisma.notification.create({\r\n          data: {\r\n            type,\r\n            title: this.generateTitle(type, data),\r\n            message: this.generateMessage(type, data, 'telegram'),\r\n            recipients: Array.isArray(recipients) ? recipients : [recipients],\r\n            priority: notificationConfig.priority,\r\n            channels: notificationConfig.channels,\r\n            data: data,\r\n            status: 'PENDING'\r\n          }\r\n        });\r\n      } catch (dbError) {\r\n        this.logger.warn('Database notification table not available, continuing without DB logging');\r\n      }\r\n\r\n      // Отправляем по всем каналам\r\n      const results = [];\r\n      for (const channel of notificationConfig.channels) {\r\n        if (options.channels && !options.channels.includes(channel)) {\r\n          continue;\r\n        }\r\n\r\n        try {\r\n          const result = await this.sendByChannel(channel, type, recipients, data);\r\n          results.push({ channel, success: true, result });\r\n        } catch (error) {\r\n          this.logger.error(`Failed to send ${type} via ${channel}:`, error);\r\n          results.push({ channel, success: false, error: error.message });\r\n        }\r\n      }\r\n\r\n      // Обновляем статус уведомления (если запись была создана)\r\n      const allSuccess = results.every(r => r.success);\r\n      if (notification) {\r\n        try {\r\n          await this.prisma.notification.update({\r\n            where: { id: notification.id },\r\n            data: {\r\n              status: allSuccess ? 'SENT' : 'FAILED',\r\n              sentAt: allSuccess ? new Date() : null,\r\n              deliveryResults: results\r\n            }\r\n          });\r\n        } catch (updateError) {\r\n          this.logger.warn('Failed to update notification status in database');\r\n        }\r\n      }\r\n\r\n      return {\r\n        notificationId: notification?.id || 'no-db',\r\n        success: allSuccess,\r\n        results\r\n      };\r\n\r\n    } catch (error) {\r\n      this.logger.error('Send notification error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Отправка по конкретному каналу\r\n   */\r\n  async sendByChannel(channel, type, recipients, data) {\r\n    switch (channel) {\r\n      case 'telegram':\r\n        return await this.sendTelegram(type, recipients, data);\r\n      case 'email':\r\n        return await this.sendEmail(type, recipients, data);\r\n      case 'sms':\r\n        return await this.sendSMS(type, recipients, data);\r\n      default:\r\n        throw new Error(`Unsupported channel: ${channel}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Отправка Telegram уведомления\r\n   */\r\n  async sendTelegram(type, recipients, data) {\r\n    if (!this.telegramBot) {\r\n      throw new Error('Telegram bot not configured');\r\n    }\r\n\r\n    const message = this.generateMessage(type, data, 'telegram');\r\n    const results = [];\r\n\r\n    for (const recipient of Array.isArray(recipients) ? recipients : [recipients]) {\r\n      try {\r\n        // Получаем Telegram ID пользователя\r\n        const user = await this.prisma.user.findFirst({\r\n          where: {\r\n            OR: [\r\n              { id: recipient },\r\n              { email: recipient },\r\n              { telegramId: recipient }\r\n            ]\r\n          }\r\n        });\r\n\r\n        if (!user?.telegramId) {\r\n          throw new Error(`No Telegram ID for recipient: ${recipient}`);\r\n        }\r\n\r\n        await this.telegramBot.sendMessage(user.telegramId, message, {\r\n          parse_mode: 'Markdown',\r\n          disable_web_page_preview: true\r\n        });\r\n\r\n        results.push({ recipient, success: true });\r\n      } catch (error) {\r\n        results.push({ recipient, success: false, error: error.message });\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Отправка Email уведомления\r\n   */\r\n  async sendEmail(type, recipients, data) {\r\n    if (!this.emailTransporter) {\r\n      throw new Error('Email transporter not configured');\r\n    }\r\n\r\n    const template = this.templates[this.notificationTypes[type].template]?.email;\r\n    if (!template) {\r\n      throw new Error(`No email template for type: ${type}`);\r\n    }\r\n\r\n    const subject = this.interpolateTemplate(template.subject, data);\r\n    const html = this.interpolateTemplate(template.html, data);\r\n\r\n    const results = [];\r\n\r\n    for (const recipient of Array.isArray(recipients) ? recipients : [recipients]) {\r\n      try {\r\n        // Получаем email пользователя\r\n        let email = recipient;\r\n        if (!recipient.includes('@')) {\r\n          const user = await this.prisma.user.findFirst({\r\n            where: { id: recipient }\r\n          });\r\n          email = user?.email;\r\n        }\r\n\r\n        if (!email) {\r\n          throw new Error(`No email for recipient: ${recipient}`);\r\n        }\r\n\r\n        await this.emailTransporter.sendMail({\r\n          from: process.env.SMTP_FROM || 'noreply@vhm24.com',\r\n          to: email,\r\n          subject,\r\n          html\r\n        });\r\n\r\n        results.push({ recipient, success: true });\r\n      } catch (error) {\r\n        results.push({ recipient, success: false, error: error.message });\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Отправка SMS уведомления (заглушка)\r\n   */\r\n  async sendSMS(type, recipients, data) {\r\n    // TODO: Интеграция с SMS провайдером\r\n    this.logger.info('SMS sending not implemented yet');\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Генерация заголовка уведомления\r\n   */\r\n  generateTitle(type, data) {\r\n    const titles = {\r\n      TASK_OVERDUE: `Просроченная задача: ${data.taskTitle}`,\r\n      LOW_STOCK: `Низкий остаток: ${data.itemName}`,\r\n      MACHINE_OFFLINE: `Автомат не в сети: ${data.machineName}`,\r\n      ROUTE_COMPLETED: `Маршрут завершен: ${data.routeName}`,\r\n      MAINTENANCE_DUE: `Требуется ТО: ${data.machineName}`,\r\n      INCOMPLETE_DATA: `Незаполненные данные: ${data.userName}`,\r\n      SYSTEM_ALERT: `Системное уведомление: ${data.alertType}`,\r\n      FUEL_REPORT: `Заправка: ${data.driverName}`,\r\n      ARRIVAL_CONFIRMATION: `Прибытие: ${data.driverName}`,\r\n      WAREHOUSE_RECEIPT: `Поступление: ${data.itemName}`\r\n    };\r\n\r\n    return titles[type] || `Уведомление: ${type}`;\r\n  }\r\n\r\n  /**\r\n   * Генерация сообщения по шаблону\r\n   */\r\n  generateMessage(type, data, channel) {\r\n    const notificationConfig = this.notificationTypes[type];\r\n    const template = this.templates[notificationConfig.template]?.[channel];\r\n    \r\n    if (!template) {\r\n      return `Уведомление типа ${type}: ${JSON.stringify(data)}`;\r\n    }\r\n\r\n    return this.interpolateTemplate(template, data);\r\n  }\r\n\r\n  /**\r\n   * Интерполяция шаблона\r\n   */\r\n  interpolateTemplate(template, data) {\r\n    return template.replace(/\\{(\\w+)\\}/g, (match, key) => {\r\n      return data[key] !== undefined ? data[key] : match;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Массовая отправка уведомлений по расписанию\r\n   */\r\n  async sendScheduledNotifications() {\r\n    try {\r\n      // Проверяем просроченные задачи\r\n      await this.checkOverdueTasks();\r\n      \r\n      // Проверяем низкие остатки\r\n      await this.checkLowStock();\r\n      \r\n      // Проверяем офлайн автоматы\r\n      await this.checkOfflineMachines();\r\n      \r\n      // Проверяем просроченное ТО\r\n      await this.checkOverdueMaintenance();\r\n\r\n      this.logger.info('Scheduled notifications check completed');\r\n    } catch (error) {\r\n      this.logger.error('Scheduled notifications error:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка просроченных задач\r\n   */\r\n  async checkOverdueTasks() {\r\n    const overdueTasks = await this.prisma.task.findMany({\r\n      where: {\r\n        status: { in: ['CREATED', 'ASSIGNED', 'IN_PROGRESS'] },\r\n        dueDate: { lt: new Date() }\r\n      },\r\n      include: {\r\n        assignee: true\r\n      }\r\n    });\r\n\r\n    for (const task of overdueTasks) {\r\n      const overdueDays = Math.floor((new Date() - task.dueDate) / (1000 * 60 * 60 * 24));\r\n      \r\n      await this.sendNotification('TASK_OVERDUE', [task.assigneeId], {\r\n        taskId: task.id,\r\n        taskTitle: task.title,\r\n        assignee: task.assignee.name,\r\n        overdueDays\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка низких остатков\r\n   */\r\n  async checkLowStock() {\r\n    try {\r\n      // Получаем товары с низкими остатками\r\n      const lowStockItems = await this.prisma.inventoryItem.findMany({\r\n        where: {\r\n          AND: [\r\n            { quantity: { not: null } },\r\n            { minQuantity: { not: null } }\r\n          ]\r\n        }\r\n      });\r\n\r\n      // Фильтруем товары с низкими остатками\r\n      const filteredItems = lowStockItems.filter(item => \r\n        item.quantity <= (item.minQuantity || 0)\r\n      );\r\n\r\n      for (const item of filteredItems) {\r\n        // Отправляем менеджерам склада\r\n        const warehouseManagers = await this.prisma.user.findMany({\r\n          where: {\r\n            roles: { has: 'WAREHOUSE_MANAGER' },\r\n            isActive: true\r\n          }\r\n        });\r\n\r\n        for (const manager of warehouseManagers) {\r\n          await this.sendNotification('LOW_STOCK', [manager.id], {\r\n            itemName: item.name,\r\n            quantity: item.quantity,\r\n            unit: item.unit || 'шт',\r\n            minQuantity: item.minQuantity || 0,\r\n            warehouse: 'Основной склад'\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Check low stock error:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка офлайн автоматов\r\n   */\r\n  async checkOfflineMachines() {\r\n    const offlineThreshold = new Date(Date.now() - 30 * 60 * 1000); // 30 минут\r\n    \r\n    const offlineMachines = await this.prisma.machine.findMany({\r\n      where: {\r\n        lastPing: { lt: offlineThreshold },\r\n        status: { not: 'MAINTENANCE' }\r\n      }\r\n    });\r\n\r\n    for (const machine of offlineMachines) {\r\n      const offlineTime = Math.floor((new Date() - machine.lastPing) / (1000 * 60));\r\n      \r\n      // Отправляем техникам\r\n      const technicians = await this.prisma.user.findMany({\r\n        where: {\r\n          role: 'TECHNICIAN',\r\n          isActive: true\r\n        }\r\n      });\r\n\r\n      for (const technician of technicians) {\r\n        await this.sendNotification('MACHINE_OFFLINE', [technician.id], {\r\n          machineName: machine.name,\r\n          location: machine.location?.address || 'Адрес не указан',\r\n          offlineTime: `${offlineTime} мин`\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка просроченного ТО\r\n   */\r\n  async checkOverdueMaintenance() {\r\n    const overdueMaintenance = await this.prisma.maintenanceSchedule.findMany({\r\n      where: {\r\n        nextMaintenanceDate: { lt: new Date() },\r\n        status: 'SCHEDULED'\r\n      },\r\n      include: {\r\n        machine: true\r\n      }\r\n    });\r\n\r\n    for (const maintenance of overdueMaintenance) {\r\n      const overdueDays = Math.floor((new Date() - maintenance.nextMaintenanceDate) / (1000 * 60 * 60 * 24));\r\n      \r\n      // Отправляем техникам\r\n      const technicians = await this.prisma.user.findMany({\r\n        where: {\r\n          role: 'TECHNICIAN',\r\n          isActive: true\r\n        }\r\n      });\r\n\r\n      for (const technician of technicians) {\r\n        await this.sendNotification('MAINTENANCE_DUE', [technician.id], {\r\n          machineName: maintenance.machine.name,\r\n          location: maintenance.machine.location?.address || 'Адрес не указан',\r\n          dueDate: maintenance.nextMaintenanceDate.toLocaleDateString('ru-RU'),\r\n          overdueDays\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение истории уведомлений\r\n   */\r\n  async getNotificationHistory(filters = {}) {\r\n    const where = {};\r\n    \r\n    if (filters.type) where.type = filters.type;\r\n    if (filters.status) where.status = filters.status;\r\n    if (filters.priority) where.priority = filters.priority;\r\n    if (filters.dateFrom) where.createdAt = { gte: new Date(filters.dateFrom) };\r\n    if (filters.dateTo) where.createdAt = { ...where.createdAt, lte: new Date(filters.dateTo) };\r\n\r\n    return await this.prisma.notification.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n      take: filters.limit || 100,\r\n      skip: filters.offset || 0\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Статистика уведомлений\r\n   */\r\n  async getNotificationStats(period = '7d') {\r\n    const dateFrom = new Date();\r\n    if (period === '7d') dateFrom.setDate(dateFrom.getDate() - 7);\r\n    else if (period === '30d') dateFrom.setDate(dateFrom.getDate() - 30);\r\n    else if (period === '1y') dateFrom.setFullYear(dateFrom.getFullYear() - 1);\r\n\r\n    const stats = await this.prisma.notification.groupBy({\r\n      by: ['type', 'status'],\r\n      where: {\r\n        createdAt: { gte: dateFrom }\r\n      },\r\n      _count: true\r\n    });\r\n\r\n    return stats;\r\n  }\r\n}\r\n\r\nmodule.exports = NotificationService;\r\n",
  "services/telegram-bot/src/handlers/warehouseHandler.js": "/**\r\n * VHM24 Warehouse Handler with FSM\r\n * Обработчик для складских работников с поддержкой сканирования, взвешивания и фотофиксации\r\n */\r\n\r\nconst fsmManager = require('../fsm/manager');\r\nconst { WAREHOUSE_STATES, COMMON_STATES } = require('../fsm/states');\r\nconst qrScanner = require('../utils/qrScanner');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n/**\r\n * Главное меню складского работника\r\n */\r\nasync function showWarehouseMenu(bot, msg) {\r\n  const chatId = msg.chat.id;\r\n  const userId = msg.from.id;\r\n\r\n  try {\r\n    // Проверяем роль пользователя\r\n    const userInfo = await getUserInfo(userId);\r\n    if (!userInfo || !userInfo.roles.includes('WAREHOUSE')) {\r\n      await bot.sendMessage(chatId,\r\n        `❌ У вас нет прав складского работника. Обратитесь к администратору.`\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Получаем статистику склада\r\n    const stats = await getWarehouseStats();\r\n\r\n    let message = `📦 *Меню склада*\\n\\n`;\r\n    message += `📊 *Статистика:*\\n`;\r\n    message += `📦 Всего товаров: ${stats.totalItems || 0}\\n`;\r\n    message += `⚠️ Низкие остатки: ${stats.lowStock || 0}\\n`;\r\n    message += `📥 Поступлений сегодня: ${stats.todayReceived || 0}\\n`;\r\n    message += `📤 Отгружено сегодня: ${stats.todayShipped || 0}\\n\\n`;\r\n\r\n    const keyboards = [\r\n      [\r\n        { text: '📥 Приём товара', callback_data: 'warehouse_receive' },\r\n        { text: '📤 Отгрузка', callback_data: 'warehouse_ship' }\r\n      ],\r\n      [\r\n        { text: '🗃️ Заполнить бункер', callback_data: 'warehouse_fill_bunker' },\r\n        { text: '⚖️ Взвешивание', callback_data: 'warehouse_weigh' }\r\n      ],\r\n      [\r\n        { text: '📋 Инвентаризация', callback_data: 'warehouse_inventory' },\r\n        { text: '📊 Остатки', callback_data: 'warehouse_stock' }\r\n      ],\r\n      [\r\n        { text: '📸 Фото отчёт', callback_data: 'warehouse_photo_report' },\r\n        { text: '🔄 Обновить', callback_data: 'warehouse_refresh' }\r\n      ],\r\n      [\r\n        { text: '🔙 Главное меню', callback_data: 'main_menu' }\r\n      ]\r\n    ];\r\n\r\n    await bot.sendMessage(chatId, message, {\r\n      parse_mode: 'Markdown',\r\n      reply_markup: {\r\n        inline_keyboard: keyboards\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    global.logger.error('Warehouse menu error:', error);\r\n    await bot.sendMessage(chatId,\r\n      `❌ Ошибка при загрузке меню склада. Попробуйте позже.`\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Приём товара\r\n */\r\nasync function receiveItems(bot, callbackQuery) {\r\n  const chatId = callbackQuery.message.chat.id;\r\n  const userId = callbackQuery.from.id;\r\n\r\n  try {\r\n    await fsmManager.setUserState(userId, WAREHOUSE_STATES.WAITING_ITEM_SCAN);\r\n    await fsmManager.setUserData(userId, {\r\n      action: 'receive_items',\r\n      items: []\r\n    });\r\n\r\n    await bot.editMessageText(\r\n      `📥 *Приём товара*\\n\\n` +\r\n      `📱 Отсканируйте штрих-код товара или введите артикул:\\n\\n` +\r\n      `💡 *Поддерживаемые форматы:*\\n` +\r\n      `• Штрих-код (фото)\\n` +\r\n      `• Артикул (текст)\\n` +\r\n      `• QR-код (фото)`,\r\n      {\r\n        chat_id: chatId,\r\n        message_id: callbackQuery.message.message_id,\r\n        parse_mode: 'Markdown',\r\n        reply_markup: {\r\n          inline_keyboard: [\r\n            [{ text: '📸 Сканировать штрих-код', callback_data: 'warehouse_scan_barcode' }],\r\n            [{ text: '❌ Отмена', callback_data: 'warehouse_cancel' }]\r\n          ]\r\n        }\r\n      }\r\n    );\r\n\r\n    await bot.answerCallbackQuery(callbackQuery.id);\r\n\r\n  } catch (error) {\r\n    global.logger.error('Receive items error:', error);\r\n    await bot.answerCallbackQuery(callbackQuery.id, {\r\n      text: '❌ Ошибка при начале приёма товара',\r\n      show_alert: true\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Обработка сканирования товара\r\n */\r\nasync function handleItemScan(bot, msg) {\r\n  const chatId = msg.chat.id;\r\n  const userId = msg.from.id;\r\n\r\n  try {\r\n    const currentState = await fsmManager.getUserState(userId);\r\n    \r\n    if (currentState !== WAREHOUSE_STATES.WAITING_ITEM_SCAN) {\r\n      return false;\r\n    }\r\n\r\n    let itemCode = null;\r\n\r\n    // Обработка фото (штрих-код/QR-код)\r\n    if (msg.photo) {\r\n      await bot.sendMessage(chatId, `📸 Фото получено. Распознавание QR-кода...`);\r\n      \r\n      try {\r\n        // Получаем информацию о файле\r\n        const photo = msg.photo[msg.photo.length - 1]; // Берем самое большое фото\r\n        const fileInfo = await bot.getFile(photo.file_id);\r\n        const fileUrl = `https://api.telegram.org/file/bot${process.env.TELEGRAM_BOT_TOKEN}/${fileInfo.file_path}`;\r\n        \r\n        // Создаем временную директорию, если она не существует\r\n        const tempDir = path.join(__dirname, '../../../temp');\r\n        if (!fs.existsSync(tempDir)) {\r\n          fs.mkdirSync(tempDir, { recursive: true });\r\n        }\r\n        \r\n        // Скачиваем файл\r\n        const axios = require('axios');\r\n        const response = await axios({\r\n          method: 'GET',\r\n          url: fileUrl,\r\n          responseType: 'arraybuffer'\r\n        });\r\n        \r\n        // Сохраняем файл\r\n        const tempFilePath = path.join(tempDir, `temp_${Date.now()}.jpg`);\r\n        fs.writeFileSync(tempFilePath, response.data);\r\n        \r\n        // Распознаем QR-код\r\n        const qrData = await qrScanner.scanQRCodeFromFile(tempFilePath);\r\n        \r\n        // Удаляем временный файл\r\n        fs.unlinkSync(tempFilePath);\r\n        \r\n        if (qrData) {\r\n          // Парсим данные QR-кода\r\n          const parsedData = qrScanner.parseQRData(qrData);\r\n          \r\n          if (parsedData.success) {\r\n            global.logger.info('QR code detected:', parsedData);\r\n            \r\n            // Обрабатываем разные типы QR-кодов\r\n            if (parsedData.type === 'inventory') {\r\n              // Получаем ID товара\r\n              const itemId = parsedData.data.id;\r\n              \r\n              // Ищем товар по ID\r\n              const item = await findItemById(itemId);\r\n              \r\n              if (item) {\r\n                // Переходим к вводу количества\r\n                await fsmManager.setUserState(userId, WAREHOUSE_STATES.WAITING_QUANTITY_INPUT);\r\n                await fsmManager.updateUserData(userId, {\r\n                  currentItem: item\r\n                });\r\n                \r\n                await bot.sendMessage(chatId,\r\n                  `✅ *Товар найден по QR-коду:*\\n\\n` +\r\n                  `📦 ${item.name}\\n` +\r\n                  `🏷️ Артикул: ${item.sku}\\n` +\r\n                  `📊 Текущий остаток: ${item.quantity} ${item.unit}\\n\\n` +\r\n                  `📝 Введите количество для приёма:`,\r\n                  { \r\n                    parse_mode: 'Markdown',\r\n                    reply_markup: {\r\n                      inline_keyboard: [\r\n                        [{ text: '❌ Отмена', callback_data: 'warehouse_cancel' }]\r\n                      ]\r\n                    }\r\n                  }\r\n                );\r\n                \r\n                return true;\r\n              }\r\n            } else if (parsedData.type === 'machine') {\r\n              // Получаем ID машины\r\n              const machineId = parsedData.data.id;\r\n              \r\n              await bot.sendMessage(chatId,\r\n                `✅ *Распознан QR-код машины:*\\n\\n` +\r\n                `🆔 ID: ${machineId}\\n\\n` +\r\n                `⚠️ Для приёма товара необходимо отсканировать QR-код товара или ввести артикул.`\r\n              );\r\n              \r\n              return true;\r\n            } else if (parsedData.type === 'task') {\r\n              // Получаем ID задачи\r\n              const taskId = parsedData.data.id;\r\n              \r\n              await bot.sendMessage(chatId,\r\n                `✅ *Распознан QR-код задачи:*\\n\\n` +\r\n                `🆔 ID: ${taskId}\\n\\n` +\r\n                `⚠️ Для приёма товара необходимо отсканировать QR-код товара или ввести артикул.`\r\n              );\r\n              \r\n              return true;\r\n            } else {\r\n              // Неизвестный тип QR-кода\r\n              await bot.sendMessage(chatId,\r\n                `⚠️ Распознан QR-код неизвестного типа.\\n\\n` +\r\n                `Пожалуйста, отсканируйте QR-код товара или введите артикул вручную:`\r\n              );\r\n              \r\n              return true;\r\n            }\r\n          }\r\n        }\r\n        \r\n        // Если QR-код не распознан или не найден товар\r\n        await bot.sendMessage(chatId,\r\n          `⚠️ QR-код не распознан или товар не найден.\\n\\n` +\r\n          `Пожалуйста, введите артикул товара вручную:`\r\n        );\r\n      } catch (error) {\r\n        global.logger.error('QR code scanning error:', error);\r\n        await bot.sendMessage(chatId,\r\n          `❌ Ошибка при распознавании QR-кода.\\n\\n` +\r\n          `Пожалуйста, введите артикул товара вручную:`\r\n        );\r\n      }\r\n      \r\n      return true;\r\n    }\r\n\r\n    // Обработка текста (артикул)\r\n    if (msg.text) {\r\n      itemCode = msg.text.trim();\r\n    }\r\n\r\n    if (!itemCode) {\r\n      await bot.sendMessage(chatId,\r\n        `❌ Пожалуйста, отправьте фото штрих-кода или введите артикул товара.`\r\n      );\r\n      return true;\r\n    }\r\n\r\n    // Поиск товара в базе\r\n    const item = await findItemByCode(itemCode);\r\n    \r\n    if (!item) {\r\n      await bot.sendMessage(chatId,\r\n        `❌ Товар с артикулом \"${itemCode}\" не найден.\\n\\n` +\r\n        `Попробуйте еще раз или обратитесь к администратору.`\r\n      );\r\n      return true;\r\n    }\r\n\r\n    // Переходим к вводу количества\r\n    await fsmManager.setUserState(userId, WAREHOUSE_STATES.WAITING_QUANTITY_INPUT);\r\n    await fsmManager.updateUserData(userId, {\r\n      currentItem: item\r\n    });\r\n\r\n    await bot.sendMessage(chatId,\r\n      `✅ *Товар найден:*\\n\\n` +\r\n      `📦 ${item.name}\\n` +\r\n      `🏷️ Артикул: ${item.sku}\\n` +\r\n      `📊 Текущий остаток: ${item.quantity} ${item.unit}\\n\\n` +\r\n      `📝 Введите количество для приёма:`,\r\n      { \r\n        parse_mode: 'Markdown',\r\n        reply_markup: {\r\n          inline_keyboard: [\r\n            [{ text: '❌ Отмена', callback_data: 'warehouse_cancel' }]\r\n          ]\r\n        }\r\n      }\r\n    );\r\n\r\n    return true;\r\n  } catch (error) {\r\n    global.logger.error('Handle item scan error:', error);\r\n    await bot.sendMessage(chatId,\r\n      `❌ Ошибка при обработке товара. Попробуйте еще раз.`\r\n    );\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Обработка ввода количества\r\n */\r\nasync function handleQuantityInput(bot, msg) {\r\n  const chatId = msg.chat.id;\r\n  const userId = msg.from.id;\r\n\r\n  try {\r\n    const currentState = await fsmManager.getUserState(userId);\r\n    \r\n    if (currentState !== WAREHOUSE_STATES.WAITING_QUANTITY_INPUT) {\r\n      return false;\r\n    }\r\n\r\n    const quantityText = msg.text;\r\n    const quantity = parseFloat(quantityText);\r\n\r\n    if (isNaN(quantity) || quantity <= 0) {\r\n      await bot.sendMessage(chatId,\r\n        `❌ Некорректное количество. Введите положительное число (например: 10 или 5.5):`\r\n      );\r\n      return true;\r\n    }\r\n\r\n    const userData = await fsmManager.getUserData(userId);\r\n    const item = userData.currentItem;\r\n\r\n    // Переходим к фото подтверждению\r\n    await fsmManager.setUserState(userId, WAREHOUSE_STATES.WAITING_BUNKER_PHOTO);\r\n    await fsmManager.updateUserData(userId, {\r\n      quantity: quantity\r\n    });\r\n\r\n    await bot.sendMessage(chatId,\r\n      `📝 *Подтверждение приёма:*\\n\\n` +\r\n      `📦 Товар: ${item.name}\\n` +\r\n      `📊 Количество: ${quantity} ${item.unit}\\n\\n` +\r\n      `📸 Сделайте фото товара для подтверждения:`,\r\n      { \r\n        parse_mode: 'Markdown',\r\n        reply_markup: {\r\n          inline_keyboard: [\r\n            [{ text: '✅ Принять без фото', callback_data: 'warehouse_accept_no_photo' }],\r\n            [{ text: '❌ Отмена', callback_data: 'warehouse_cancel' }]\r\n          ]\r\n        }\r\n      }\r\n    );\r\n\r\n    return true;\r\n  } catch (error) {\r\n    global.logger.error('Handle quantity input error:', error);\r\n    await bot.sendMessage(chatId,\r\n      `❌ Ошибка при обработке количества. Попробуйте еще раз.`\r\n    );\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Обработка фото подтверждения\r\n */\r\nasync function handleConfirmationPhoto(bot, msg) {\r\n  const chatId = msg.chat.id;\r\n  const userId = msg.from.id;\r\n\r\n  try {\r\n    const currentState = await fsmManager.getUserState(userId);\r\n    \r\n    if (currentState !== WAREHOUSE_STATES.WAITING_BUNKER_PHOTO) {\r\n      return false;\r\n    }\r\n\r\n    if (!msg.photo || msg.photo.length === 0) {\r\n      await bot.sendMessage(chatId,\r\n        `❌ Пожалуйста, отправьте фото товара для подтверждения.`\r\n      );\r\n      return true;\r\n    }\r\n\r\n    const userData = await fsmManager.getUserData(userId);\r\n    const item = userData.currentItem;\r\n    const quantity = userData.quantity;\r\n\r\n    // Получаем URL фото\r\n    const photo = msg.photo[msg.photo.length - 1];\r\n    const fileInfo = await bot.getFile(photo.file_id);\r\n    const photoUrl = `https://api.telegram.org/file/bot${bot.token}/${fileInfo.file_path}`;\r\n\r\n    // Создаем движение товара\r\n    const stockMovement = await global.apiClient.post('/stock-movements', {\r\n      itemId: item.id,\r\n      type: 'IN',\r\n      quantity: quantity,\r\n      reason: 'Приём товара на склад',\r\n      reference: `Telegram-${Date.now()}`,\r\n      metadata: {\r\n        telegramUserId: userId,\r\n        photoUrl: photoUrl,\r\n        telegramFileId: photo.file_id\r\n      }\r\n    });\r\n\r\n    if (stockMovement.data.success) {\r\n      await bot.sendMessage(chatId,\r\n        `✅ *Товар принят на склад!*\\n\\n` +\r\n        `📦 ${item.name}\\n` +\r\n        `📊 Принято: ${quantity} ${item.unit}\\n` +\r\n        `📸 Фото сохранено\\n` +\r\n        `⏰ Время: ${new Date().toLocaleTimeString('ru-RU')}\\n\\n` +\r\n        `🆔 Номер операции: ${stockMovement.data.data.id}`,\r\n        { parse_mode: 'Markdown' }\r\n      );\r\n    } else {\r\n      throw new Error('Failed to create stock movement');\r\n    }\r\n\r\n    await fsmManager.clearUserState(userId);\r\n    await showWarehouseMenu(bot, msg);\r\n\r\n    return true;\r\n  } catch (error) {\r\n    global.logger.error('Handle confirmation photo error:', error);\r\n    await bot.sendMessage(chatId,\r\n      `❌ Ошибка при сохранении товара. Попробуйте еще раз.`\r\n    );\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Заполнение бункера\r\n */\r\nasync function fillBunker(bot, callbackQuery) {\r\n  const chatId = callbackQuery.message.chat.id;\r\n  const userId = callbackQuery.from.id;\r\n\r\n  try {\r\n    // Получаем список доступных бункеров\r\n    const bunkers = await getAvailableBunkers();\r\n\r\n    if (bunkers.length === 0) {\r\n      await bot.answerCallbackQuery(callbackQuery.id, {\r\n        text: '❌ Нет доступных бункеров',\r\n        show_alert: true\r\n      });\r\n      return;\r\n    }\r\n\r\n    let message = `🗃️ *Заполнение бункера*\\n\\n`;\r\n    message += `Выберите бункер для заполнения:\\n\\n`;\r\n\r\n    const keyboards = [];\r\n    bunkers.forEach((bunker, index) => {\r\n      keyboards.push([{\r\n        text: `🗃️ ${bunker.machine.name} - ${bunker.item.name}`,\r\n        callback_data: `warehouse_select_bunker:${bunker.id}`\r\n      }]);\r\n    });\r\n\r\n    keyboards.push([{ text: '❌ Отмена', callback_data: 'warehouse_cancel' }]);\r\n\r\n    await bot.editMessageText(message, {\r\n      chat_id: chatId,\r\n      message_id: callbackQuery.message.message_id,\r\n      parse_mode: 'Markdown',\r\n      reply_markup: {\r\n        inline_keyboard: keyboards\r\n      }\r\n    });\r\n\r\n    await bot.answerCallbackQuery(callbackQuery.id);\r\n\r\n  } catch (error) {\r\n    global.logger.error('Fill bunker error:', error);\r\n    await bot.answerCallbackQuery(callbackQuery.id, {\r\n      text: '❌ Ошибка при загрузке бункеров',\r\n      show_alert: true\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Взвешивание товара\r\n */\r\nasync function weighItems(bot, callbackQuery) {\r\n  const chatId = callbackQuery.message.chat.id;\r\n  const userId = callbackQuery.from.id;\r\n\r\n  try {\r\n    await fsmManager.setUserState(userId, WAREHOUSE_STATES.WAITING_WEIGHT_INPUT);\r\n    await fsmManager.setUserData(userId, {\r\n      action: 'weigh_items'\r\n    });\r\n\r\n    await bot.editMessageText(\r\n      `⚖️ *Взвешивание товара*\\n\\n` +\r\n      `📝 Введите вес товара в килограммах:\\n\\n` +\r\n      `💡 Примеры: 5.2, 10, 0.5`,\r\n      {\r\n        chat_id: chatId,\r\n        message_id: callbackQuery.message.message_id,\r\n        parse_mode: 'Markdown',\r\n        reply_markup: {\r\n          inline_keyboard: [\r\n            [{ text: '❌ Отмена', callback_data: 'warehouse_cancel' }]\r\n          ]\r\n        }\r\n      }\r\n    );\r\n\r\n    await bot.answerCallbackQuery(callbackQuery.id);\r\n\r\n  } catch (error) {\r\n    global.logger.error('Weigh items error:', error);\r\n    await bot.answerCallbackQuery(callbackQuery.id, {\r\n      text: '❌ Ошибка при начале взвешивания',\r\n      show_alert: true\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Обработка ввода веса\r\n */\r\nasync function handleWeightInput(bot, msg) {\r\n  const chatId = msg.chat.id;\r\n  const userId = msg.from.id;\r\n\r\n  try {\r\n    const currentState = await fsmManager.getUserState(userId);\r\n    \r\n    if (currentState !== WAREHOUSE_STATES.WAITING_WEIGHT_INPUT) {\r\n      return false;\r\n    }\r\n\r\n    const weightText = msg.text;\r\n    const weight = parseFloat(weightText);\r\n\r\n    if (isNaN(weight) || weight <= 0) {\r\n      await bot.sendMessage(chatId,\r\n        `❌ Некорректный вес. Введите положительное число в килограммах:`\r\n      );\r\n      return true;\r\n    }\r\n\r\n    // Сохраняем результат взвешивания\r\n    const weighingResult = await global.apiClient.post('/warehouse-logs', {\r\n      type: 'WEIGHING',\r\n      description: `Взвешивание товара: ${weight} кг`,\r\n      weight: weight,\r\n      metadata: {\r\n        telegramUserId: userId,\r\n        timestamp: new Date().toISOString()\r\n      }\r\n    });\r\n\r\n    await bot.sendMessage(chatId,\r\n      `✅ *Взвешивание завершено!*\\n\\n` +\r\n      `⚖️ Вес: ${weight} кг\\n` +\r\n      `⏰ Время: ${new Date().toLocaleTimeString('ru-RU')}\\n\\n` +\r\n      `🆔 Номер записи: ${weighingResult.data.data?.id || 'N/A'}`,\r\n      { parse_mode: 'Markdown' }\r\n    );\r\n\r\n    await fsmManager.clearUserState(userId);\r\n    await showWarehouseMenu(bot, msg);\r\n\r\n    return true;\r\n  } catch (error) {\r\n    global.logger.error('Handle weight input error:', error);\r\n    await bot.sendMessage(chatId,\r\n      `❌ Ошибка при сохранении веса. Попробуйте еще раз.`\r\n    );\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Отмена текущего действия\r\n */\r\nasync function cancelAction(bot, callbackQuery) {\r\n  const userId = callbackQuery.from.id;\r\n  \r\n  try {\r\n    await fsmManager.clearUserState(userId);\r\n    \r\n    await bot.answerCallbackQuery(callbackQuery.id, {\r\n      text: '❌ Действие отменено'\r\n    });\r\n\r\n    await showWarehouseMenu(bot, {\r\n      chat: { id: callbackQuery.message.chat.id },\r\n      from: { id: userId }\r\n    });\r\n  } catch (error) {\r\n    global.logger.error('Cancel action error:', error);\r\n  }\r\n}\r\n\r\n// Вспомогательные функции\r\n\r\nasync function getUserInfo(userId) {\r\n  try {\r\n    const response = await global.apiClient.get('/auth/me');\r\n    return response.data.data;\r\n  } catch (error) {\r\n    return null;\r\n  }\r\n}\r\n\r\nasync function getWarehouseStats() {\r\n  try {\r\n    const response = await global.apiClient.get('/warehouse/stats');\r\n    return response.data.data || {};\r\n  } catch (error) {\r\n    return {};\r\n  }\r\n}\r\n\r\nasync function findItemByCode(code) {\r\n  try {\r\n    const response = await global.apiClient.get(`/inventory/items?sku=${code}`);\r\n    return response.data.data[0] || null;\r\n  } catch (error) {\r\n    return null;\r\n  }\r\n}\r\n\r\nasync function findItemById(id) {\r\n  try {\r\n    const response = await global.apiClient.get(`/inventory/items/${id}`);\r\n    return response.data.data || null;\r\n  } catch (error) {\r\n    return null;\r\n  }\r\n}\r\n\r\nasync function getAvailableBunkers() {\r\n  try {\r\n    const response = await global.apiClient.get('/machine-inventory?needsRefill=true');\r\n    return response.data.data || [];\r\n  } catch (error) {\r\n    return [];\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  showWarehouseMenu,\r\n  receiveItems,\r\n  handleItemScan,\r\n  handleQuantityInput,\r\n  handleConfirmationPhoto,\r\n  fillBunker,\r\n  weighItems,\r\n  handleWeightInput,\r\n  cancelAction,\r\n  WAREHOUSE_STATES\r\n};\r\n",
  "services/telegram-bot/src/utils/s3Storage.js": "const AWS = require('aws-sdk');\r\nconst { v4: uuidv4 } = require('uuid');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n/**\r\n * DigitalOcean Spaces Storage Module\r\n * Модуль для загрузки файлов в DigitalOcean Spaces\r\n */\r\n\r\nclass S3Storage {\r\n  constructor() {\r\n    // Конфигурация DigitalOcean Spaces\r\n    this.spacesEndpoint = new AWS.Endpoint(process.env.S3_ENDPOINT || 'https://fra1.digitaloceanspaces.com');\r\n    this.s3 = new AWS.S3({\r\n      endpoint: this.spacesEndpoint,\r\n      accessKeyId: process.env.S3_ACCESS_KEY || 'DO00XEB6BC6XZ8Q2M4KQ',\r\n      secretAccessKey: process.env.S3_SECRET_KEY || 'SeYpfXGQ4eKR8WEDdGKjtLo0c6BK82r2hfnrzB63swk',\r\n      region: process.env.S3_REGION || 'fra1'\r\n    });\r\n    \r\n    this.bucketName = process.env.S3_BUCKET || 'vhm24-uploads';\r\n    this.cdnUrl = `https://${this.bucketName}.fra1.cdn.digitaloceanspaces.com`;\r\n  }\r\n\r\n  /**\r\n   * Загрузка файла в DigitalOcean Spaces\r\n   * @param {string} filePath - Путь к локальному файлу\r\n   * @param {string} fileName - Имя файла\r\n   * @param {string} folder - Папка для загрузки (по умолчанию 'uploads')\r\n   * @returns {Promise<string>} - URL загруженного файла\r\n   */\r\n  async uploadFile(filePath, fileName, folder = 'uploads') {\r\n    try {\r\n      // Генерируем уникальное имя файла\r\n      const fileExtension = path.extname(fileName);\r\n      const uniqueFileName = `${uuidv4()}${fileExtension}`;\r\n      const key = `${folder}/${uniqueFileName}`;\r\n\r\n      // Читаем файл\r\n      const fileContent = fs.readFileSync(filePath);\r\n\r\n      // Определяем MIME тип\r\n      const mimeType = this.getMimeType(fileExtension);\r\n\r\n      // Параметры загрузки\r\n      const uploadParams = {\r\n        Bucket: this.bucketName,\r\n        Key: key,\r\n        Body: fileContent,\r\n        ACL: 'public-read',\r\n        ContentType: mimeType,\r\n        CacheControl: 'max-age=31536000' // Кэширование на год\r\n      };\r\n\r\n      // Загружаем файл\r\n      const result = await this.s3.upload(uploadParams).promise();\r\n      \r\n      // Возвращаем CDN URL\r\n      const cdnUrl = `${this.cdnUrl}/${key}`;\r\n      \r\n      console.log(`✅ File uploaded successfully: ${cdnUrl}`);\r\n      return cdnUrl;\r\n\r\n    } catch (error) {\r\n      console.error('❌ Error uploading file to S3:', error);\r\n      throw new Error(`Failed to upload file: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Загрузка фото из Telegram\r\n   * @param {string} filePath - Путь к загруженному фото\r\n   * @param {string} originalFileName - Оригинальное имя файла\r\n   * @returns {Promise<string>} - URL загруженного фото\r\n   */\r\n  async uploadPhoto(filePath, originalFileName = 'photo.jpg') {\r\n    return this.uploadFile(filePath, originalFileName, 'photos');\r\n  }\r\n\r\n  /**\r\n   * Загрузка документа из Telegram\r\n   * @param {string} filePath - Путь к загруженному документу\r\n   * @param {string} originalFileName - Оригинальное имя файла\r\n   * @returns {Promise<string>} - URL загруженного документа\r\n   */\r\n  async uploadDocument(filePath, originalFileName) {\r\n    return this.uploadFile(filePath, originalFileName, 'documents');\r\n  }\r\n\r\n  /**\r\n   * Загрузка отчета\r\n   * @param {string} filePath - Путь к файлу отчета\r\n   * @param {string} fileName - Имя файла отчета\r\n   * @returns {Promise<string>} - URL загруженного отчета\r\n   */\r\n  async uploadReport(filePath, fileName) {\r\n    return this.uploadFile(filePath, fileName, 'reports');\r\n  }\r\n\r\n  /**\r\n   * Определение MIME типа по расширению файла\r\n   * @param {string} extension - Расширение файла\r\n   * @returns {string} - MIME тип\r\n   */\r\n  getMimeType(extension) {\r\n    const mimeTypes = {\r\n      '.jpg': 'image/jpeg',\r\n      '.jpeg': 'image/jpeg',\r\n      '.png': 'image/png',\r\n      '.gif': 'image/gif',\r\n      '.webp': 'image/webp',\r\n      '.pdf': 'application/pdf',\r\n      '.doc': 'application/msword',\r\n      '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\r\n      '.xls': 'application/vnd.ms-excel',\r\n      '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\r\n      '.txt': 'text/plain',\r\n      '.csv': 'text/csv',\r\n      '.json': 'application/json'\r\n    };\r\n\r\n    return mimeTypes[extension.toLowerCase()] || 'application/octet-stream';\r\n  }\r\n\r\n  /**\r\n   * Удаление файла из DigitalOcean Spaces\r\n   * @param {string} fileUrl - URL файла для удаления\r\n   * @returns {Promise<boolean>} - Результат удаления\r\n   */\r\n  async deleteFile(fileUrl) {\r\n    try {\r\n      // Извлекаем ключ из URL\r\n      const key = fileUrl.replace(`${this.cdnUrl}/`, '');\r\n\r\n      const deleteParams = {\r\n        Bucket: this.bucketName,\r\n        Key: key\r\n      };\r\n\r\n      await this.s3.deleteObject(deleteParams).promise();\r\n      console.log(`✅ File deleted successfully: ${fileUrl}`);\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error('❌ Error deleting file from S3:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение информации о файле\r\n   * @param {string} fileUrl - URL файла\r\n   * @returns {Promise<Object>} - Информация о файле\r\n   */\r\n  async getFileInfo(fileUrl) {\r\n    try {\r\n      const key = fileUrl.replace(`${this.cdnUrl}/`, '');\r\n\r\n      const headParams = {\r\n        Bucket: this.bucketName,\r\n        Key: key\r\n      };\r\n\r\n      const result = await this.s3.headObject(headParams).promise();\r\n      \r\n      return {\r\n        size: result.ContentLength,\r\n        lastModified: result.LastModified,\r\n        contentType: result.ContentType,\r\n        etag: result.ETag\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('❌ Error getting file info:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Создание подписанного URL для временного доступа\r\n   * @param {string} key - Ключ файла в S3\r\n   * @param {number} expiresIn - Время жизни URL в секундах (по умолчанию 1 час)\r\n   * @returns {string} - Подписанный URL\r\n   */\r\n  getSignedUrl(key, expiresIn = 3600) {\r\n    const params = {\r\n      Bucket: this.bucketName,\r\n      Key: key,\r\n      Expires: expiresIn\r\n    };\r\n\r\n    return this.s3.getSignedUrl('getObject', params);\r\n  }\r\n}\r\n\r\n// Экспортируем singleton экземпляр\r\nconst s3Storage = new S3Storage();\r\nmodule.exports = s3Storage;\r\n",
  "setup-error-fixing-system.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 - Установка системы исправления ошибок\r\n * \r\n * Этот скрипт устанавливает все необходимые зависимости для работы\r\n * системы исправления ошибок VHM24.\r\n * \r\n * Использование:\r\n * node setup-error-fixing-system.js\r\n */\r\n\r\nconst { execSync } = require('child_process');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst readline = require('readline');\r\n\r\nconst rl = readline.createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout\r\n});\r\n\r\n// Цвета для консоли\r\nconst colors = {\r\n  reset: '\\x1b[0m',\r\n  bright: '\\x1b[1m',\r\n  red: '\\x1b[31m',\r\n  green: '\\x1b[32m',\r\n  yellow: '\\x1b[33m',\r\n  blue: '\\x1b[34m',\r\n  magenta: '\\x1b[35m',\r\n  cyan: '\\x1b[36m'\r\n};\r\n\r\n// Функция для форматированного вывода\r\nfunction log(message, color = 'reset') {\r\n  console.log(`${colors[color]}${message}${colors.reset}`);\r\n}\r\n\r\n// Функция для запроса подтверждения\r\nfunction confirm(message) {\r\n  return new Promise((resolve) => {\r\n    rl.question(`${colors.yellow}${message} (y/n): ${colors.reset}`, (answer) => {\r\n      resolve(answer.toLowerCase() === 'y');\r\n    });\r\n  });\r\n}\r\n\r\n// Функция для проверки наличия пакета\r\nfunction isPackageInstalled(packageName, global = false) {\r\n  try {\r\n    if (global) {\r\n      execSync(`npm list -g ${packageName}`, { stdio: 'pipe' });\r\n    } else {\r\n      execSync(`npm list ${packageName}`, { stdio: 'pipe' });\r\n    }\r\n    return true;\r\n  } catch (error) {\r\n    return false;\r\n  }\r\n}\r\n\r\n// Основная функция\r\nasync function main() {\r\n  log('\\n🔧 VHM24 - УСТАНОВКА СИСТЕМЫ ИСПРАВЛЕНИЯ ОШИБОК 🔧\\n', 'bright');\r\n  \r\n  // Проверяем наличие package.json\r\n  if (!fs.existsSync('package.json')) {\r\n    log('❌ Файл package.json не найден. Убедитесь, что вы находитесь в корневой директории проекта.', 'red');\r\n    rl.close();\r\n    return;\r\n  }\r\n  \r\n  // Шаг 1: Установка локальных зависимостей\r\n  log('\\n📦 ШАГ 1: УСТАНОВКА ЛОКАЛЬНЫХ ЗАВИСИМОСТЕЙ', 'magenta');\r\n  \r\n  const localDependencies = [\r\n    'glob',\r\n    'node-fetch',\r\n    'tap'\r\n  ];\r\n  \r\n  const missingLocalDeps = localDependencies.filter(dep => !isPackageInstalled(dep));\r\n  \r\n  if (missingLocalDeps.length > 0) {\r\n    log(`Необходимо установить следующие локальные зависимости: ${missingLocalDeps.join(', ')}`, 'cyan');\r\n    const installLocalConfirm = await confirm('Установить локальные зависимости?');\r\n    \r\n    if (installLocalConfirm) {\r\n      try {\r\n        log('\\nУстановка локальных зависимостей...', 'cyan');\r\n        execSync(`npm install --save-dev ${missingLocalDeps.join(' ')}`, { stdio: 'inherit' });\r\n        log('\\n✅ Локальные зависимости установлены!', 'green');\r\n      } catch (error) {\r\n        log(`\\n❌ Ошибка при установке локальных зависимостей: ${error.message}`, 'red');\r\n      }\r\n    }\r\n  } else {\r\n    log('✅ Все локальные зависимости уже установлены!', 'green');\r\n  }\r\n  \r\n  // Шаг 2: Установка глобальных зависимостей\r\n  log('\\n🌐 ШАГ 2: УСТАНОВКА ГЛОБАЛЬНЫХ ЗАВИСИМОСТЕЙ', 'magenta');\r\n  \r\n  const globalDependencies = [\r\n    'autocannon'\r\n  ];\r\n  \r\n  const missingGlobalDeps = globalDependencies.filter(dep => !isPackageInstalled(dep, true));\r\n  \r\n  if (missingGlobalDeps.length > 0) {\r\n    log(`Необходимо установить следующие глобальные зависимости: ${missingGlobalDeps.join(', ')}`, 'cyan');\r\n    const installGlobalConfirm = await confirm('Установить глобальные зависимости?');\r\n    \r\n    if (installGlobalConfirm) {\r\n      try {\r\n        log('\\nУстановка глобальных зависимостей...', 'cyan');\r\n        execSync(`npm install -g ${missingGlobalDeps.join(' ')}`, { stdio: 'inherit' });\r\n        log('\\n✅ Глобальные зависимости установлены!', 'green');\r\n      } catch (error) {\r\n        log(`\\n❌ Ошибка при установке глобальных зависимостей: ${error.message}`, 'red');\r\n      }\r\n    }\r\n  } else {\r\n    log('✅ Все глобальные зависимости уже установлены!', 'green');\r\n  }\r\n  \r\n  // Шаг 3: Создание директорий\r\n  log('\\n📁 ШАГ 3: СОЗДАНИЕ НЕОБХОДИМЫХ ДИРЕКТОРИЙ', 'magenta');\r\n  \r\n  const directories = [\r\n    'backups',\r\n    'scripts'\r\n  ];\r\n  \r\n  directories.forEach(dir => {\r\n    if (!fs.existsSync(dir)) {\r\n      fs.mkdirSync(dir, { recursive: true });\r\n      log(`✅ Создана директория: ${dir}`, 'green');\r\n    } else {\r\n      log(`✅ Директория ${dir} уже существует`, 'green');\r\n    }\r\n  });\r\n  \r\n  // Шаг 4: Проверка наличия скриптов\r\n  log('\\n📜 ШАГ 4: ПРОВЕРКА НАЛИЧИЯ СКРИПТОВ', 'magenta');\r\n  \r\n  const scripts = [\r\n    'scripts/project-analyzer.js',\r\n    'scripts/auto-fixer.js',\r\n    'scripts/test-after-fixes.js',\r\n    'fix-all-errors.js',\r\n    'VHM24_FIX_CHECKLIST.md',\r\n    'VHM24_ERROR_FIXING_SYSTEM.md'\r\n  ];\r\n  \r\n  const missingScripts = scripts.filter(script => !fs.existsSync(script));\r\n  \r\n  if (missingScripts.length > 0) {\r\n    log(`❌ Отсутствуют следующие скрипты: ${missingScripts.join(', ')}`, 'red');\r\n    log('Убедитесь, что вы скопировали все необходимые файлы в проект.', 'yellow');\r\n  } else {\r\n    log('✅ Все необходимые скрипты найдены!', 'green');\r\n  }\r\n  \r\n  // Шаг 5: Добавление скриптов в package.json\r\n  log('\\n🔧 ШАГ 5: ДОБАВЛЕНИЕ СКРИПТОВ В PACKAGE.JSON', 'magenta');\r\n  \r\n  const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));\r\n  \r\n  if (!packageJson.scripts) {\r\n    packageJson.scripts = {};\r\n  }\r\n  \r\n  const scriptsToAdd = {\r\n    'analyze': 'node scripts/project-analyzer.js',\r\n    'fix': 'node scripts/auto-fixer.js',\r\n    'test-fixes': 'node scripts/test-after-fixes.js',\r\n    'fix-all': 'node fix-all-errors.js'\r\n  };\r\n  \r\n  let scriptsAdded = false;\r\n  \r\n  Object.entries(scriptsToAdd).forEach(([name, command]) => {\r\n    if (!packageJson.scripts[name]) {\r\n      packageJson.scripts[name] = command;\r\n      scriptsAdded = true;\r\n      log(`✅ Добавлен скрипт: ${name}`, 'green');\r\n    } else {\r\n      log(`✅ Скрипт ${name} уже существует`, 'green');\r\n    }\r\n  });\r\n  \r\n  if (scriptsAdded) {\r\n    fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2));\r\n    log('✅ Файл package.json обновлен!', 'green');\r\n  }\r\n  \r\n  // Завершение\r\n  log('\\n🎉 УСТАНОВКА ЗАВЕРШЕНА!', 'bright');\r\n  log('Теперь вы можете использовать следующие команды:', 'cyan');\r\n  log('  npm run analyze - для анализа проекта', 'cyan');\r\n  log('  npm run fix - для исправления проблем', 'cyan');\r\n  log('  npm run test-fixes - для тестирования после исправлений', 'cyan');\r\n  log('  npm run fix-all - для запуска всего процесса', 'cyan');\r\n  log('\\nИли запустите полный процесс напрямую:', 'cyan');\r\n  log('  node fix-all-errors.js', 'cyan');\r\n  log('\\n📚 Дополнительная информация доступна в VHM24_ERROR_FIXING_SYSTEM.md', 'cyan');\r\n  \r\n  rl.close();\r\n}\r\n\r\n// Запуск основной функции\r\nmain().catch(error => {\r\n  log(`\\n❌ Критическая ошибка: ${error.message}`, 'red');\r\n  rl.close();\r\n});\r\n",
  "start-pm2.js": "/**\r\n * VHM24 - PM2 Startup Script\r\n * \r\n * Этот скрипт запускает систему с использованием PM2 для управления процессами\r\n * PM2 обеспечивает автоматический перезапуск, мониторинг и логирование\r\n */\r\n\r\nconst { execSync } = require('child_process');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nconsole.log('🚀 Запуск VHM24 с использованием PM2...\\n');\r\n\r\ntry {\r\n  // Проверяем, установлен ли PM2\r\n  try {\r\n    execSync('pm2 --version', { stdio: 'ignore' });\r\n    console.log('✅ PM2 уже установлен');\r\n  } catch (error) {\r\n    console.log('⚠️ PM2 не установлен, устанавливаем...');\r\n    execSync('npm install -g pm2', { stdio: 'inherit' });\r\n    console.log('✅ PM2 успешно установлен');\r\n  }\r\n\r\n  // Создаем конфигурационный файл для PM2\r\n  const pm2Config = {\r\n    apps: [\r\n      {\r\n        name: 'vhm24-auth',\r\n        script: 'services/auth/src/index.js',\r\n        watch: false,\r\n        instances: 1,\r\n        autorestart: true,\r\n        max_memory_restart: '200M',\r\n        env: {\r\n          NODE_ENV: 'production'\r\n        }\r\n      },\r\n      {\r\n        name: 'vhm24-machines',\r\n        script: 'services/machines/src/index.js',\r\n        watch: false,\r\n        instances: 1,\r\n        autorestart: true,\r\n        max_memory_restart: '200M',\r\n        env: {\r\n          NODE_ENV: 'production'\r\n        }\r\n      },\r\n      {\r\n        name: 'vhm24-inventory',\r\n        script: 'services/inventory/src/index.js',\r\n        watch: false,\r\n        instances: 1,\r\n        autorestart: true,\r\n        max_memory_restart: '200M',\r\n        env: {\r\n          NODE_ENV: 'production'\r\n        }\r\n      },\r\n      {\r\n        name: 'vhm24-tasks',\r\n        script: 'services/tasks/src/index.js',\r\n        watch: false,\r\n        instances: 1,\r\n        autorestart: true,\r\n        max_memory_restart: '200M',\r\n        env: {\r\n          NODE_ENV: 'production'\r\n        }\r\n      },\r\n      {\r\n        name: 'vhm24-bunkers',\r\n        script: 'services/bunkers/src/index.js',\r\n        watch: false,\r\n        instances: 1,\r\n        autorestart: true,\r\n        max_memory_restart: '200M',\r\n        env: {\r\n          NODE_ENV: 'production'\r\n        }\r\n      },\r\n      {\r\n        name: 'vhm24-telegram-bot',\r\n        script: 'services/telegram-bot/src/index.js',\r\n        watch: false,\r\n        instances: 1,\r\n        autorestart: true,\r\n        max_memory_restart: '200M',\r\n        env: {\r\n          NODE_ENV: 'production'\r\n        }\r\n      },\r\n      {\r\n        name: 'vhm24-notifications',\r\n        script: 'services/notifications/src/index.js',\r\n        watch: false,\r\n        instances: 1,\r\n        autorestart: true,\r\n        max_memory_restart: '200M',\r\n        env: {\r\n          NODE_ENV: 'production'\r\n        }\r\n      },\r\n      {\r\n        name: 'vhm24-gateway',\r\n        script: 'services/gateway/src/index.js',\r\n        watch: false,\r\n        instances: 1,\r\n        autorestart: true,\r\n        max_memory_restart: '200M',\r\n        env: {\r\n          NODE_ENV: 'production'\r\n        }\r\n      }\r\n    ]\r\n  };\r\n\r\n  // Записываем конфигурацию в файл\r\n  fs.writeFileSync('ecosystem.config.js', `module.exports = ${JSON.stringify(pm2Config, null, 2)}`);\r\n  console.log('✅ Создан конфигурационный файл PM2: ecosystem.config.js');\r\n\r\n  // Запускаем систему с использованием PM2\r\n  console.log('\\n🚀 Запуск системы с использованием PM2...');\r\n  execSync('pm2 start ecosystem.config.js', { stdio: 'inherit' });\r\n\r\n  // Сохраняем конфигурацию PM2 для автозапуска при перезагрузке\r\n  console.log('\\n💾 Настройка автозапуска при перезагрузке системы...');\r\n  execSync('pm2 save', { stdio: 'inherit' });\r\n  \r\n  // Выводим информацию о запущенных процессах\r\n  console.log('\\n📊 Статус запущенных процессов:');\r\n  execSync('pm2 list', { stdio: 'inherit' });\r\n  \r\n  console.log('\\n✅ Система успешно запущена с использованием PM2!');\r\n  console.log('📝 Для просмотра логов используйте: pm2 logs');\r\n  console.log('🔄 Для перезапуска всех сервисов: pm2 restart all');\r\n  console.log('⏹️ Для остановки всех сервисов: pm2 stop all');\r\n  console.log('🔍 Для мониторинга: pm2 monit');\r\n} catch (error) {\r\n  console.error('\\n❌ Ошибка при запуске системы с использованием PM2:', error.message);\r\n  process.exit(1);\r\n}\r\n",
  "cleanup-project.js": "/**\r\n * VHM24 Project Cleanup Script\r\n * Removes redundant files and organizes the project structure\r\n */\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n// Files to delete\r\nconst filesToDelete = [\r\n  // Redundant documentation\r\n  'RAILWAY_API_STATUS.md',\r\n  'RAILWAY_BOT_FIX.md',\r\n  'RAILWAY_BUILD_FIX.md',\r\n  'RAILWAY_CORRECT_VARIABLES.md',\r\n  'RAILWAY_DATABASE_FIX.md',\r\n  'RAILWAY_DEPLOY_NOW.md',\r\n  'RAILWAY_ENV_REQUIRED.md',\r\n  'RAILWAY_ENV_SETUP.md',\r\n  'RAILWAY_FINAL_CONFIG.md',\r\n  'RAILWAY_FINAL_DEPLOY.md',\r\n  'RAILWAY_FINAL_SETUP.md',\r\n  'RAILWAY_FINAL_STATUS.md',\r\n  'RAILWAY_FINAL_STEPS.md',\r\n  'RAILWAY_FINAL_VARIABLES.md',\r\n  'RAILWAY_FIX_CHECKLIST.md',\r\n  'RAILWAY_GATEWAY_FIX.md',\r\n  'RAILWAY_PORT_FIX.md',\r\n  'RAILWAY_QUICK_DEPLOY.md',\r\n  'RAILWAY_VARIABLES_FINAL.md',\r\n  'RAILWAY_VARIABLES_READY.env',\r\n  'RAILWAY_WITH_SUPABASE.md',\r\n  'RAILWAY_ADMIN_SETUP.md',\r\n  \r\n  // Redundant start scripts\r\n  'start-all-services-fixed.bat',\r\n  'start-all-services.bat',\r\n  'start-all.bat',\r\n  'start-development.bat',\r\n  'start-gateway-simple.bat',\r\n  'start-services.bat',\r\n  'start-with-supabase.bat',\r\n  'deploy-railway-fixed.bat',\r\n  'deploy-to-railway.bat',\r\n  'deploy-to-railway.sh',\r\n  \r\n  // Old entry points (replaced by start.js)\r\n  'index.js',\r\n  'railway-start.js',\r\n  \r\n  // Other redundant files\r\n  'index-gateway-only.js',\r\n  'prepare-for-railway.js',\r\n  'setup-railway-env.js',\r\n  'format-json.js',\r\n  'vendhub-api-example.js',\r\n  'vendhub-bot-example.js',\r\n  'vendbot-compatibility-report.json',\r\n  '.env.railway',\r\n  'railway.json',\r\n  \r\n  // Old analysis files\r\n  'VENDBOT_MIGRATION_ANALYSIS.md',\r\n  'VENDHUB_API_SPEC.md',\r\n  'VENDHUB_ARCHITECTURE_DIAGRAM.md',\r\n  'VENDHUB_ARCHITECTURE.md',\r\n  'VENDHUB_MIGRATION_PLAN.md',\r\n  'VENDHUB_PROJECT_SUMMARY.md',\r\n  'VENDHUB_TELEGRAM_BOT_SPEC.md',\r\n  'VENDHUB_TEST_REPORT.md',\r\n  'VENDHUB_VS_VHM24_COMPARISON.md',\r\n  'VHM24_FIXES_REPORT_2025.md',\r\n  'VHM24_FIXES_REPORT.md',\r\n  'VHM24_GAP_ANALYSIS.md',\r\n  'VHM24_IMPLEMENTATION_REPORT.md',\r\n  'FINAL_COMPATIBILITY_REPORT.md',\r\n  'FULL_ANALYSIS_AND_FIXES.md',\r\n  'ARCHITECTURE_REVIEW.md',\r\n  'README_IMPROVEMENTS.md',\r\n  'TEST_RESULTS.md'\r\n];\r\n\r\n// Files to keep and potentially merge\r\nconst filesToKeep = [\r\n  'RAILWAY_DEPLOYMENT_GUIDE.md',\r\n  'RAILWAY_DATABASE_SETUP.md',\r\n  'DATABASE_MIGRATION_PLAN.md',\r\n  'DATABASE_MIGRATION_SUMMARY.md',\r\n  'SUPABASE_MIGRATION_GUIDE.md',\r\n  'QUICK_START.md',\r\n  'NEXT_STEPS.md',\r\n  'README.md',\r\n  'VHM24_ANALYSIS_AND_OPTIMIZATION.md'\r\n];\r\n\r\nconsole.log('🧹 VHM24 Project Cleanup\\n');\r\n\r\n// Count files before cleanup\r\nconst totalFilesBefore = fs.readdirSync('.').length;\r\nconsole.log(`Total files before cleanup: ${totalFilesBefore}`);\r\n\r\n// Delete files\r\nlet deletedCount = 0;\r\nlet errors = [];\r\n\r\nconsole.log('\\n📁 Deleting redundant files...\\n');\r\n\r\nfilesToDelete.forEach(file => {\r\n  const filePath = path.join('.', file);\r\n  if (fs.existsSync(filePath)) {\r\n    try {\r\n      fs.unlinkSync(filePath);\r\n      console.log(`✅ Deleted: ${file}`);\r\n      deletedCount++;\r\n    } catch (error) {\r\n      console.error(`❌ Error deleting ${file}: ${error.message}`);\r\n      errors.push({ file, error: error.message });\r\n    }\r\n  } else {\r\n    console.log(`⏭️  Skipped (not found): ${file}`);\r\n  }\r\n});\r\n\r\n// Summary\r\nconsole.log('\\n📊 Cleanup Summary:');\r\nconsole.log(`- Files deleted: ${deletedCount}`);\r\nconsole.log(`- Files kept: ${filesToKeep.length}`);\r\nconsole.log(`- Errors: ${errors.length}`);\r\n\r\nif (errors.length > 0) {\r\n  console.log('\\n❌ Errors encountered:');\r\n  errors.forEach(({ file, error }) => {\r\n    console.log(`  - ${file}: ${error}`);\r\n  });\r\n}\r\n\r\n// Count files after cleanup\r\nconst totalFilesAfter = fs.readdirSync('.').length;\r\nconsole.log(`\\nTotal files after cleanup: ${totalFilesAfter}`);\r\nconsole.log(`Files removed: ${totalFilesBefore - totalFilesAfter}`);\r\n\r\nconsole.log('\\n✨ Cleanup complete!');\r\nconsole.log('\\n📝 Next steps:');\r\nconsole.log('1. Review the remaining documentation files');\r\nconsole.log('2. Merge related documentation into single files');\r\nconsole.log('3. Update README.md with current project structure');\r\nconsole.log('4. Run \"npm run clean && npm install\" to refresh dependencies');\r\n",
  "fix-all-errors-and-start.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Complete Error Fix and Start\r\n * Комплексное исправление всех ошибок и запуск системы\r\n */\r\n\r\nconst { spawn, execSync } = require('child_process');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nconsole.log('🔧 Комплексное исправление ошибок VHM24...\\n');\r\n\r\n// Функция для выполнения команды с выводом\r\nfunction runCommand(command, cwd = process.cwd()) {\r\n  try {\r\n    console.log(`📦 Выполняется: ${command}`);\r\n    execSync(command, { \r\n      cwd, \r\n      stdio: 'inherit',\r\n      encoding: 'utf8'\r\n    });\r\n    console.log(`✅ Команда выполнена успешно\\n`);\r\n    return true;\r\n  } catch (error) {\r\n    console.log(`❌ Ошибка выполнения команды: ${error.message}\\n`);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Функция для создания недостающих директорий\r\nfunction createMissingDirectories() {\r\n  console.log('📁 Создание недостающих директорий...');\r\n  \r\n  const directories = [\r\n    'services/data-import/templates',\r\n    'services/notifications/logs',\r\n    'services/audit/logs',\r\n    'services/gateway/uploads',\r\n    'services/backup/backups'\r\n  ];\r\n\r\n  directories.forEach(dir => {\r\n    const fullPath = path.join(__dirname, dir);\r\n    if (!fs.existsSync(fullPath)) {\r\n      fs.mkdirSync(fullPath, { recursive: true });\r\n      console.log(`✅ Создана директория: ${dir}`);\r\n    }\r\n  });\r\n}\r\n\r\n// Функция для остановки всех процессов Node.js\r\nfunction killAllNodeProcesses() {\r\n  console.log('🛑 Остановка всех процессов Node.js...');\r\n  try {\r\n    if (process.platform === 'win32') {\r\n      execSync('taskkill /f /im node.exe', { stdio: 'ignore' });\r\n    } else {\r\n      execSync('pkill -f node', { stdio: 'ignore' });\r\n    }\r\n    console.log('✅ Все процессы остановлены');\r\n  } catch (error) {\r\n    console.log('⚠️  Некоторые процессы не удалось остановить (это нормально)');\r\n  }\r\n}\r\n\r\n// Функция для установки зависимостей\r\nfunction installDependencies() {\r\n  console.log('📦 Установка зависимостей...');\r\n  \r\n  const packages = [\r\n    '.',\r\n    'packages/database',\r\n    'packages/shared',\r\n    'packages/shared-types',\r\n    'services/gateway',\r\n    'services/auth',\r\n    'services/machines',\r\n    'services/notifications',\r\n    'services/audit',\r\n    'services/routes',\r\n    'services/warehouse',\r\n    'services/recipes'\r\n  ];\r\n\r\n  for (const pkg of packages) {\r\n    const pkgPath = path.join(__dirname, pkg);\r\n    const packageJsonPath = path.join(pkgPath, 'package.json');\r\n    \r\n    if (fs.existsSync(packageJsonPath)) {\r\n      console.log(`📦 Установка зависимостей для ${pkg}...`);\r\n      if (!runCommand('npm install --no-audit --no-fund', pkgPath)) {\r\n        console.log(`⚠️  Ошибка установки зависимостей для ${pkg}, продолжаем...\\n`);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Функция для запуска сервиса\r\nfunction startService(service) {\r\n  return new Promise((resolve) => {\r\n    console.log(`🔧 Запуск ${service.name}...`);\r\n    \r\n    const childProcess = spawn('npm', ['start'], {\r\n      cwd: path.join(__dirname, service.path),\r\n      stdio: 'pipe',\r\n      env: {\r\n        ...process.env,\r\n        PORT: service.port\r\n      }\r\n    });\r\n\r\n    let started = false;\r\n    let output = '';\r\n\r\n    childProcess.stdout.on('data', (data) => {\r\n      const text = data.toString();\r\n      output += text;\r\n      console.log(`[${service.name}] ${text.trim()}`);\r\n      \r\n      if (!started && (text.includes('listening') || text.includes('running') || text.includes('Server listening'))) {\r\n        started = true;\r\n        console.log(`✅ ${service.name} запущен на порту ${service.port}`);\r\n        resolve({ process: childProcess, success: true });\r\n      }\r\n    });\r\n\r\n    childProcess.stderr.on('data', (data) => {\r\n      const text = data.toString();\r\n      if (!text.includes('ExperimentalWarning') && !text.includes('DeprecationWarning')) {\r\n        console.log(`[${service.name} ERROR] ${text.trim()}`);\r\n      }\r\n    });\r\n\r\n    childProcess.on('close', (code) => {\r\n      if (!started) {\r\n        console.log(`❌ ${service.name} завершен с кодом ${code}`);\r\n        resolve({ process: null, success: false });\r\n      }\r\n    });\r\n\r\n    childProcess.on('error', (error) => {\r\n      console.log(`💥 Ошибка запуска ${service.name}: ${error.message}`);\r\n      if (!started) {\r\n        resolve({ process: null, success: false });\r\n      }\r\n    });\r\n\r\n    // Таймаут для запуска\r\n    setTimeout(() => {\r\n      if (!started) {\r\n        console.log(`⚠️  ${service.name} запускается медленно...`);\r\n        resolve({ process: childProcess, success: true });\r\n      }\r\n    }, 10000);\r\n  });\r\n}\r\n\r\n// Основная функция\r\nasync function main() {\r\n  try {\r\n    // 1. Остановка всех процессов\r\n    killAllNodeProcesses();\r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n    // 2. Создание недостающих директорий\r\n    createMissingDirectories();\r\n\r\n    // 3. Установка зависимостей\r\n    installDependencies();\r\n\r\n    // 4. Запуск сервисов\r\n    console.log('\\n🚀 Запуск сервисов...\\n');\r\n    \r\n    const services = [\r\n      { name: 'Auth', path: 'services/auth', port: 3001 },\r\n      { name: 'Gateway', path: 'services/gateway', port: 8000 },\r\n      { name: 'Machines', path: 'services/machines', port: 3002 },\r\n      { name: 'Notifications', path: 'services/notifications', port: 3006 },\r\n      { name: 'Audit', path: 'services/audit', port: 3007 }\r\n    ];\r\n\r\n    const runningProcesses = [];\r\n    let successCount = 0;\r\n\r\n    for (const service of services) {\r\n      const result = await startService(service);\r\n      if (result.success) {\r\n        successCount++;\r\n        if (result.process) {\r\n          runningProcesses.push(result.process);\r\n        }\r\n      }\r\n      // Пауза между запусками\r\n      await new Promise(resolve => setTimeout(resolve, 2000));\r\n    }\r\n\r\n    console.log('\\n🎉 Запуск завершен!');\r\n    console.log(`📊 Запущено сервисов: ${successCount}/${services.length}`);\r\n    \r\n    if (successCount > 0) {\r\n      console.log('\\n📋 Доступные endpoints:');\r\n      console.log('   🌐 API Gateway: http://localhost:8000');\r\n      console.log('   🔐 Auth Service: http://localhost:3001');\r\n      console.log('   🤖 Machines Service: http://localhost:3002');\r\n      console.log('   🔔 Notifications Service: http://localhost:3006');\r\n      console.log('   🔍 Audit Service: http://localhost:3007');\r\n      \r\n      console.log('\\n🧪 Для тестирования запустите:');\r\n      console.log('   node test-complete-system-with-notifications.js');\r\n      \r\n      console.log('\\n⚠️  Для остановки нажмите Ctrl+C');\r\n\r\n      // Обработка сигналов завершения\r\n      process.on('SIGINT', () => {\r\n        console.log('\\n🛑 Остановка всех сервисов...');\r\n        runningProcesses.forEach(proc => {\r\n          if (proc && !proc.killed) {\r\n            proc.kill('SIGTERM');\r\n          }\r\n        });\r\n        setTimeout(() => {\r\n          console.log('👋 Все сервисы остановлены');\r\n          process.exit(0);\r\n        }, 2000);\r\n      });\r\n\r\n      // Ожидание завершения\r\n      await new Promise(() => {});\r\n    } else {\r\n      console.log('❌ Не удалось запустить ни одного сервиса');\r\n      process.exit(1);\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('💥 Критическая ошибка:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Запуск\r\nmain();\r\n",
  "install-dependencies.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Simple Dependencies Installation\r\n * Простая установка зависимостей для VHM24\r\n */\r\n\r\nconst { execSync } = require('child_process');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nconsole.log('🔧 Установка зависимостей VHM24...\\n');\r\n\r\n// Функция для выполнения команды с выводом\r\nfunction runCommand(command, cwd = process.cwd()) {\r\n  try {\r\n    console.log(`📦 Выполняется: ${command} в ${cwd}`);\r\n    const result = execSync(command, { \r\n      cwd, \r\n      stdio: 'inherit',\r\n      encoding: 'utf8'\r\n    });\r\n    console.log(`✅ Команда выполнена успешно\\n`);\r\n    return true;\r\n  } catch (error) {\r\n    console.log(`❌ Ошибка выполнения команды: ${error.message}\\n`);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Проверяем наличие Node.js и npm\r\nfunction checkPrerequisites() {\r\n  console.log('🔍 Проверка предварительных требований...');\r\n  \r\n  try {\r\n    const nodeVersion = execSync('node --version', { encoding: 'utf8' }).trim();\r\n    const npmVersion = execSync('npm --version', { encoding: 'utf8' }).trim();\r\n    \r\n    console.log(`✅ Node.js: ${nodeVersion}`);\r\n    console.log(`✅ npm: ${npmVersion}\\n`);\r\n    return true;\r\n  } catch (error) {\r\n    console.log('❌ Node.js или npm не установлены');\r\n    return false;\r\n  }\r\n}\r\n\r\n// Основные пакеты для установки\r\nconst packages = [\r\n  'packages/database',\r\n  'packages/shared',\r\n  'packages/shared-types',\r\n  'services/notifications',\r\n  'services/audit',\r\n  'services/gateway'\r\n];\r\n\r\nasync function main() {\r\n  // Проверяем предварительные требования\r\n  if (!checkPrerequisites()) {\r\n    process.exit(1);\r\n  }\r\n\r\n  // Устанавливаем зависимости в корне\r\n  console.log('📦 Установка корневых зависимостей...');\r\n  if (!runCommand('npm install')) {\r\n    console.log('⚠️  Ошибка установки корневых зависимостей, продолжаем...\\n');\r\n  }\r\n\r\n  // Устанавливаем зависимости для каждого пакета\r\n  for (const pkg of packages) {\r\n    const pkgPath = path.join(__dirname, pkg);\r\n    const packageJsonPath = path.join(pkgPath, 'package.json');\r\n    \r\n    if (fs.existsSync(packageJsonPath)) {\r\n      console.log(`📦 Установка зависимостей для ${pkg}...`);\r\n      if (!runCommand('npm install', pkgPath)) {\r\n        console.log(`⚠️  Ошибка установки зависимостей для ${pkg}, продолжаем...\\n`);\r\n      }\r\n    } else {\r\n      console.log(`⚠️  package.json не найден для ${pkg}\\n`);\r\n    }\r\n  }\r\n\r\n  console.log('🎉 Установка зависимостей завершена!');\r\n  console.log('\\n🚀 Теперь можно запускать:');\r\n  console.log('   node start-all-services-with-audit.js');\r\n  console.log('   node test-complete-system-with-notifications.js');\r\n}\r\n\r\nmain().catch(error => {\r\n  console.error('💥 Критическая ошибка:', error);\r\n  process.exit(1);\r\n});\r\n",
  "monitor-24-7.js": "/**\r\n * VHM24 - VendHub Manager 24/7\r\n * System Monitor\r\n * Checks all services are running 24/7\r\n */\r\n\r\nconst axios = require('axios');\r\n\r\nconst services = [\r\n  { name: 'Gateway', url: 'http://localhost:8000/health' },\r\n  { name: 'Auth', url: 'http://localhost:3001/health' },\r\n  { name: 'Machines', url: 'http://localhost:3002/health' },\r\n  { name: 'Inventory', url: 'http://localhost:3003/health' },\r\n  { name: 'Tasks', url: 'http://localhost:3004/health' },\r\n  { name: 'Bunkers', url: 'http://localhost:3005/health' }\r\n];\r\n\r\nasync function checkServices() {\r\n  console.log('🔍 VHM24 - Checking 24/7 service status...\\n');\r\n  \r\n  let allHealthy = true;\r\n  \r\n  for (const service of services) {\r\n    try {\r\n      const response = await axios.get(service.url, { timeout: 5000 });\r\n      if (response.data.status === 'ok') {\r\n        console.log(`✅ ${service.name} - ONLINE 24/7`);\r\n      } else {\r\n        console.log(`⚠️  ${service.name} - ISSUE DETECTED`);\r\n        allHealthy = false;\r\n      }\r\n    } catch (error) {\r\n      console.log(`❌ ${service.name} - OFFLINE`);\r\n      allHealthy = false;\r\n    }\r\n  }\r\n  \r\n  console.log('\\n' + '='.repeat(40));\r\n  if (allHealthy) {\r\n    console.log('✅ VHM24 System Status: FULLY OPERATIONAL 24/7');\r\n  } else {\r\n    console.log('⚠️  VHM24 System Status: ISSUES DETECTED');\r\n    console.log('Some services need attention for 24/7 operation');\r\n  }\r\n}\r\n\r\n// Run check immediately\r\ncheckServices();\r\n\r\n// Check every 5 minutes for 24/7 monitoring\r\nsetInterval(checkServices, 5 * 60 * 1000);\r\n\r\nconsole.log('\\n⏰ VHM24 Monitor running - checking every 5 minutes');\r\nconsole.log('Press Ctrl+C to stop monitoring\\n');\r\n",
  "packages/database/src/seed.js": "const { PrismaClient } = require('@prisma/client');\r\nconst bcrypt = require('bcrypt');\r\nconst path = require('path');\r\n\r\n// Load environment variables\r\nrequire('dotenv').config({ path: path.join(__dirname, '../../../.env') });\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nasync function main() {\r\n  console.log('🌱 Seeding database...');\r\n  console.log('Database URL:', process.env.DATABASE_URL ? 'Connected' : 'Not found');\r\n  \r\n  try {\r\n    // Check if admin already exists\r\n    const existingAdmin = await prisma.user.findFirst({\r\n      where: {\r\n        OR: [\r\n          { email: 'admin@vhm24.ru' },\r\n          { telegramId: '42283329' }\r\n        ]\r\n      }\r\n    });\r\n\r\n    if (existingAdmin) {\r\n      console.log('✅ Admin already exists:', existingAdmin.email);\r\n      return;\r\n    }\r\n\r\n    // Create admin user\r\n    const passwordHash = await bcrypt.hash('admin123', 10);\r\n    \r\n    const admin = await prisma.user.create({\r\n      data: {\r\n        email: 'admin@vhm24.ru',\r\n        name: 'System Administrator',\r\n        passwordHash,\r\n        roles: ['ADMIN'],\r\n        telegramId: '42283329', // Your Telegram ID\r\n        phoneNumber: '+998901234567', // Optional\r\n        isActive: true\r\n      }\r\n    });\r\n    \r\n    console.log('✅ Admin created successfully!');\r\n    console.log('Email:', admin.email);\r\n    console.log('Password: admin123');\r\n    console.log('Telegram ID:', admin.telegramId);\r\n    console.log('Roles:', admin.roles);\r\n\r\n    // Create some test data\r\n    console.log('\\n📦 Creating test data...');\r\n\r\n    // Create a location\r\n    const location = await prisma.location.create({\r\n      data: {\r\n        name: 'Main Office',\r\n        address: 'Tashkent, Uzbekistan',\r\n        latitude: 41.2995,\r\n        longitude: 69.2401\r\n      }\r\n    });\r\n\r\n    // Create a machine\r\n    const machine = await prisma.machine.create({\r\n      data: {\r\n        code: 'VM-001',\r\n        serialNumber: 'SN-2024-001',\r\n        type: 'Coffee Vending Machine',\r\n        name: 'Coffee Machine #1',\r\n        status: 'ONLINE',\r\n        locationId: location.id\r\n      }\r\n    });\r\n\r\n    console.log('✅ Test machine created:', machine.name);\r\n\r\n    // Create inventory items\r\n    const items = await Promise.all([\r\n      prisma.inventoryItem.create({\r\n        data: {\r\n          name: 'Coffee Beans',\r\n          sku: 'COFFEE-001',\r\n          unit: 'KG',\r\n          category: 'Ingredients',\r\n          quantity: 50,\r\n          minQuantity: 10,\r\n          price: 25000\r\n        }\r\n      }),\r\n      prisma.inventoryItem.create({\r\n        data: {\r\n          name: 'Sugar',\r\n          sku: 'SUGAR-001',\r\n          unit: 'KG',\r\n          category: 'Ingredients',\r\n          quantity: 30,\r\n          minQuantity: 5,\r\n          price: 5000\r\n        }\r\n      }),\r\n      prisma.inventoryItem.create({\r\n        data: {\r\n          name: 'Milk Powder',\r\n          sku: 'MILK-001',\r\n          unit: 'KG',\r\n          category: 'Ingredients',\r\n          quantity: 20,\r\n          minQuantity: 5,\r\n          price: 15000\r\n        }\r\n      })\r\n    ]);\r\n\r\n    console.log('✅ Inventory items created:', items.length);\r\n\r\n    // Create machine inventory (bunkers)\r\n    for (const item of items) {\r\n      await prisma.machineInventory.create({\r\n        data: {\r\n          machineId: machine.id,\r\n          itemId: item.id,\r\n          quantity: 5,\r\n          minQuantity: 1,\r\n          maxQuantity: 10\r\n        }\r\n      });\r\n    }\r\n\r\n    console.log('✅ Machine bunkers configured');\r\n\r\n    // Create a sample task\r\n    const task = await prisma.task.create({\r\n      data: {\r\n        title: 'Refill Coffee Machine',\r\n        description: 'Regular maintenance and refill',\r\n        status: 'CREATED',\r\n        priority: 'MEDIUM',\r\n        machineId: machine.id,\r\n        createdById: admin.id\r\n      }\r\n    });\r\n\r\n    console.log('✅ Sample task created:', task.title);\r\n\r\n    console.log('\\n🎉 Database seeded successfully!');\r\n    console.log('\\n📱 Telegram Bot Usage:');\r\n    console.log('1. Send /start to your bot');\r\n    console.log('2. Login with Telegram ID: 42283329');\r\n    console.log('\\n🌐 Web Login:');\r\n    console.log('Email: admin@vhm24.ru');\r\n    console.log('Password: admin123');\r\n\r\n  } catch (error) {\r\n    console.error('❌ Error seeding database:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nmain()\r\n  .catch((e) => {\r\n    console.error(e);\r\n    process.exit(1);\r\n  })\r\n  .finally(async () => {\r\n    await prisma.$disconnect();\r\n  });\r\n",
  "packages/shared-types/src/redis-fallback.js": "// Fallback Redis implementation для локальной разработки без Redis сервера\r\nconst EventEmitter = require('events');\r\n\r\n// Mock Redis client\r\nclass MockRedis extends EventEmitter {\r\n  constructor() {\r\n    super();\r\n    this.data = new Map();\r\n    this.ttls = new Map();\r\n    \r\n    // Эмулируем успешное подключение\r\n    setTimeout(() => {\r\n      console.log('Connected to Redis (Mock)');\r\n      this.emit('connect');\r\n    }, 100);\r\n  }\r\n\r\n  async get(key) {\r\n    // Проверяем TTL\r\n    if (this.ttls.has(key)) {\r\n      const expiry = this.ttls.get(key);\r\n      if (Date.now() > expiry) {\r\n        this.data.delete(key);\r\n        this.ttls.delete(key);\r\n        return null;\r\n      }\r\n    }\r\n    return this.data.get(key) || null;\r\n  }\r\n\r\n  async set(key, value) {\r\n    this.data.set(key, value);\r\n    return 'OK';\r\n  }\r\n\r\n  async setex(key, seconds, value) {\r\n    this.data.set(key, value);\r\n    this.ttls.set(key, Date.now() + (seconds * 1000));\r\n    return 'OK';\r\n  }\r\n\r\n  async del(...keys) {\r\n    let deleted = 0;\r\n    keys.forEach(key => {\r\n      if (this.data.has(key)) {\r\n        this.data.delete(key);\r\n        this.ttls.delete(key);\r\n        deleted++;\r\n      }\r\n    });\r\n    return deleted;\r\n  }\r\n\r\n  async exists(key) {\r\n    // Проверяем TTL\r\n    if (this.ttls.has(key)) {\r\n      const expiry = this.ttls.get(key);\r\n      if (Date.now() > expiry) {\r\n        this.data.delete(key);\r\n        this.ttls.delete(key);\r\n        return 0;\r\n      }\r\n    }\r\n    return this.data.has(key) ? 1 : 0;\r\n  }\r\n\r\n  async expire(key, seconds) {\r\n    if (this.data.has(key)) {\r\n      this.ttls.set(key, Date.now() + (seconds * 1000));\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  async ttl(key) {\r\n    if (!this.data.has(key)) return -2;\r\n    if (!this.ttls.has(key)) return -1;\r\n    \r\n    const expiry = this.ttls.get(key);\r\n    const remaining = Math.ceil((expiry - Date.now()) / 1000);\r\n    return remaining > 0 ? remaining : -2;\r\n  }\r\n\r\n  async keys(pattern) {\r\n    const regex = new RegExp(pattern.replace(/\\*/g, '.*'));\r\n    return Array.from(this.data.keys()).filter(key => regex.test(key));\r\n  }\r\n\r\n  async flushall() {\r\n    this.data.clear();\r\n    this.ttls.clear();\r\n    return 'OK';\r\n  }\r\n}\r\n\r\n// Определяем, использовать ли реальный Redis или mock\r\nlet redis;\r\nconst useRealRedis = process.env.REDIS_URL && process.env.NODE_ENV === 'production';\r\n\r\nif (useRealRedis) {\r\n  try {\r\n    const Redis = require('ioredis');\r\n    redis = new Redis(process.env.REDIS_URL, {\r\n      maxRetriesPerRequest: 3,\r\n      retryStrategy: (times) => {\r\n        const delay = Math.min(times * 50, 2000);\r\n        return delay;\r\n      },\r\n      reconnectOnError: (err) => {\r\n        const targetError = 'READONLY';\r\n        if (err.message.includes(targetError)) {\r\n          return true;\r\n        }\r\n        return false;\r\n      }\r\n    });\r\n\r\n    redis.on('error', (err) => {\r\n      console.error('Redis connection error:', err);\r\n    });\r\n\r\n    redis.on('connect', () => {\r\n      console.log('Connected to Redis');\r\n    });\r\n  } catch (error) {\r\n    console.warn('Failed to connect to Redis, using fallback:', error.message);\r\n    redis = new MockRedis();\r\n  }\r\n} else {\r\n  console.log('Using Redis fallback for local development');\r\n  redis = new MockRedis();\r\n}\r\n\r\n// Утилиты для работы с кешем\r\nclass CacheManager {\r\n  constructor(prefix = 'vhm24:') {\r\n    this.prefix = prefix;\r\n    this.defaultTTL = parseInt(process.env.REDIS_TTL) || 3600; // 1 час по умолчанию\r\n  }\r\n\r\n  // Генерация ключа с префиксом\r\n  getKey(key) {\r\n    return `${this.prefix}${key}`;\r\n  }\r\n\r\n  // Получение данных из кеша\r\n  async get(key) {\r\n    try {\r\n      const data = await redis.get(this.getKey(key));\r\n      return data ? JSON.parse(data) : null;\r\n    } catch (error) {\r\n      console.error('Redis get error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Сохранение данных в кеш\r\n  async set(key, value, ttl = this.defaultTTL) {\r\n    try {\r\n      const data = JSON.stringify(value);\r\n      if (ttl) {\r\n        await redis.setex(this.getKey(key), ttl, data);\r\n      } else {\r\n        await redis.set(this.getKey(key), data);\r\n      }\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Redis set error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Удаление данных из кеша\r\n  async delete(key) {\r\n    try {\r\n      await redis.del(this.getKey(key));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Redis delete error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Удаление данных по паттерну\r\n  async deletePattern(pattern) {\r\n    try {\r\n      const keys = await redis.keys(this.getKey(pattern));\r\n      if (keys.length > 0) {\r\n        await redis.del(...keys);\r\n      }\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Redis delete pattern error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Проверка существования ключа\r\n  async exists(key) {\r\n    try {\r\n      const exists = await redis.exists(this.getKey(key));\r\n      return exists === 1;\r\n    } catch (error) {\r\n      console.error('Redis exists error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Установка времени жизни для существующего ключа\r\n  async expire(key, ttl) {\r\n    try {\r\n      await redis.expire(this.getKey(key), ttl);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Redis expire error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Получение оставшегося времени жизни ключа\r\n  async ttl(key) {\r\n    try {\r\n      const ttl = await redis.ttl(this.getKey(key));\r\n      return ttl;\r\n    } catch (error) {\r\n      console.error('Redis ttl error:', error);\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  // Очистка всего кеша с префиксом\r\n  async flush() {\r\n    try {\r\n      const keys = await redis.keys(this.getKey('*'));\r\n      if (keys.length > 0) {\r\n        await redis.del(...keys);\r\n      }\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Redis flush error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Кеширование результата функции\r\n  async cache(key, fn, ttl = this.defaultTTL) {\r\n    // Проверяем кеш\r\n    const cached = await this.get(key);\r\n    if (cached !== null) {\r\n      return cached;\r\n    }\r\n\r\n    // Выполняем функцию\r\n    const result = await fn();\r\n\r\n    // Сохраняем результат в кеш\r\n    await this.set(key, result, ttl);\r\n\r\n    return result;\r\n  }\r\n\r\n  // Инвалидация кеша для связанных сущностей\r\n  async invalidate(patterns) {\r\n    try {\r\n      const promises = patterns.map(pattern => this.deletePattern(pattern));\r\n      await Promise.all(promises);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Redis invalidate error:', error);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n// Создаем экземпляры для разных сервисов\r\nconst cacheManagers = {\r\n  auth: new CacheManager('vhm24:auth:'),\r\n  machines: new CacheManager('vhm24:machines:'),\r\n  inventory: new CacheManager('vhm24:inventory:'),\r\n  tasks: new CacheManager('vhm24:tasks:'),\r\n  reports: new CacheManager('vhm24:reports:'),\r\n  telegram: new CacheManager('vhm24:telegram:')\r\n};\r\n\r\n// Декоратор для кеширования методов\r\nfunction cacheable(keyGenerator, ttl) {\r\n  return function(target, propertyKey, descriptor) {\r\n    const originalMethod = descriptor.value;\r\n\r\n    descriptor.value = async function(...args) {\r\n      const cache = cacheManagers[this.serviceName] || new CacheManager();\r\n      const key = typeof keyGenerator === 'function' \r\n        ? keyGenerator.apply(this, args) \r\n        : keyGenerator;\r\n\r\n      return cache.cache(key, async () => {\r\n        return originalMethod.apply(this, args);\r\n      }, ttl);\r\n    };\r\n\r\n    return descriptor;\r\n  };\r\n}\r\n\r\n// Middleware для кеширования HTTP запросов\r\nfunction cacheMiddleware(options = {}) {\r\n  const {\r\n    keyGenerator = (req) => `${req.method}:${req.url}`,\r\n    ttl = 300, // 5 минут по умолчанию\r\n    serviceName = 'http',\r\n    condition = () => true\r\n  } = options;\r\n\r\n  const cache = cacheManagers[serviceName] || new CacheManager(`vhm24:${serviceName}:`);\r\n\r\n  return async (req, reply) => {\r\n    // Проверяем условие кеширования\r\n    if (!condition(req)) {\r\n      return;\r\n    }\r\n\r\n    const key = keyGenerator(req);\r\n\r\n    // Проверяем кеш для GET запросов\r\n    if (req.method === 'GET') {\r\n      const cached = await cache.get(key);\r\n      if (cached) {\r\n        reply.header('X-Cache', 'HIT');\r\n        return reply.send(cached);\r\n      }\r\n    }\r\n\r\n    // Перехватываем ответ для кеширования\r\n    const originalSend = reply.send.bind(reply);\r\n    reply.send = function(payload) {\r\n      // Кешируем успешные ответы\r\n      if (reply.statusCode >= 200 && reply.statusCode < 300) {\r\n        cache.set(key, payload, ttl).catch(err => {\r\n          console.error('Cache set error:', err);\r\n        });\r\n      }\r\n      reply.header('X-Cache', 'MISS');\r\n      return originalSend(payload);\r\n    };\r\n  };\r\n}\r\n\r\nmodule.exports = {\r\n  redis,\r\n  CacheManager,\r\n  cacheManagers,\r\n  cacheable,\r\n  cacheMiddleware\r\n};\r\n",
  "packages/shared/middleware/errorHandler.js": "/**\r\n * VHM24 Error Handler Middleware\r\n * Централизованная обработка ошибок для всех сервисов\r\n */\r\n\r\nconst { securityErrorHandler } = require('./security');\r\n\r\n/**\r\n * Кастомные классы ошибок\r\n */\r\nclass AppError extends Error {\r\n  constructor(message, statusCode = 500, name = 'AppError') {\r\n    super(message);\r\n    this.name = name;\r\n    this.statusCode = statusCode;\r\n    this.isOperational = true;\r\n    \r\n    Error.captureStackTrace(this, this.constructor);\r\n  }\r\n}\r\n\r\nclass ValidationError extends AppError {\r\n  constructor(message, details = []) {\r\n    super(message, 400, 'ValidationError');\r\n    this.details = details;\r\n  }\r\n}\r\n\r\nclass AuthenticationError extends AppError {\r\n  constructor(message = 'Authentication required') {\r\n    super(message, 401, 'UnauthorizedError');\r\n  }\r\n}\r\n\r\nclass AuthorizationError extends AppError {\r\n  constructor(message = 'Access denied') {\r\n    super(message, 403, 'ForbiddenError');\r\n  }\r\n}\r\n\r\nclass NotFoundError extends AppError {\r\n  constructor(message = 'Resource not found') {\r\n    super(message, 404, 'NotFoundError');\r\n  }\r\n}\r\n\r\nclass ConflictError extends AppError {\r\n  constructor(message = 'Resource conflict') {\r\n    super(message, 409, 'ConflictError');\r\n  }\r\n}\r\n\r\nclass RateLimitError extends AppError {\r\n  constructor(message = 'Rate limit exceeded') {\r\n    super(message, 429, 'TooManyRequestsError');\r\n  }\r\n}\r\n\r\nclass DatabaseError extends AppError {\r\n  constructor(message = 'Database operation failed') {\r\n    super(message, 500, 'DatabaseError');\r\n  }\r\n}\r\n\r\nclass ExternalServiceError extends AppError {\r\n  constructor(message = 'External service unavailable') {\r\n    super(message, 503, 'ExternalServiceError');\r\n  }\r\n}\r\n\r\n/**\r\n * Обработчик Prisma ошибок\r\n */\r\nconst handlePrismaError = (error) => {\r\n  const isDev = process.env.NODE_ENV === 'development';\r\n  \r\n  switch (error.code) {\r\n    case 'P2002':\r\n      // Unique constraint violation\r\n      const field = error.meta?.target?.[0] || 'field';\r\n      return new ConflictError(`${field} already exists`);\r\n      \r\n    case 'P2025':\r\n      // Record not found\r\n      return new NotFoundError('Record not found');\r\n      \r\n    case 'P2003':\r\n      // Foreign key constraint violation\r\n      return new ValidationError('Invalid reference to related record');\r\n      \r\n    case 'P2014':\r\n      // Required relation violation\r\n      return new ValidationError('Required relation is missing');\r\n      \r\n    case 'P2021':\r\n      // Table does not exist\r\n      return new DatabaseError(isDev ? error.message : 'Database schema error');\r\n      \r\n    case 'P2022':\r\n      // Column does not exist\r\n      return new DatabaseError(isDev ? error.message : 'Database schema error');\r\n      \r\n    default:\r\n      return new DatabaseError(isDev ? error.message : 'Database operation failed');\r\n  }\r\n};\r\n\r\n/**\r\n * Обработчик JWT ошибок\r\n */\r\nconst handleJWTError = (error) => {\r\n  switch (error.name) {\r\n    case 'JsonWebTokenError':\r\n      return new AuthenticationError('Invalid token');\r\n      \r\n    case 'TokenExpiredError':\r\n      return new AuthenticationError('Token expired');\r\n      \r\n    case 'NotBeforeError':\r\n      return new AuthenticationError('Token not active');\r\n      \r\n    default:\r\n      return new AuthenticationError('Authentication failed');\r\n  }\r\n};\r\n\r\n/**\r\n * Обработчик Fastify ошибок\r\n */\r\nconst handleFastifyError = (error) => {\r\n  const isDev = process.env.NODE_ENV === 'development';\r\n  \r\n  switch (error.code) {\r\n    case 'FST_ERR_VALIDATION':\r\n      return new ValidationError('Request validation failed', error.validation);\r\n      \r\n    case 'FST_ERR_NOT_FOUND':\r\n      return new NotFoundError('Route not found');\r\n      \r\n    case 'FST_ERR_BAD_STATUS_CODE':\r\n      return new AppError(isDev ? error.message : 'Invalid response', 500);\r\n      \r\n    case 'FST_ERR_ASYNC_CONSTRAINT':\r\n      return new AppError(isDev ? error.message : 'Server constraint violation', 500);\r\n      \r\n    default:\r\n      return new AppError(isDev ? error.message : 'Server error', error.statusCode || 500);\r\n  }\r\n};\r\n\r\n/**\r\n * Главный обработчик ошибок\r\n */\r\nconst errorHandler = (error, request, reply) => {\r\n  let processedError = error;\r\n\r\n  // Обрабатываем различные типы ошибок\r\n  if (error.name === 'PrismaClientKnownRequestError') {\r\n    processedError = handlePrismaError(error);\r\n  } else if (error.name?.includes('JsonWebToken') || error.name?.includes('Token')) {\r\n    processedError = handleJWTError(error);\r\n  } else if (error.code?.startsWith('FST_')) {\r\n    processedError = handleFastifyError(error);\r\n  } else if (!error.isOperational) {\r\n    // Неожиданная ошибка - логируем полностью и возвращаем общую ошибку\r\n    console.error('Unexpected Error:', {\r\n      error: error.message,\r\n      stack: error.stack,\r\n      url: request.url,\r\n      method: request.method,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n    \r\n    processedError = new AppError(\r\n      process.env.NODE_ENV === 'development' ? error.message : 'Internal server error',\r\n      500\r\n    );\r\n  }\r\n\r\n  // Используем безопасный обработчик ошибок\r\n  securityErrorHandler(processedError, request, reply);\r\n};\r\n\r\n/**\r\n * Async wrapper для обработки ошибок в async функциях\r\n */\r\nconst asyncHandler = (fn) => {\r\n  return (request, reply) => {\r\n    Promise.resolve(fn(request, reply)).catch((error) => {\r\n      errorHandler(error, request, reply);\r\n    });\r\n  };\r\n};\r\n\r\n/**\r\n * Middleware для обработки 404 ошибок\r\n */\r\nconst notFoundHandler = (request, reply) => {\r\n  reply.code(404).send({\r\n    error: 'Not Found',\r\n    message: `Route ${request.method} ${request.url} not found`,\r\n    statusCode: 404,\r\n    timestamp: new Date().toISOString()\r\n  });\r\n};\r\n\r\n/**\r\n * Обработчик необработанных Promise rejections\r\n */\r\nconst handleUnhandledRejection = (reason, promise) => {\r\n  console.error('Unhandled Promise Rejection:', {\r\n    reason: reason.message || reason,\r\n    stack: reason.stack,\r\n    promise: promise,\r\n    timestamp: new Date().toISOString()\r\n  });\r\n  \r\n  // В production можно добавить отправку в систему мониторинга\r\n  if (process.env.NODE_ENV === 'production') {\r\n    // Отправляем в систему мониторинга (например, Sentry)\r\n    // sentry.captureException(reason);\r\n  }\r\n};\r\n\r\n/**\r\n * Обработчик необработанных исключений\r\n */\r\nconst handleUncaughtException = (error) => {\r\n  console.error('Uncaught Exception:', {\r\n    error: error.message,\r\n    stack: error.stack,\r\n    timestamp: new Date().toISOString()\r\n  });\r\n  \r\n  // В production можно добавить отправку в систему мониторинга\r\n  if (process.env.NODE_ENV === 'production') {\r\n    // Отправляем в систему мониторинга\r\n    // sentry.captureException(error);\r\n    \r\n    // Graceful shutdown\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\n/**\r\n * Настройка глобальных обработчиков ошибок\r\n */\r\nconst setupGlobalErrorHandlers = () => {\r\n  process.on('unhandledRejection', handleUnhandledRejection);\r\n  process.on('uncaughtException', handleUncaughtException);\r\n  \r\n  // Graceful shutdown\r\n  process.on('SIGTERM', () => {\r\n    console.log('SIGTERM received, shutting down gracefully');\r\n    process.exit(0);\r\n  });\r\n  \r\n  process.on('SIGINT', () => {\r\n    console.log('SIGINT received, shutting down gracefully');\r\n    process.exit(0);\r\n  });\r\n};\r\n\r\n/**\r\n * Регистрация обработчиков ошибок в Fastify\r\n */\r\nconst registerErrorHandlers = (fastify) => {\r\n  // Основной обработчик ошибок\r\n  fastify.setErrorHandler(errorHandler);\r\n  \r\n  // Обработчик 404\r\n  fastify.setNotFoundHandler(notFoundHandler);\r\n  \r\n  // Хук для логирования ошибок\r\n  fastify.addHook('onError', async (request, reply, error) => {\r\n    const logLevel = error.statusCode >= 500 ? 'error' : 'warn';\r\n    \r\n    console[logLevel]('Request Error:', {\r\n      error: error.message,\r\n      statusCode: error.statusCode,\r\n      method: request.method,\r\n      url: request.url,\r\n      ip: request.ip,\r\n      userAgent: request.headers['user-agent'],\r\n      userId: request.user?.id,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Утилиты для создания ошибок\r\n */\r\nconst createError = {\r\n  validation: (message, details) => new ValidationError(message, details),\r\n  authentication: (message) => new AuthenticationError(message),\r\n  authorization: (message) => new AuthorizationError(message),\r\n  notFound: (message) => new NotFoundError(message),\r\n  conflict: (message) => new ConflictError(message),\r\n  rateLimit: (message) => new RateLimitError(message),\r\n  database: (message) => new DatabaseError(message),\r\n  externalService: (message) => new ExternalServiceError(message),\r\n  app: (message, statusCode, name) => new AppError(message, statusCode, name)\r\n};\r\n\r\n/**\r\n * Проверка является ли ошибка операционной\r\n */\r\nconst isOperationalError = (error) => {\r\n  return error instanceof AppError && error.isOperational;\r\n};\r\n\r\nmodule.exports = {\r\n  // Классы ошибок\r\n  AppError,\r\n  ValidationError,\r\n  AuthenticationError,\r\n  AuthorizationError,\r\n  NotFoundError,\r\n  ConflictError,\r\n  RateLimitError,\r\n  DatabaseError,\r\n  ExternalServiceError,\r\n  \r\n  // Обработчики\r\n  errorHandler,\r\n  asyncHandler,\r\n  notFoundHandler,\r\n  registerErrorHandlers,\r\n  setupGlobalErrorHandlers,\r\n  \r\n  // Утилиты\r\n  createError,\r\n  isOperationalError,\r\n  handlePrismaError,\r\n  handleJWTError,\r\n  handleFastifyError\r\n};\r\n",
  "packages/shared/utils/cache.js": "/**\r\n * VHM24 Cache Utility\r\n * Redis кеширование с автоматической сериализацией\r\n */\r\n\r\nconst Redis = require('ioredis');\r\nconst { logger, structuredLog } = require('./logger');\r\n\r\n/**\r\n * Создание Redis клиента\r\n */\r\nconst createRedisClient = () => {\r\n  const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';\r\n  \r\n  const redis = new Redis(redisUrl, {\r\n    retryDelayOnFailover: 100,\r\n    enableReadyCheck: false,\r\n    maxRetriesPerRequest: 3,\r\n    lazyConnect: true,\r\n    \r\n    // Настройки для production\r\n    ...(process.env.NODE_ENV === 'production' && {\r\n      connectTimeout: 10000,\r\n      commandTimeout: 5000,\r\n      retryDelayOnFailover: 100,\r\n      enableOfflineQueue: false\r\n    })\r\n  });\r\n\r\n  // Обработка событий Redis\r\n  redis.on('connect', () => {\r\n    logger.info('Redis connected');\r\n  });\r\n\r\n  redis.on('ready', () => {\r\n    logger.info('Redis ready');\r\n  });\r\n\r\n  redis.on('error', (error) => {\r\n    logger.error('Redis error:', error);\r\n  });\r\n\r\n  redis.on('close', () => {\r\n    logger.warn('Redis connection closed');\r\n  });\r\n\r\n  redis.on('reconnecting', () => {\r\n    logger.info('Redis reconnecting...');\r\n  });\r\n\r\n  return redis;\r\n};\r\n\r\n// Создаем основной Redis клиент\r\nconst redis = createRedisClient();\r\n\r\n/**\r\n * Базовый класс для кеширования\r\n */\r\nclass Cache {\r\n  constructor(prefix = 'vhm24', defaultTTL = 300) {\r\n    this.prefix = prefix;\r\n    this.defaultTTL = defaultTTL;\r\n    this.redis = redis;\r\n  }\r\n\r\n  /**\r\n   * Создание ключа с префиксом\r\n   */\r\n  _createKey(key) {\r\n    return `${this.prefix}:${key}`;\r\n  }\r\n\r\n  /**\r\n   * Получение данных из кеша\r\n   */\r\n  async get(key) {\r\n    try {\r\n      const cacheKey = this._createKey(key);\r\n      const data = await this.redis.get(cacheKey);\r\n      \r\n      if (data) {\r\n        structuredLog.cache.hit(key);\r\n        return JSON.parse(data);\r\n      } else {\r\n        structuredLog.cache.miss(key);\r\n        return null;\r\n      }\r\n    } catch (error) {\r\n      logger.error('Cache get error:', { key, error: error.message });\r\n      return null; // Возвращаем null при ошибке, чтобы не ломать приложение\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Сохранение данных в кеш\r\n   */\r\n  async set(key, value, ttl = this.defaultTTL) {\r\n    try {\r\n      const cacheKey = this._createKey(key);\r\n      const serializedValue = JSON.stringify(value);\r\n      \r\n      if (ttl > 0) {\r\n        await this.redis.setex(cacheKey, ttl, serializedValue);\r\n      } else {\r\n        await this.redis.set(cacheKey, serializedValue);\r\n      }\r\n      \r\n      structuredLog.cache.set(key, ttl);\r\n      return true;\r\n    } catch (error) {\r\n      logger.error('Cache set error:', { key, ttl, error: error.message });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Удаление данных из кеша\r\n   */\r\n  async del(key) {\r\n    try {\r\n      const cacheKey = this._createKey(key);\r\n      const result = await this.redis.del(cacheKey);\r\n      logger.debug('Cache delete:', { key, deleted: result > 0 });\r\n      return result > 0;\r\n    } catch (error) {\r\n      logger.error('Cache delete error:', { key, error: error.message });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Удаление по паттерну\r\n   */\r\n  async delPattern(pattern) {\r\n    try {\r\n      const cachePattern = this._createKey(pattern);\r\n      const keys = await this.redis.keys(cachePattern);\r\n      \r\n      if (keys.length > 0) {\r\n        const result = await this.redis.del(...keys);\r\n        logger.debug('Cache pattern delete:', { pattern, deletedCount: result });\r\n        return result;\r\n      }\r\n      \r\n      return 0;\r\n    } catch (error) {\r\n      logger.error('Cache pattern delete error:', { pattern, error: error.message });\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверка существования ключа\r\n   */\r\n  async exists(key) {\r\n    try {\r\n      const cacheKey = this._createKey(key);\r\n      const result = await this.redis.exists(cacheKey);\r\n      return result === 1;\r\n    } catch (error) {\r\n      logger.error('Cache exists error:', { key, error: error.message });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Установка TTL для существующего ключа\r\n   */\r\n  async expire(key, ttl) {\r\n    try {\r\n      const cacheKey = this._createKey(key);\r\n      const result = await this.redis.expire(cacheKey, ttl);\r\n      return result === 1;\r\n    } catch (error) {\r\n      logger.error('Cache expire error:', { key, ttl, error: error.message });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получение TTL ключа\r\n   */\r\n  async ttl(key) {\r\n    try {\r\n      const cacheKey = this._createKey(key);\r\n      return await this.redis.ttl(cacheKey);\r\n    } catch (error) {\r\n      logger.error('Cache TTL error:', { key, error: error.message });\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Инкремент значения\r\n   */\r\n  async incr(key, amount = 1) {\r\n    try {\r\n      const cacheKey = this._createKey(key);\r\n      return await this.redis.incrby(cacheKey, amount);\r\n    } catch (error) {\r\n      logger.error('Cache increment error:', { key, amount, error: error.message });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Декремент значения\r\n   */\r\n  async decr(key, amount = 1) {\r\n    try {\r\n      const cacheKey = this._createKey(key);\r\n      return await this.redis.decrby(cacheKey, amount);\r\n    } catch (error) {\r\n      logger.error('Cache decrement error:', { key, amount, error: error.message });\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Создание экземпляров кеша для разных целей\r\n */\r\nconst cache = new Cache('vhm24', 300); // Основной кеш, 5 минут\r\nconst sessionCache = new Cache('session', 3600); // Сессии, 1 час\r\nconst rateLimit = new Cache('rate_limit', 60); // Rate limiting, 1 минута\r\nconst tempCache = new Cache('temp', 30); // Временный кеш, 30 секунд\r\n\r\n/**\r\n * Декоратор для кеширования результатов функций\r\n */\r\nconst cacheResult = (keyGenerator, ttl = 300, cacheInstance = cache) => {\r\n  return (target, propertyName, descriptor) => {\r\n    const method = descriptor.value;\r\n    \r\n    descriptor.value = async function (...args) {\r\n      const cacheKey = typeof keyGenerator === 'function' \r\n        ? keyGenerator(...args) \r\n        : `${propertyName}:${JSON.stringify(args)}`;\r\n      \r\n      // Пытаемся получить из кеша\r\n      const cached = await cacheInstance.get(cacheKey);\r\n      if (cached !== null) {\r\n        return cached;\r\n      }\r\n      \r\n      // Выполняем функцию и кешируем результат\r\n      const result = await method.apply(this, args);\r\n      await cacheInstance.set(cacheKey, result, ttl);\r\n      \r\n      return result;\r\n    };\r\n    \r\n    return descriptor;\r\n  };\r\n};\r\n\r\n/**\r\n * Middleware для кеширования HTTP ответов\r\n */\r\nconst cacheMiddleware = (keyGenerator, ttl = 300) => {\r\n  return async (request, reply) => {\r\n    const cacheKey = typeof keyGenerator === 'function'\r\n      ? keyGenerator(request)\r\n      : `http:${request.method}:${request.url}`;\r\n    \r\n    // Проверяем кеш только для GET запросов\r\n    if (request.method === 'GET') {\r\n      const cached = await cache.get(cacheKey);\r\n      if (cached) {\r\n        reply.header('X-Cache', 'HIT');\r\n        return reply.send(cached);\r\n      }\r\n    }\r\n    \r\n    // Перехватываем ответ для кеширования\r\n    const originalSend = reply.send;\r\n    reply.send = function (payload) {\r\n      if (request.method === 'GET' && reply.statusCode === 200) {\r\n        cache.set(cacheKey, payload, ttl);\r\n        reply.header('X-Cache', 'MISS');\r\n      }\r\n      return originalSend.call(this, payload);\r\n    };\r\n  };\r\n};\r\n\r\n/**\r\n * Утилиты для работы с кешем\r\n */\r\nconst cacheUtils = {\r\n  /**\r\n   * Очистка кеша пользователя\r\n   */\r\n  clearUserCache: async (userId) => {\r\n    await cache.delPattern(`user:${userId}:*`);\r\n    await sessionCache.delPattern(`user:${userId}:*`);\r\n  },\r\n\r\n  /**\r\n   * Очистка кеша машины\r\n   */\r\n  clearMachineCache: async (machineId) => {\r\n    await cache.delPattern(`machine:${machineId}:*`);\r\n    await cache.delPattern(`inventory:machine:${machineId}:*`);\r\n  },\r\n\r\n  /**\r\n   * Очистка всего кеша\r\n   */\r\n  clearAll: async () => {\r\n    await redis.flushdb();\r\n    logger.info('All cache cleared');\r\n  },\r\n\r\n  /**\r\n   * Получение статистики кеша\r\n   */\r\n  getStats: async () => {\r\n    try {\r\n      const info = await redis.info('memory');\r\n      const keyspace = await redis.info('keyspace');\r\n      \r\n      return {\r\n        memory: info,\r\n        keyspace: keyspace,\r\n        connected: redis.status === 'ready'\r\n      };\r\n    } catch (error) {\r\n      logger.error('Cache stats error:', error);\r\n      return null;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Проверка здоровья кеша\r\n   */\r\n  healthCheck: async () => {\r\n    try {\r\n      const testKey = 'health_check';\r\n      const testValue = Date.now();\r\n      \r\n      await cache.set(testKey, testValue, 10);\r\n      const retrieved = await cache.get(testKey);\r\n      await cache.del(testKey);\r\n      \r\n      return retrieved === testValue;\r\n    } catch (error) {\r\n      logger.error('Cache health check failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Graceful shutdown\r\n */\r\nconst shutdown = async () => {\r\n  try {\r\n    await redis.quit();\r\n    logger.info('Redis connection closed gracefully');\r\n  } catch (error) {\r\n    logger.error('Error closing Redis connection:', error);\r\n  }\r\n};\r\n\r\n// Обработка завершения процесса\r\nprocess.on('SIGTERM', shutdown);\r\nprocess.on('SIGINT', shutdown);\r\n\r\nmodule.exports = {\r\n  // Основные экземпляры кеша\r\n  cache,\r\n  sessionCache,\r\n  rateLimit,\r\n  tempCache,\r\n  \r\n  // Класс для создания новых экземпляров\r\n  Cache,\r\n  \r\n  // Redis клиент\r\n  redis,\r\n  \r\n  // Декораторы и middleware\r\n  cacheResult,\r\n  cacheMiddleware,\r\n  \r\n  // Утилиты\r\n  cacheUtils,\r\n  \r\n  // Функции управления\r\n  createRedisClient,\r\n  shutdown\r\n};\r\n",
  "packages/shared/utils/config.js": "/**\r\n * VHM24 Configuration Utility\r\n * Централизованная конфигурация с валидацией\r\n */\r\n\r\nconst joi = require('joi');\r\n\r\n/**\r\n * Схема валидации environment переменных\r\n */\r\nconst envSchema = joi.object({\r\n  // Основные настройки\r\n  NODE_ENV: joi.string().valid('development', 'test', 'production').default('development'),\r\n  PORT: joi.number().port().default(3000),\r\n  HOST: joi.string().default('0.0.0.0'),\r\n  \r\n  // Сервис\r\n  SERVICE_NAME: joi.string().required(),\r\n  SERVICE_VERSION: joi.string().default('1.0.0'),\r\n  \r\n  // База данных\r\n  DATABASE_URL: joi.string().uri().required(),\r\n  DATABASE_POOL_SIZE: joi.number().min(1).max(50).default(10),\r\n  \r\n  // Redis\r\n  REDIS_URL: joi.string().uri().required(),\r\n  REDIS_POOL_SIZE: joi.number().min(1).max(20).default(5),\r\n  \r\n  // JWT\r\n  JWT_SECRET: joi.string().min(32).required(),\r\n  JWT_EXPIRES_IN: joi.string().default('7d'),\r\n  JWT_REFRESH_EXPIRES_IN: joi.string().default('30d'),\r\n  \r\n  // CORS\r\n  ALLOWED_ORIGINS: joi.string().default('http://localhost:3000,http://localhost:3001'),\r\n  \r\n  // Логирование\r\n  LOG_LEVEL: joi.string().valid('debug', 'info', 'warn', 'error').default('info'),\r\n  \r\n  // Rate Limiting\r\n  RATE_LIMIT_MAX: joi.number().min(1).default(100),\r\n  RATE_LIMIT_WINDOW: joi.string().default('1 minute'),\r\n  \r\n  // Файлы\r\n  UPLOAD_MAX_SIZE: joi.number().default(5242880), // 5MB\r\n  UPLOAD_ALLOWED_TYPES: joi.string().default('image/jpeg,image/png,image/gif,application/pdf'),\r\n  \r\n  // Внешние сервисы\r\n  TELEGRAM_BOT_TOKEN: joi.string().when('SERVICE_NAME', {\r\n    is: 'telegram-bot',\r\n    then: joi.required(),\r\n    otherwise: joi.optional()\r\n  }),\r\n  \r\n  // Мониторинг\r\n  SENTRY_DSN: joi.string().uri().allow('').optional(),\r\n  PROMETHEUS_ENABLED: joi.boolean().default(false),\r\n  PROMETHEUS_PORT: joi.number().port().default(9090),\r\n  \r\n  // Email (если нужно)\r\n  SMTP_HOST: joi.string().allow('').optional(),\r\n  SMTP_PORT: joi.number().port().optional(),\r\n  SMTP_USER: joi.string().allow('').optional(),\r\n  SMTP_PASS: joi.string().allow('').optional(),\r\n  \r\n  // Webhook URLs\r\n  WEBHOOK_SECRET: joi.string().optional(),\r\n  \r\n  // Backup\r\n  BACKUP_ENABLED: joi.boolean().default(false),\r\n  BACKUP_SCHEDULE: joi.string().default('0 2 * * *'), // Каждый день в 2:00\r\n  BACKUP_RETENTION_DAYS: joi.number().min(1).default(7),\r\n  \r\n  // Health checks\r\n  HEALTH_CHECK_TIMEOUT: joi.number().default(5000),\r\n  \r\n  // Graceful shutdown\r\n  SHUTDOWN_TIMEOUT: joi.number().default(10000)\r\n}).unknown(); // Разрешаем дополнительные переменные\r\n\r\n/**\r\n * Валидация и парсинг environment переменных\r\n */\r\nconst validateEnv = () => {\r\n  const { error, value: envVars } = envSchema.validate(process.env);\r\n\r\n  if (error) {\r\n    throw new Error(`Config validation error: ${error.message}`);\r\n  }\r\n\r\n  return envVars;\r\n};\r\n\r\n// Валидируем переменные при загрузке модуля\r\nconst env = validateEnv();\r\n\r\n/**\r\n * Основная конфигурация приложения\r\n */\r\nconst config = {\r\n  // Основные настройки\r\n  env: env.NODE_ENV,\r\n  isDev: env.NODE_ENV === 'development',\r\n  isTest: env.NODE_ENV === 'test',\r\n  isProd: env.NODE_ENV === 'production',\r\n  \r\n  // Сервер\r\n  server: {\r\n    host: env.HOST,\r\n    port: env.PORT,\r\n    name: env.SERVICE_NAME,\r\n    version: env.SERVICE_VERSION\r\n  },\r\n  \r\n  // База данных\r\n  database: {\r\n    url: env.DATABASE_URL,\r\n    poolSize: env.DATABASE_POOL_SIZE,\r\n    ssl: env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false\r\n  },\r\n  \r\n  // Redis\r\n  redis: {\r\n    url: env.REDIS_URL,\r\n    poolSize: env.REDIS_POOL_SIZE,\r\n    retryDelayOnFailover: 100,\r\n    enableReadyCheck: false,\r\n    maxRetriesPerRequest: 3,\r\n    lazyConnect: true\r\n  },\r\n  \r\n  // JWT\r\n  jwt: {\r\n    secret: env.JWT_SECRET,\r\n    expiresIn: env.JWT_EXPIRES_IN,\r\n    refreshExpiresIn: env.JWT_REFRESH_EXPIRES_IN,\r\n    algorithm: 'HS256'\r\n  },\r\n  \r\n  // CORS\r\n  cors: {\r\n    origins: env.ALLOWED_ORIGINS.split(',').map(origin => origin.trim()),\r\n    credentials: true,\r\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],\r\n    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'X-Correlation-ID']\r\n  },\r\n  \r\n  // Логирование\r\n  logging: {\r\n    level: env.LOG_LEVEL,\r\n    pretty: env.NODE_ENV === 'development'\r\n  },\r\n  \r\n  // Rate Limiting\r\n  rateLimit: {\r\n    max: env.RATE_LIMIT_MAX,\r\n    timeWindow: env.RATE_LIMIT_WINDOW,\r\n    skipOnError: true\r\n  },\r\n  \r\n  // Файлы\r\n  upload: {\r\n    maxSize: env.UPLOAD_MAX_SIZE,\r\n    allowedTypes: env.UPLOAD_ALLOWED_TYPES.split(',').map(type => type.trim()),\r\n    destination: './uploads'\r\n  },\r\n  \r\n  // Внешние сервисы\r\n  external: {\r\n    telegram: {\r\n      botToken: env.TELEGRAM_BOT_TOKEN\r\n    }\r\n  },\r\n  \r\n  // Мониторинг\r\n  monitoring: {\r\n    sentry: {\r\n      dsn: env.SENTRY_DSN,\r\n      enabled: !!env.SENTRY_DSN\r\n    },\r\n    prometheus: {\r\n      enabled: env.PROMETHEUS_ENABLED,\r\n      port: env.PROMETHEUS_PORT\r\n    }\r\n  },\r\n  \r\n  // Email\r\n  email: {\r\n    smtp: {\r\n      host: env.SMTP_HOST,\r\n      port: env.SMTP_PORT,\r\n      auth: env.SMTP_USER && env.SMTP_PASS ? {\r\n        user: env.SMTP_USER,\r\n        pass: env.SMTP_PASS\r\n      } : null\r\n    }\r\n  },\r\n  \r\n  // Webhook\r\n  webhook: {\r\n    secret: env.WEBHOOK_SECRET\r\n  },\r\n  \r\n  // Backup\r\n  backup: {\r\n    enabled: env.BACKUP_ENABLED,\r\n    schedule: env.BACKUP_SCHEDULE,\r\n    retentionDays: env.BACKUP_RETENTION_DAYS\r\n  },\r\n  \r\n  // Health checks\r\n  health: {\r\n    timeout: env.HEALTH_CHECK_TIMEOUT\r\n  },\r\n  \r\n  // Graceful shutdown\r\n  shutdown: {\r\n    timeout: env.SHUTDOWN_TIMEOUT\r\n  }\r\n};\r\n\r\n/**\r\n * Получение конфигурации по пути\r\n */\r\nconst get = (path, defaultValue = undefined) => {\r\n  const keys = path.split('.');\r\n  let current = config;\r\n  \r\n  for (const key of keys) {\r\n    if (current && typeof current === 'object' && key in current) {\r\n      current = current[key];\r\n    } else {\r\n      return defaultValue;\r\n    }\r\n  }\r\n  \r\n  return current;\r\n};\r\n\r\n/**\r\n * Проверка обязательных конфигураций для сервиса\r\n */\r\nconst validateServiceConfig = (serviceName) => {\r\n  const requiredConfigs = {\r\n    'auth': ['jwt.secret', 'database.url'],\r\n    'gateway': ['jwt.secret', 'cors.origins'],\r\n    'machines': ['database.url'],\r\n    'inventory': ['database.url'],\r\n    'tasks': ['database.url'],\r\n    'telegram-bot': ['external.telegram.botToken', 'database.url'],\r\n    'notifications': ['database.url'],\r\n    'monitoring': ['database.url'],\r\n    'backup': ['database.url']\r\n  };\r\n  \r\n  const required = requiredConfigs[serviceName] || [];\r\n  const missing = [];\r\n  \r\n  for (const configPath of required) {\r\n    if (get(configPath) === undefined) {\r\n      missing.push(configPath);\r\n    }\r\n  }\r\n  \r\n  if (missing.length > 0) {\r\n    throw new Error(`Missing required configuration for ${serviceName}: ${missing.join(', ')}`);\r\n  }\r\n  \r\n  return true;\r\n};\r\n\r\n/**\r\n * Создание конфигурации для Fastify\r\n */\r\nconst createFastifyConfig = () => {\r\n  return {\r\n    logger: config.logging.pretty ? {\r\n      transport: {\r\n        target: 'pino-pretty',\r\n        options: {\r\n          colorize: true,\r\n          translateTime: 'UTC:yyyy-mm-dd HH:MM:ss.l'\r\n        }\r\n      }\r\n    } : true,\r\n    \r\n    trustProxy: config.isProd,\r\n    \r\n    // Настройки для production\r\n    ...(config.isProd && {\r\n      keepAliveTimeout: 30000,\r\n      requestTimeout: 30000,\r\n      bodyLimit: config.upload.maxSize\r\n    })\r\n  };\r\n};\r\n\r\n/**\r\n * Создание конфигурации для Prisma\r\n */\r\nconst createPrismaConfig = () => {\r\n  return {\r\n    datasources: {\r\n      db: {\r\n        url: config.database.url\r\n      }\r\n    },\r\n    log: config.isDev ? ['query', 'info', 'warn', 'error'] : ['warn', 'error']\r\n  };\r\n};\r\n\r\n/**\r\n * Создание конфигурации для Redis\r\n */\r\nconst createRedisConfig = () => {\r\n  return {\r\n    ...config.redis,\r\n    // Дополнительные настройки для production\r\n    ...(config.isProd && {\r\n      connectTimeout: 10000,\r\n      commandTimeout: 5000,\r\n      enableOfflineQueue: false\r\n    })\r\n  };\r\n};\r\n\r\n/**\r\n * Вывод конфигурации в консоль (без секретов)\r\n */\r\nconst printConfig = () => {\r\n  const safeToPrint = { ...config };\r\n  \r\n  // Маскируем секретные данные\r\n  if (safeToPrint.jwt) safeToPrint.jwt.secret = '***';\r\n  if (safeToPrint.database) safeToPrint.database.url = safeToPrint.database.url.replace(/:\\/\\/.*@/, '://***@');\r\n  if (safeToPrint.redis) safeToPrint.redis.url = safeToPrint.redis.url.replace(/:\\/\\/.*@/, '://***@');\r\n  if (safeToPrint.external?.telegram) safeToPrint.external.telegram.botToken = '***';\r\n  if (safeToPrint.email?.smtp?.auth) {\r\n    safeToPrint.email.smtp.auth.user = '***';\r\n    safeToPrint.email.smtp.auth.pass = '***';\r\n  }\r\n  \r\n  console.log('Configuration loaded:', JSON.stringify(safeToPrint, null, 2));\r\n};\r\n\r\n/**\r\n * Проверка готовности конфигурации\r\n */\r\nconst isReady = () => {\r\n  try {\r\n    validateServiceConfig(config.server.name);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Configuration not ready:', error.message);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Получение переменных окружения для конкретного сервиса\r\n */\r\nconst getServiceEnv = (serviceName) => {\r\n  const serviceEnvs = {\r\n    'auth': {\r\n      SERVICE_NAME: 'auth',\r\n      PORT: 3001\r\n    },\r\n    'gateway': {\r\n      SERVICE_NAME: 'gateway',\r\n      PORT: 8000\r\n    },\r\n    'machines': {\r\n      SERVICE_NAME: 'machines',\r\n      PORT: 3002\r\n    },\r\n    'inventory': {\r\n      SERVICE_NAME: 'inventory',\r\n      PORT: 3003\r\n    },\r\n    'tasks': {\r\n      SERVICE_NAME: 'tasks',\r\n      PORT: 3004\r\n    },\r\n    'telegram-bot': {\r\n      SERVICE_NAME: 'telegram-bot',\r\n      PORT: 3005\r\n    },\r\n    'notifications': {\r\n      SERVICE_NAME: 'notifications',\r\n      PORT: 3006\r\n    },\r\n    'monitoring': {\r\n      SERVICE_NAME: 'monitoring',\r\n      PORT: 3007\r\n    },\r\n    'backup': {\r\n      SERVICE_NAME: 'backup',\r\n      PORT: 3008\r\n    }\r\n  };\r\n  \r\n  return serviceEnvs[serviceName] || {};\r\n};\r\n\r\nmodule.exports = {\r\n  // Основная конфигурация\r\n  config,\r\n  \r\n  // Функции доступа\r\n  get,\r\n  \r\n  // Валидация\r\n  validateServiceConfig,\r\n  isReady,\r\n  \r\n  // Создание конфигураций для библиотек\r\n  createFastifyConfig,\r\n  createPrismaConfig,\r\n  createRedisConfig,\r\n  \r\n  // Утилиты\r\n  printConfig,\r\n  getServiceEnv,\r\n  \r\n  // Прямой доступ к env\r\n  env\r\n};\r\n",
  "railway-deploy.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Railway Deployment Script\r\n * Запускает все сервисы в одном процессе для Railway\r\n */\r\n\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n\r\n// Загружаем переменные окружения\r\ntry {\r\n  require('dotenv').config();\r\n} catch (error) {\r\n  console.log('⚠️  dotenv not available, using environment variables');\r\n}\r\n\r\nconsole.log('🚂 VHM24 Railway Deployment Starting...');\r\nconsole.log(`📍 Environment: ${process.env.NODE_ENV || 'production'}`);\r\nconsole.log(`🔌 Port: ${process.env.PORT || 8000}`);\r\n\r\n// Устанавливаем переменные окружения\r\nprocess.env.NODE_ENV = process.env.NODE_ENV || 'production';\r\nprocess.env.PORT = process.env.PORT || '8000';\r\n\r\n// Проверяем обязательные переменные\r\nconst requiredEnvVars = ['DATABASE_URL'];\r\nconst missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\r\n\r\nif (missingVars.length > 0) {\r\n  console.error('❌ Missing required environment variables:', missingVars.join(', '));\r\n  process.exit(1);\r\n}\r\n\r\n// Функция для запуска сервиса\r\nasync function startService(serviceName, servicePath, port) {\r\n  try {\r\n    console.log(`🚀 Starting ${serviceName} service on port ${port}...`);\r\n    \r\n    // Устанавливаем порт для сервиса\r\n    process.env[`${serviceName.toUpperCase()}_PORT`] = port;\r\n    \r\n    // Запускаем сервис\r\n    require(servicePath);\r\n    \r\n    console.log(`✅ ${serviceName} service started successfully`);\r\n    return true;\r\n  } catch (error) {\r\n    console.error(`❌ Failed to start ${serviceName} service:`, error.message);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Основная функция\r\nasync function deployToRailway() {\r\n  try {\r\n    console.log('🔧 Initializing Railway deployment...');\r\n    \r\n    // Генерируем Prisma клиент если нужно\r\n    if (fs.existsSync('packages/database/prisma/schema.prisma')) {\r\n      console.log('🔧 Checking Prisma client...');\r\n      try {\r\n        const { getAuthClient } = require('./packages/database');\r\n        await getAuthClient().$connect();\r\n        console.log('✅ Prisma client is ready');\r\n      } catch (error) {\r\n        console.log('⚠️  Prisma client needs generation, this is normal on first deploy');\r\n      }\r\n    }\r\n\r\n    // Запускаем сервисы последовательно\r\n    const services = [\r\n      { name: 'Auth', path: './services/auth/src/index.js', port: 3001 },\r\n      { name: 'Machines', path: './services/machines/src/index.js', port: 3002 },\r\n      { name: 'Inventory', path: './services/inventory/src/index.js', port: 3003 },\r\n      { name: 'Tasks', path: './services/tasks/src/index.js', port: 3004 },\r\n      { name: 'Bunkers', path: './services/bunkers/src/index.js', port: 3005 },\r\n      { name: 'Notifications', path: './services/notifications/src/index.js', port: 3006 }\r\n    ];\r\n\r\n    // Запускаем сервисы в фоне\r\n    for (const service of services) {\r\n      if (fs.existsSync(service.path)) {\r\n        setTimeout(() => {\r\n          startService(service.name, service.path, service.port);\r\n        }, 1000); // Небольшая задержка между запусками\r\n      } else {\r\n        console.log(`⚠️  Service ${service.name} not found at ${service.path}`);\r\n      }\r\n    }\r\n\r\n    // Запускаем Telegram Bot если токен есть\r\n    if (process.env.TELEGRAM_BOT_TOKEN && fs.existsSync('./services/telegram-bot/src/index.js')) {\r\n      setTimeout(() => {\r\n        console.log('🤖 Starting Telegram Bot...');\r\n        require('./services/telegram-bot/src/index.js');\r\n      }, 2000);\r\n    }\r\n\r\n    // Запускаем Gateway последним (основной сервис)\r\n    setTimeout(() => {\r\n      console.log('📡 Starting Gateway service (main)...');\r\n      require('./services/gateway/src/index.js');\r\n    }, 3000);\r\n\r\n    console.log('🎉 All services initialization started!');\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Railway deployment failed:', error.message);\r\n    console.error('Stack trace:', error.stack);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Обработка сигналов\r\nprocess.on('SIGTERM', () => {\r\n  console.log('🛑 Received SIGTERM, shutting down...');\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('SIGINT', () => {\r\n  console.log('🛑 Received SIGINT, shutting down...');\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('uncaughtException', (error) => {\r\n  console.error('❌ Uncaught Exception:', error);\r\n  process.exit(1);\r\n});\r\n\r\nprocess.on('unhandledRejection', (reason, promise) => {\r\n  console.error('❌ Unhandled Rejection:', reason);\r\n  process.exit(1);\r\n});\r\n\r\n// Запускаем деплой\r\ndeployToRailway();\r\n",
  "railway-migrate.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Railway Database Migration Script\r\n * Запускает миграции базы данных для Railway\r\n */\r\n\r\nconst { spawn } = require('child_process');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n\r\n// Загружаем переменные окружения\r\ntry {\r\n  require('dotenv').config();\r\n} catch (error) {\r\n  console.log('⚠️  dotenv not available, using environment variables');\r\n}\r\n\r\nconsole.log('🗄️  VHM24 Railway Database Migration Starting...');\r\nconsole.log(`📍 Environment: ${process.env.NODE_ENV || 'production'}`);\r\n\r\n// Проверяем обязательные переменные\r\nif (!process.env.DATABASE_URL) {\r\n  console.error('❌ DATABASE_URL is required for migration');\r\n  process.exit(1);\r\n}\r\n\r\n// Функция для запуска команды\r\nfunction runCommand(command, args = [], options = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    console.log(`🔧 Running: ${command} ${args.join(' ')}`);\r\n    \r\n    const child = spawn(command, args, {\r\n      stdio: 'inherit',\r\n      shell: true,\r\n      cwd: path.join(__dirname, 'packages/database'),\r\n      ...options\r\n    });\r\n\r\n    child.on('close', (code) => {\r\n      if (code === 0) {\r\n        resolve();\r\n      } else {\r\n        reject(new Error(`Command failed with code ${code}`));\r\n      }\r\n    });\r\n\r\n    child.on('error', reject);\r\n  });\r\n}\r\n\r\n// Основная функция миграции\r\nasync function migrateDatabase() {\r\n  try {\r\n    console.log('🔧 Starting database migration...');\r\n    \r\n    // Проверяем наличие schema.prisma\r\n    const schemaPath = path.join(__dirname, 'packages/database/prisma/schema.prisma');\r\n    if (!fs.existsSync(schemaPath)) {\r\n      throw new Error('Prisma schema not found at packages/database/prisma/schema.prisma');\r\n    }\r\n    \r\n    console.log('✅ Prisma schema found');\r\n    \r\n    // Генерируем Prisma клиент\r\n    console.log('🔧 Generating Prisma client...');\r\n    await runCommand('npx', ['prisma', 'generate']);\r\n    console.log('✅ Prisma client generated');\r\n    \r\n    // Запускаем миграции\r\n    console.log('🔧 Running database migrations...');\r\n    await runCommand('npx', ['prisma', 'migrate', 'deploy']);\r\n    console.log('✅ Database migrations completed');\r\n    \r\n    // Проверяем подключение к базе данных\r\n    console.log('🔧 Testing database connection...');\r\n    const { getAuthClient } = require('./packages/database');\r\n    const prisma = getAuthClient();\r\n    \r\n    await prisma.$connect();\r\n    console.log('✅ Database connection successful');\r\n    \r\n    // Проверяем наличие таблиц\r\n    const userCount = await prisma.user.count();\r\n    console.log(`📊 Users in database: ${userCount}`);\r\n    \r\n    // Создаем администратора если нет пользователей\r\n    if (userCount === 0) {\r\n      console.log('🔧 Creating default admin user...');\r\n      const bcrypt = require('bcrypt');\r\n      \r\n      const adminUser = await prisma.user.create({\r\n        data: {\r\n          email: 'admin@vhm24.ru',\r\n          name: 'System Administrator',\r\n          passwordHash: await bcrypt.hash('admin123', 10),\r\n          telegramId: process.env.ADMIN_IDS || '42283329',\r\n          roles: ['ADMIN'],\r\n          isActive: true\r\n        }\r\n      });\r\n      \r\n      console.log('✅ Default admin user created');\r\n      console.log(`📧 Email: admin@vhm24.ru`);\r\n      console.log(`🔑 Password: admin123`);\r\n      console.log(`📱 Telegram ID: ${adminUser.telegramId}`);\r\n    }\r\n    \r\n    await prisma.$disconnect();\r\n    console.log('🎉 Database migration completed successfully!');\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Database migration failed:', error.message);\r\n    console.error('Stack trace:', error.stack);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Запускаем миграцию\r\nmigrateDatabase();\r\n",
  "railway-start-final.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Railway Final Start Script\r\n * Объединяет миграцию и запуск приложения в одном скрипте\r\n */\r\n\r\nconst { spawn } = require('child_process');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n\r\n// Загружаем переменные окружения\r\ntry {\r\n  require('dotenv').config();\r\n} catch (error) {\r\n  console.log('⚠️  dotenv not available, using environment variables');\r\n}\r\n\r\nconsole.log('🚂 VHM24 Railway Final Start...');\r\nconsole.log(`📍 Environment: ${process.env.NODE_ENV || 'production'}`);\r\nconsole.log(`🔌 Port: ${process.env.PORT || 8000}`);\r\n\r\n// Устанавливаем переменные окружения\r\nprocess.env.NODE_ENV = process.env.NODE_ENV || 'production';\r\nprocess.env.PORT = process.env.PORT || '8000';\r\n\r\n// Проверяем обязательные переменные\r\nif (!process.env.DATABASE_URL) {\r\n  console.error('❌ DATABASE_URL is required for Railway deployment');\r\n  process.exit(1);\r\n}\r\n\r\n// Функция для запуска команды\r\nfunction runCommand(command, args = [], options = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    console.log(`🔧 Running: ${command} ${args.join(' ')}`);\r\n    \r\n    const child = spawn(command, args, {\r\n      stdio: 'inherit',\r\n      shell: true,\r\n      ...options\r\n    });\r\n\r\n    child.on('close', (code) => {\r\n      if (code === 0) {\r\n        resolve();\r\n      } else {\r\n        reject(new Error(`Command failed with code ${code}`));\r\n      }\r\n    });\r\n\r\n    child.on('error', reject);\r\n  });\r\n}\r\n\r\n// Функция для запуска сервиса\r\nasync function startService(serviceName, servicePath, port) {\r\n  try {\r\n    console.log(`🚀 Starting ${serviceName} service on port ${port}...`);\r\n    \r\n    // Устанавливаем порт для сервиса\r\n    process.env[`${serviceName.toUpperCase()}_PORT`] = port;\r\n    \r\n    // Запускаем сервис\r\n    require(servicePath);\r\n    \r\n    console.log(`✅ ${serviceName} service started successfully`);\r\n    return true;\r\n  } catch (error) {\r\n    console.error(`❌ Failed to start ${serviceName} service:`, error.message);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Основная функция\r\nasync function startRailwayApp() {\r\n  try {\r\n    console.log('🗄️  === DATABASE MIGRATION PHASE ===');\r\n    \r\n    // Проверяем наличие schema.prisma\r\n    const schemaPath = path.join(__dirname, 'packages/database/prisma/schema.prisma');\r\n    if (!fs.existsSync(schemaPath)) {\r\n      throw new Error('Prisma schema not found at packages/database/prisma/schema.prisma');\r\n    }\r\n    \r\n    console.log('✅ Prisma schema found');\r\n    \r\n    // Генерируем Prisma клиент\r\n    console.log('🔧 Generating Prisma client...');\r\n    await runCommand('npx', ['prisma', 'generate'], {\r\n      cwd: path.join(__dirname, 'packages/database')\r\n    });\r\n    console.log('✅ Prisma client generated');\r\n    \r\n    // Запускаем миграции\r\n    console.log('🔧 Running database migrations...');\r\n    await runCommand('npx', ['prisma', 'migrate', 'deploy'], {\r\n      cwd: path.join(__dirname, 'packages/database')\r\n    });\r\n    console.log('✅ Database migrations completed');\r\n    \r\n    // Проверяем подключение к базе данных\r\n    console.log('🔧 Testing database connection...');\r\n    const { getAuthClient } = require('./packages/database');\r\n    const prisma = getAuthClient();\r\n    \r\n    await prisma.$connect();\r\n    console.log('✅ Database connection successful');\r\n    \r\n    // Проверяем наличие пользователей\r\n    const userCount = await prisma.user.count();\r\n    console.log(`📊 Users in database: ${userCount}`);\r\n    \r\n    // Создаем администратора если нет пользователей\r\n    if (userCount === 0) {\r\n      console.log('🔧 Creating default admin user...');\r\n      const bcrypt = require('bcrypt');\r\n      \r\n      const adminUser = await prisma.user.create({\r\n        data: {\r\n          email: 'admin@vhm24.ru',\r\n          name: 'System Administrator',\r\n          passwordHash: await bcrypt.hash('admin123', 10),\r\n          telegramId: process.env.ADMIN_IDS || '42283329',\r\n          roles: ['ADMIN'],\r\n          isActive: true\r\n        }\r\n      });\r\n      \r\n      console.log('✅ Default admin user created');\r\n      console.log(`📧 Email: admin@vhm24.ru`);\r\n      console.log(`🔑 Password: admin123`);\r\n      console.log(`📱 Telegram ID: ${adminUser.telegramId}`);\r\n    }\r\n    \r\n    await prisma.$disconnect();\r\n    console.log('🎉 Database migration completed successfully!');\r\n    \r\n    console.log('\\n🚂 === APPLICATION DEPLOYMENT PHASE ===');\r\n    \r\n    // Запускаем сервисы последовательно\r\n    const services = [\r\n      { name: 'Auth', path: './services/auth/src/index.js', port: 3001 },\r\n      { name: 'Machines', path: './services/machines/src/index.js', port: 3002 },\r\n      { name: 'Inventory', path: './services/inventory/src/index.js', port: 3003 },\r\n      { name: 'Tasks', path: './services/tasks/src/index.js', port: 3004 },\r\n      { name: 'Bunkers', path: './services/bunkers/src/index.js', port: 3005 },\r\n      { name: 'Notifications', path: './services/notifications/src/index.js', port: 3006 }\r\n    ];\r\n\r\n    // Запускаем сервисы в фоне\r\n    for (const service of services) {\r\n      if (fs.existsSync(service.path)) {\r\n        setTimeout(() => {\r\n          startService(service.name, service.path, service.port);\r\n        }, 1000); // Небольшая задержка между запусками\r\n      } else {\r\n        console.log(`⚠️  Service ${service.name} not found at ${service.path}`);\r\n      }\r\n    }\r\n\r\n    // Запускаем Telegram Bot если токен есть\r\n    if (process.env.TELEGRAM_BOT_TOKEN && fs.existsSync('./services/telegram-bot/src/index.js')) {\r\n      setTimeout(() => {\r\n        console.log('🤖 Starting Telegram Bot...');\r\n        require('./services/telegram-bot/src/index.js');\r\n      }, 2000);\r\n    }\r\n\r\n    // Запускаем Gateway последним (основной сервис)\r\n    setTimeout(() => {\r\n      console.log('📡 Starting Gateway service (main)...');\r\n      require('./services/gateway/src/index.js');\r\n    }, 3000);\r\n\r\n    console.log('🎉 All services initialization started!');\r\n    console.log(`🌐 Application will be available on port ${process.env.PORT}`);\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Railway deployment failed:', error.message);\r\n    console.error('Stack trace:', error.stack);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Обработка сигналов\r\nprocess.on('SIGTERM', () => {\r\n  console.log('🛑 Received SIGTERM, shutting down...');\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('SIGINT', () => {\r\n  console.log('🛑 Received SIGINT, shutting down...');\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('uncaughtException', (error) => {\r\n  console.error('❌ Uncaught Exception:', error);\r\n  process.exit(1);\r\n});\r\n\r\nprocess.on('unhandledRejection', (reason, promise) => {\r\n  console.error('❌ Unhandled Rejection:', reason);\r\n  process.exit(1);\r\n});\r\n\r\n// Запускаем приложение\r\nstartRailwayApp();\r\n",
  "railway-start-simple.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * VHM24 Railway Simple Start Script\r\n * Простой запуск для Railway без сложной логики\r\n */\r\n\r\nconst Fastify = require('fastify');\r\n\r\nconsole.log('🚂 VHM24 Railway Simple Start...');\r\nconsole.log(`📍 Environment: ${process.env.NODE_ENV || 'production'}`);\r\nconsole.log(`🔌 Port: ${process.env.PORT || 8000}`);\r\n\r\n// Создаем простой Fastify сервер\r\nconst fastify = Fastify({\r\n  logger: true\r\n});\r\n\r\n// Health check endpoint\r\nfastify.get('/health', async (request, reply) => {\r\n  return { \r\n    status: 'ok', \r\n    service: 'vhm24-simple',\r\n    timestamp: new Date().toISOString(),\r\n    environment: process.env.NODE_ENV || 'production',\r\n    port: process.env.PORT || 8000\r\n  };\r\n});\r\n\r\n// Root endpoint\r\nfastify.get('/', async (request, reply) => {\r\n  reply.type('text/html');\r\n  return `\r\n    <!DOCTYPE html>\r\n    <html>\r\n    <head>\r\n      <title>VHM24 - Railway Deployment Success</title>\r\n      <style>\r\n        body { \r\n          font-family: Arial, sans-serif; \r\n          margin: 40px; \r\n          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n          color: white;\r\n          text-align: center;\r\n        }\r\n        .container { \r\n          max-width: 800px; \r\n          margin: 0 auto; \r\n          padding: 40px;\r\n          background: rgba(255,255,255,0.1);\r\n          border-radius: 20px;\r\n          backdrop-filter: blur(10px);\r\n        }\r\n        .success { color: #4CAF50; font-size: 2em; margin: 20px 0; }\r\n        .endpoint { \r\n          margin: 10px 0; \r\n          padding: 10px; \r\n          background: rgba(255,255,255,0.2); \r\n          border-radius: 10px; \r\n        }\r\n      </style>\r\n    </head>\r\n    <body>\r\n      <div class=\"container\">\r\n        <h1>🎉 VHM24 Railway Deployment</h1>\r\n        <div class=\"success\">✅ УСПЕШНО РАЗВЕРНУТО!</div>\r\n        \r\n        <h2>📊 Информация о системе:</h2>\r\n        <div class=\"endpoint\">🌍 Environment: ${process.env.NODE_ENV || 'production'}</div>\r\n        <div class=\"endpoint\">🔌 Port: ${process.env.PORT || 8000}</div>\r\n        <div class=\"endpoint\">🚂 Railway URL: ${process.env.RAILWAY_STATIC_URL || 'N/A'}</div>\r\n        <div class=\"endpoint\">⏰ Deployed: ${new Date().toISOString()}</div>\r\n        \r\n        <h2>🔗 Доступные endpoints:</h2>\r\n        <div class=\"endpoint\">GET /health - Health check</div>\r\n        <div class=\"endpoint\">GET / - Эта страница</div>\r\n        \r\n        <h2>🎯 Следующие шаги:</h2>\r\n        <p>1. Проверить health endpoint: <code>/health</code></p>\r\n        <p>2. Настроить переменные окружения для полной функциональности</p>\r\n        <p>3. Добавить API endpoints по мере необходимости</p>\r\n        \r\n        <div style=\"margin-top: 40px; font-size: 0.9em; opacity: 0.8;\">\r\n          VHM24 - VendHub Manager 24/7<br>\r\n          Railway Deployment Test - Version 1.0.0\r\n        </div>\r\n      </div>\r\n    </body>\r\n    </html>\r\n  `;\r\n});\r\n\r\n// API Documentation endpoint\r\nfastify.get('/docs', async (request, reply) => {\r\n  reply.type('text/html');\r\n  return `\r\n    <!DOCTYPE html>\r\n    <html>\r\n    <head>\r\n      <title>VHM24 API Documentation</title>\r\n      <style>\r\n        body { font-family: Arial, sans-serif; margin: 40px; }\r\n        .endpoint { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }\r\n        .method { font-weight: bold; color: #007bff; }\r\n      </style>\r\n    </head>\r\n    <body>\r\n      <h1>🤖 VHM24 API Documentation</h1>\r\n      <p>VendHub Manager 24/7 - Railway Test Deployment</p>\r\n      \r\n      <div class=\"endpoint\">\r\n        <div class=\"method\">GET /</div>\r\n        <p>Main page with deployment information</p>\r\n      </div>\r\n      \r\n      <div class=\"endpoint\">\r\n        <div class=\"method\">GET /health</div>\r\n        <p>Health check endpoint</p>\r\n      </div>\r\n      \r\n      <div class=\"endpoint\">\r\n        <div class=\"method\">GET /docs</div>\r\n        <p>This documentation page</p>\r\n      </div>\r\n      \r\n      <p><strong>Status:</strong> Railway deployment test successful</p>\r\n      <p><strong>Environment:</strong> ${process.env.NODE_ENV || 'production'}</p>\r\n      <p><strong>Version:</strong> 1.0.0</p>\r\n    </body>\r\n    </html>\r\n  `;\r\n});\r\n\r\n// Запускаем сервер\r\nconst start = async () => {\r\n  try {\r\n    const port = process.env.PORT || 8000;\r\n    await fastify.listen({ \r\n      port: port,\r\n      host: '0.0.0.0'\r\n    });\r\n    \r\n    console.log(`🎉 VHM24 Simple is running on port ${port}`);\r\n    console.log(`🌐 Health check: http://localhost:${port}/health`);\r\n    console.log(`📚 Documentation: http://localhost:${port}/docs`);\r\n    \r\n    // Railway specific logging\r\n    if (process.env.RAILWAY_ENVIRONMENT) {\r\n      console.log('🚂 Running on Railway:', process.env.RAILWAY_STATIC_URL);\r\n      console.log('🔗 Public URL:', `https://${process.env.RAILWAY_STATIC_URL}`);\r\n    }\r\n    \r\n  } catch (err) {\r\n    console.error('❌ Server failed to start:', err);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\n// Обработка сигналов\r\nprocess.on('SIGTERM', async () => {\r\n  console.log('🛑 Received SIGTERM, shutting down...');\r\n  await fastify.close();\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('SIGINT', async () => {\r\n  console.log('🛑 Received SIGINT, shutting down...');\r\n  await fastify.close();\r\n  process.exit(0);\r\n});\r\n\r\n// Запускаем приложение\r\nstart();\r\n",
  "railway-start.js": "#!/usr/bin/env node\r\n\r\nconst { spawn } = require('child_process');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n\r\n// Определяем окружение\r\nconst isRailway = process.env.RAILWAY_ENVIRONMENT || process.env.RAILWAY_STATIC_URL || process.env.RAILWAY_PROJECT_ID;\r\nconst isProduction = process.env.NODE_ENV === 'production' || isRailway;\r\n\r\nconsole.log('🚀 VHM24 Platform Starting...');\r\nconsole.log(`📍 Environment: ${isProduction ? 'Production' : 'Development'}`);\r\nconsole.log(`🚂 Railway: ${isRailway ? 'Yes' : 'No'}`);\r\n\r\n// Функция для запуска процесса\r\nfunction startProcess(command, args = [], options = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    console.log(`🔧 Running: ${command} ${args.join(' ')}`);\r\n    \r\n    const child = spawn(command, args, {\r\n      stdio: 'inherit',\r\n      shell: true,\r\n      ...options\r\n    });\r\n\r\n    child.on('close', (code) => {\r\n      if (code === 0) {\r\n        resolve();\r\n      } else {\r\n        reject(new Error(`Process exited with code ${code}`));\r\n      }\r\n    });\r\n\r\n    child.on('error', reject);\r\n  });\r\n}\r\n\r\n// Основная функция запуска\r\nasync function start() {\r\n  try {\r\n    // Устанавливаем переменные окружения по умолчанию\r\n    process.env.PORT = process.env.PORT || '8000';\r\n    process.env.NODE_ENV = process.env.NODE_ENV || (isRailway ? 'production' : 'development');\r\n\r\n    if (isRailway) {\r\n      console.log('🚂 Starting in Railway mode...');\r\n      \r\n      // Проверяем наличие необходимых переменных\r\n      if (!process.env.DATABASE_URL) {\r\n        throw new Error('DATABASE_URL is required for Railway deployment');\r\n      }\r\n      \r\n      // Генерируем Prisma клиент\r\n      if (fs.existsSync('packages/database/prisma/schema.prisma')) {\r\n        console.log('🔧 Generating Prisma client...');\r\n        try {\r\n          await startProcess('npx', ['prisma', 'generate'], {\r\n            cwd: 'packages/database'\r\n          });\r\n          console.log('✅ Prisma client generated successfully');\r\n        } catch (error) {\r\n          console.error('❌ Failed to generate Prisma client:', error.message);\r\n          // Продолжаем выполнение, возможно клиент уже сгенерирован\r\n        }\r\n      }\r\n\r\n      // В Railway запускаем только Gateway (основной сервис)\r\n      console.log('📡 Starting Gateway service for Railway...');\r\n      \r\n      // Загружаем dotenv для Railway\r\n      try {\r\n        require('dotenv').config();\r\n      } catch (error) {\r\n        console.log('⚠️  dotenv not available, using environment variables');\r\n      }\r\n      \r\n      // Запускаем Gateway\r\n      require('./services/gateway/src/index.js');\r\n      \r\n    } else {\r\n      console.log('💻 Starting in local development mode...');\r\n      \r\n      // Проверяем наличие .env файла\r\n      if (!fs.existsSync('.env')) {\r\n        console.log('⚠️  .env file not found, using environment variables');\r\n      }\r\n      \r\n      // Локально запускаем все сервисы через start.js\r\n      require('./start.js');\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('❌ Failed to start application:', error.message);\r\n    console.error('Stack trace:', error.stack);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Обработка сигналов завершения\r\nprocess.on('SIGTERM', () => {\r\n  console.log('🛑 Received SIGTERM, shutting down gracefully...');\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('SIGINT', () => {\r\n  console.log('🛑 Received SIGINT, shutting down gracefully...');\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('uncaughtException', (error) => {\r\n  console.error('❌ Uncaught Exception:', error);\r\n  process.exit(1);\r\n});\r\n\r\nprocess.on('unhandledRejection', (reason, promise) => {\r\n  console.error('❌ Unhandled Rejection at:', promise, 'reason:', reason);\r\n  process.exit(1);\r\n});\r\n\r\n// Запускаем приложение\r\nstart();\r\n",
  "restart-services-with-redis-fix.js": "#!/usr/bin/env node\r\n\r\nconst { spawn, exec } = require('child_process');\r\nconst path = require('path');\r\n\r\nconsole.log('🔄 Перезапуск сервисов с исправленным Redis...');\r\n\r\n// Функция для выполнения команды\r\nfunction executeCommand(command, options = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    exec(command, options, (error, stdout, stderr) => {\r\n      if (error) {\r\n        console.error(`Ошибка: ${error.message}`);\r\n        reject(error);\r\n        return;\r\n      }\r\n      if (stderr) {\r\n        console.error(`Stderr: ${stderr}`);\r\n      }\r\n      console.log(stdout);\r\n      resolve(stdout);\r\n    });\r\n  });\r\n}\r\n\r\nasync function main() {\r\n  try {\r\n    console.log('1. Остановка всех Node.js процессов...');\r\n    \r\n    // Останавливаем все node процессы (осторожно!)\r\n    try {\r\n      await executeCommand('taskkill /F /IM node.exe', { timeout: 10000 });\r\n    } catch (error) {\r\n      console.log('Процессы Node.js уже остановлены или не найдены');\r\n    }\r\n\r\n    // Ждем немного\r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n    console.log('2. Запуск сервисов с исправленным Redis...');\r\n    \r\n    // Запускаем сервисы заново\r\n    const startProcess = spawn('node', ['start-all-services.js'], {\r\n      stdio: 'inherit',\r\n      cwd: process.cwd()\r\n    });\r\n\r\n    console.log('✅ Сервисы перезапущены с исправленным Redis!');\r\n    console.log('📊 Мониторинг логов...');\r\n\r\n    // Обработка завершения процесса\r\n    startProcess.on('close', (code) => {\r\n      console.log(`Процесс завершен с кодом ${code}`);\r\n    });\r\n\r\n    startProcess.on('error', (error) => {\r\n      console.error('Ошибка запуска:', error);\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Ошибка при перезапуске сервисов:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Обработка сигналов завершения\r\nprocess.on('SIGINT', () => {\r\n  console.log('\\n🛑 Получен сигнал завершения...');\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('SIGTERM', () => {\r\n  console.log('\\n🛑 Получен сигнал завершения...');\r\n  process.exit(0);\r\n});\r\n\r\nmain();\r\n",
  "scripts/check-env.js": "// Определяем какой сервис запускается\r\nconst SERVICE = process.env.RAILWAY_SERVICE_NAME || \r\n               process.env.SERVICE_NAME || \r\n               detectServiceFromPath() ||\r\n               'monolith'; // Изменено с 'gateway' на 'monolith'\r\n\r\nconsole.log(`🎯 Checking environment variables for service: ${SERVICE}`);\r\n\r\n// Базовые требования для всех сервисов\r\nconst baseRequired = [\r\n  'DATABASE_URL'\r\n];\r\n\r\n// Специфичные требования для каждого сервиса\r\nconst serviceRequirements = {\r\n  'monolith': ['DATABASE_URL'], // Добавлен монолитный сервис\r\n  'gateway': ['DATABASE_URL'],\r\n  'auth': ['DATABASE_URL', 'JWT_SECRET'],\r\n  'telegram-bot': ['DATABASE_URL', 'TELEGRAM_BOT_TOKEN'],\r\n  'notifications': ['DATABASE_URL', 'TELEGRAM_BOT_TOKEN'],\r\n  'data-import': ['DATABASE_URL'],\r\n  'backup': ['DATABASE_URL', 'S3_BUCKET', 'S3_ACCESS_KEY', 'S3_SECRET_KEY'],\r\n  // Для остальных сервисов достаточно базовых требований\r\n};\r\n\r\n// Определяем требования для текущего сервиса\r\nconst required = serviceRequirements[SERVICE] || baseRequired;\r\n\r\nconst optional = [\r\n  'REDIS_URL',\r\n  'S3_BUCKET',\r\n  'S3_ACCESS_KEY',\r\n  'S3_SECRET_KEY',\r\n  'SENTRY_DSN',\r\n  'JWT_SECRET',\r\n  'TELEGRAM_BOT_TOKEN'\r\n].filter(key => !required.includes(key)); // Исключаем те, что уже в required\r\n\r\nconsole.log('🔍 Checking environment variables...');\r\n\r\nconst missing = required.filter(key => !process.env[key]);\r\nconst missingOptional = optional.filter(key => !process.env[key]);\r\n\r\nif (missing.length > 0) {\r\n  console.error(`❌ Missing required environment variables for service ${SERVICE}:`);\r\n  missing.forEach(key => console.error(`  - ${key}`));\r\n  process.exit(1);\r\n}\r\n\r\nif (missingOptional.length > 0) {\r\n  console.warn('⚠️ Missing optional environment variables:');\r\n  missingOptional.forEach(key => console.warn(`  - ${key}`));\r\n}\r\n\r\n// Проверка JWT секрета только если он требуется или присутствует\r\nif ((required.includes('JWT_SECRET') || process.env.JWT_SECRET) && \r\n    process.env.JWT_SECRET && process.env.JWT_SECRET.length < 32) {\r\n  if (required.includes('JWT_SECRET')) {\r\n    console.error('❌ JWT_SECRET must be at least 32 characters long');\r\n    process.exit(1);\r\n  } else {\r\n    console.warn('⚠️ JWT_SECRET is less than 32 characters long. This is not secure for production.');\r\n  }\r\n}\r\n\r\n// Проверка S3 конфигурации только если она требуется или присутствует\r\nif ((required.includes('S3_BUCKET') || process.env.S3_BUCKET) && \r\n    process.env.S3_BUCKET && (!process.env.S3_ACCESS_KEY || !process.env.S3_SECRET_KEY)) {\r\n  if (required.includes('S3_BUCKET')) {\r\n    console.error('❌ S3_BUCKET requires S3_ACCESS_KEY and S3_SECRET_KEY');\r\n    process.exit(1);\r\n  } else {\r\n    console.warn('⚠️ S3_BUCKET requires S3_ACCESS_KEY and S3_SECRET_KEY. File storage may not work correctly.');\r\n  }\r\n}\r\n\r\nconsole.log(`✅ All required environment variables for service ${SERVICE} are set`);\r\nconsole.log(`📊 ${required.length - missing.length}/${required.length} required variables configured`);\r\nconsole.log(`📊 ${optional.length - missingOptional.length}/${optional.length} optional variables configured`);\r\n\r\n// Функция для определения сервиса из пути\r\nfunction detectServiceFromPath() {\r\n  try {\r\n    const path = require('path');\r\n    const cwd = process.cwd();\r\n    const services = [\r\n      'gateway', 'auth', 'machines', 'inventory', 'tasks', 'telegram-bot', \r\n      'notifications', 'audit', 'data-import', 'backup', 'monitoring', \r\n      'routes', 'warehouse', 'recipes', 'bunkers'\r\n    ];\r\n    \r\n    const servicePath = cwd.split(path.sep).find(part => services.includes(part));\r\n    return servicePath;\r\n  } catch (error) {\r\n    return null;\r\n  }\r\n}\r\n",
  "scripts/start-production.js": "// Production starter for Railway deployment\nconst { spawn } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\n\nconsole.log('🚀 Starting VHM24 in production mode on Railway...');\n\n// Проверка переменных окружения\ntry {\n  require('./check-env');\n} catch (error) {\n  console.error('❌ Environment check failed:', error.message);\n  process.exit(1);\n}\n\n// Определяем какой сервис запускать на основе Railway переменных\nconst SERVICE = process.env.RAILWAY_SERVICE_NAME || \n               process.env.SERVICE_NAME || \n               detectServiceFromPath() ||\n               'gateway';\n\nconsole.log(`🎯 Detected service: ${SERVICE}`);\n\nconst serviceMap = {\n  'gateway': { path: 'services/gateway', port: 8000, public: true },\n  'auth': { path: 'services/auth', port: 3001, public: false },\n  'machines': { path: 'services/machines', port: 3002, public: false },\n  'inventory': { path: 'services/inventory', port: 3003, public: false },\n  'tasks': { path: 'services/tasks', port: 3004, public: false },\n  'telegram-bot': { path: 'services/telegram-bot', port: 3005, public: false },\n  'notifications': { path: 'services/notifications', port: 3006, public: false },\n  'audit': { path: 'services/audit', port: 3007, public: false },\n  'data-import': { path: 'services/data-import', port: 3008, public: false },\n  'backup': { path: 'services/backup', port: 3009, public: false },\n  'monitoring': { path: 'services/monitoring', port: 3010, public: false },\n  'routes': { path: 'services/routes', port: 3011, public: false },\n  'warehouse': { path: 'services/warehouse', port: 3012, public: false },\n  'recipes': { path: 'services/recipes', port: 3013, public: false },\n  'bunkers': { path: 'services/bunkers', port: 3014, public: false }\n};\n\nconst service = serviceMap[SERVICE];\n\nif (!service) {\n  console.error(`❌ Unknown service: ${SERVICE}`);\n  console.log('Available services:', Object.keys(serviceMap).join(', '));\n  process.exit(1);\n}\n\n// Проверяем существование сервиса\nif (!fs.existsSync(service.path)) {\n  console.error(`❌ Service path not found: ${service.path}`);\n  process.exit(1);\n}\n\n// Устанавливаем PORT для Railway\nprocess.env.PORT = process.env.PORT || service.port.toString();\n\nconsole.log(`🚀 Starting ${SERVICE} service...`);\nconsole.log(`📁 Path: ${service.path}`);\nconsole.log(`🌐 Port: ${process.env.PORT}`);\nconsole.log(`🔓 Public: ${service.public ? 'Yes' : 'No'}`);\n\n// Устанавливаем дополнительные переменные для сервиса\nprocess.env.SERVICE_NAME = SERVICE;\nprocess.env.SERVICE_PATH = service.path;\n\n// Запускаем сервис\nconst child = spawn('npm', ['start'], {\n  cwd: service.path,\n  stdio: 'inherit',\n  env: process.env\n});\n\nchild.on('error', (error) => {\n  console.error('❌ Failed to start service:', error);\n  process.exit(1);\n});\n\nchild.on('exit', (code) => {\n  console.log(`🛑 Service ${SERVICE} exited with code ${code}`);\n  process.exit(code);\n});\n\n// Graceful shutdown\nprocess.on('SIGTERM', () => {\n  console.log('🛑 Received SIGTERM, shutting down gracefully...');\n  child.kill('SIGTERM');\n});\n\nprocess.on('SIGINT', () => {\n  console.log('🛑 Received SIGINT, shutting down gracefully...');\n  child.kill('SIGINT');\n});\n\nfunction detectServiceFromPath() {\n  // Пытаемся определить сервис из текущего пути или переменных Railway\n  const cwd = process.cwd();\n  const servicePath = cwd.split(path.sep).find(part => \n    Object.keys(serviceMap).includes(part)\n  );\n  \n  return servicePath || null;\n}",
  "scripts/test-after-fixes.js": "const { execSync } = require('child_process');\r\nconst fs = require('fs');\r\nconst fetch = require('node-fetch');\r\n\r\nasync function runTests() {\r\n  console.log('🧪 Running comprehensive tests after fixes...\\n');\r\n  \r\n  const testResults = {\r\n    unit: false,\r\n    integration: false,\r\n    security: false,\r\n    performance: false,\r\n    docker: false\r\n  };\r\n  \r\n  // 1. Unit tests\r\n  try {\r\n    console.log('Running unit tests...');\r\n    execSync('npm test', { stdio: 'inherit' });\r\n    testResults.unit = true;\r\n  } catch (e) {\r\n    console.error('Unit tests failed');\r\n  }\r\n  \r\n  // 2. Integration tests\r\n  try {\r\n    console.log('\\nRunning integration tests...');\r\n    // Запускаем сервисы\r\n    execSync('docker-compose up -d', { stdio: 'inherit' });\r\n    \r\n    // Ждем готовности\r\n    await new Promise(resolve => setTimeout(resolve, 10000));\r\n    \r\n    // Тестируем endpoints\r\n    const endpoints = [\r\n      'http://localhost:8000/health',\r\n      'http://localhost:3001/health',\r\n      'http://localhost:3002/health',\r\n      'http://localhost:3003/health',\r\n      'http://localhost:3004/health'\r\n    ];\r\n    \r\n    for (const endpoint of endpoints) {\r\n      const response = await fetch(endpoint);\r\n      if (!response.ok) throw new Error(`${endpoint} failed`);\r\n    }\r\n    \r\n    testResults.integration = true;\r\n  } catch (e) {\r\n    console.error('Integration tests failed:', e.message);\r\n  }\r\n  \r\n  // 3. Security tests\r\n  try {\r\n    console.log('\\nRunning security tests...');\r\n    execSync('npm audit', { stdio: 'inherit' });\r\n    testResults.security = true;\r\n  } catch (e) {\r\n    console.error('Security tests failed');\r\n  }\r\n  \r\n  // 4. Performance tests\r\n  try {\r\n    console.log('\\nRunning performance tests...');\r\n    // Простой load test\r\n    execSync('npx autocannon -c 10 -d 5 http://localhost:8000/health', { stdio: 'inherit' });\r\n    testResults.performance = true;\r\n  } catch (e) {\r\n    console.error('Performance tests failed');\r\n  }\r\n  \r\n  // 5. Docker build test\r\n  try {\r\n    console.log('\\nTesting Docker builds...');\r\n    execSync('docker build -t vhm24-test -f services/gateway/Dockerfile .', { stdio: 'inherit' });\r\n    testResults.docker = true;\r\n  } catch (e) {\r\n    console.error('Docker build failed');\r\n  }\r\n  \r\n  // Генерация отчета\r\n  console.log('\\n📊 Test Results:');\r\n  Object.entries(testResults).forEach(([test, passed]) => {\r\n    console.log(`${passed ? '✅' : '❌'} ${test}`);\r\n  });\r\n  \r\n  const allPassed = Object.values(testResults).every(v => v);\r\n  \r\n  if (allPassed) {\r\n    console.log('\\n🎉 All tests passed! Project is ready for deployment.');\r\n  } else {\r\n    console.log('\\n⚠️ Some tests failed. Please review and fix remaining issues.');\r\n  }\r\n  \r\n  // Cleanup\r\n  execSync('docker-compose down', { stdio: 'inherit' });\r\n}\r\n\r\nrunTests().catch(console.error);\r\n",
  "services/gateway/src/config.js": "// Конфигурация для Railway\r\nmodule.exports = {\r\n  services: {\r\n    auth: {\r\n      url: process.env.AUTH_SERVICE_URL || 'http://127.0.0.1:3001',\r\n      prefix: '/api/v1/auth'\r\n    },\r\n    machines: {\r\n      url: process.env.MACHINES_SERVICE_URL || 'http://127.0.0.1:3002',\r\n      prefix: '/api/v1/machines'\r\n    },\r\n    inventory: {\r\n      url: process.env.INVENTORY_SERVICE_URL || 'http://127.0.0.1:3003',\r\n      prefix: '/api/v1/inventory'\r\n    },\r\n    tasks: {\r\n      url: process.env.TASKS_SERVICE_URL || 'http://127.0.0.1:3004',\r\n      prefix: '/api/v1/tasks'\r\n    },\r\n    routes: {\r\n      url: process.env.ROUTES_SERVICE_URL || 'http://127.0.0.1:3005',\r\n      prefix: '/api/v1/routes'\r\n    },\r\n    warehouse: {\r\n      url: process.env.WAREHOUSE_SERVICE_URL || 'http://127.0.0.1:3006',\r\n      prefix: '/api/v1/warehouse'\r\n    },\r\n    recipes: {\r\n      url: process.env.RECIPES_SERVICE_URL || 'http://127.0.0.1:3007',\r\n      prefix: '/api/v1/recipes'\r\n    },\r\n    bunkers: {\r\n      url: process.env.BUNKERS_SERVICE_URL || 'http://127.0.0.1:3008',\r\n      prefix: '/api/v1/bunkers'\r\n    },\r\n    notifications: {\r\n      url: process.env.NOTIFICATIONS_SERVICE_URL || 'http://127.0.0.1:3008',\r\n      prefix: '/api/v1/notifications'\r\n    },\r\n    monitoring: {\r\n      url: process.env.MONITORING_SERVICE_URL || 'http://127.0.0.1:3009',\r\n      prefix: '/api/v1/monitoring'\r\n    },\r\n    backup: {\r\n      url: 'http://127.0.0.1:3007',\r\n      prefix: '/api/v1/backup',\r\n      timeout: 30000\r\n    },\r\n    audit: {\r\n      url: 'http://127.0.0.1:3009',\r\n      prefix: '/api/v1/audit',\r\n      timeout: 10000\r\n    }\r\n  }\r\n};\r\n",
  "services/telegram-bot/src/fsm/manager.js": "/**\r\n * VHM24 Telegram Bot FSM Manager\r\n * Управление состояниями пользователей с поддержкой Redis\r\n */\r\n\r\nconst { COMMON_STATES, ALL_STATES } = require('./states');\r\n\r\nclass FSMManager {\r\n  constructor() {\r\n    // В production используем Redis, в development - Map\r\n    this.useRedis = process.env.NODE_ENV === 'production' && process.env.REDIS_URL;\r\n    \r\n    if (this.useRedis) {\r\n      // Redis клиент будет инициализирован позже\r\n      this.redis = null;\r\n    } else {\r\n      // Локальное хранилище для development\r\n      this.userStates = new Map();\r\n      this.userData = new Map();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Инициализация Redis клиента\r\n   */\r\n  async initRedis() {\r\n    if (this.useRedis && !this.redis) {\r\n      try {\r\n        const Redis = require('ioredis');\r\n        this.redis = new Redis(process.env.REDIS_URL);\r\n        console.log('FSM Manager: Redis connected');\r\n      } catch (error) {\r\n        console.error('FSM Manager: Redis connection failed, falling back to memory:', error);\r\n        this.useRedis = false;\r\n        this.userStates = new Map();\r\n        this.userData = new Map();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получить текущее состояние пользователя\r\n   */\r\n  async getUserState(userId) {\r\n    try {\r\n      if (this.useRedis && this.redis) {\r\n        const state = await this.redis.get(`fsm:state:${userId}`);\r\n        return state || COMMON_STATES.IDLE;\r\n      } else {\r\n        return this.userStates.get(userId) || COMMON_STATES.IDLE;\r\n      }\r\n    } catch (error) {\r\n      console.error('FSM Manager: Error getting user state:', error);\r\n      return COMMON_STATES.IDLE;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Установить состояние пользователя\r\n   */\r\n  async setUserState(userId, state) {\r\n    try {\r\n      // Проверяем, что состояние валидно\r\n      if (!Object.values(ALL_STATES).includes(state)) {\r\n        throw new Error(`Invalid state: ${state}`);\r\n      }\r\n\r\n      if (this.useRedis && this.redis) {\r\n        await this.redis.setex(`fsm:state:${userId}`, 3600, state); // TTL 1 час\r\n        console.log(`FSM: User ${userId} state set to ${state}`);\r\n      } else {\r\n        this.userStates.set(userId, state);\r\n        console.log(`FSM: User ${userId} state set to ${state}`);\r\n      }\r\n    } catch (error) {\r\n      console.error('FSM Manager: Error setting user state:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Очистить состояние пользователя (вернуть в IDLE)\r\n   */\r\n  async clearUserState(userId) {\r\n    try {\r\n      if (this.useRedis && this.redis) {\r\n        await this.redis.del(`fsm:state:${userId}`);\r\n        await this.redis.del(`fsm:data:${userId}`);\r\n      } else {\r\n        this.userStates.delete(userId);\r\n        this.userData.delete(userId);\r\n      }\r\n      console.log(`FSM: User ${userId} state cleared`);\r\n    } catch (error) {\r\n      console.error('FSM Manager: Error clearing user state:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получить временные данные пользователя\r\n   */\r\n  async getUserData(userId) {\r\n    try {\r\n      if (this.useRedis && this.redis) {\r\n        const data = await this.redis.get(`fsm:data:${userId}`);\r\n        return data ? JSON.parse(data) : {};\r\n      } else {\r\n        return this.userData.get(userId) || {};\r\n      }\r\n    } catch (error) {\r\n      console.error('FSM Manager: Error getting user data:', error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Установить временные данные пользователя\r\n   */\r\n  async setUserData(userId, data) {\r\n    try {\r\n      if (this.useRedis && this.redis) {\r\n        await this.redis.setex(`fsm:data:${userId}`, 3600, JSON.stringify(data)); // TTL 1 час\r\n      } else {\r\n        this.userData.set(userId, data);\r\n      }\r\n    } catch (error) {\r\n      console.error('FSM Manager: Error setting user data:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Обновить временные данные пользователя\r\n   */\r\n  async updateUserData(userId, updates) {\r\n    try {\r\n      const currentData = await this.getUserData(userId);\r\n      const newData = { ...currentData, ...updates };\r\n      await this.setUserData(userId, newData);\r\n    } catch (error) {\r\n      console.error('FSM Manager: Error updating user data:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверить, находится ли пользователь в определенном состоянии\r\n   */\r\n  async isUserInState(userId, state) {\r\n    try {\r\n      const currentState = await this.getUserState(userId);\r\n      return currentState === state;\r\n    } catch (error) {\r\n      console.error('FSM Manager: Error checking user state:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Проверить, находится ли пользователь в группе состояний\r\n   */\r\n  async isUserInStateGroup(userId, stateGroup) {\r\n    try {\r\n      const currentState = await this.getUserState(userId);\r\n      return stateGroup.includes(currentState);\r\n    } catch (error) {\r\n      console.error('FSM Manager: Error checking user state group:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получить всех пользователей в определенном состоянии\r\n   */\r\n  async getUsersInState(state) {\r\n    try {\r\n      const users = [];\r\n      \r\n      if (this.useRedis && this.redis) {\r\n        const keys = await this.redis.keys('fsm:state:*');\r\n        for (const key of keys) {\r\n          const userState = await this.redis.get(key);\r\n          if (userState === state) {\r\n            const userId = key.replace('fsm:state:', '');\r\n            users.push(userId);\r\n          }\r\n        }\r\n      } else {\r\n        for (const [userId, userState] of this.userStates.entries()) {\r\n          if (userState === state) {\r\n            users.push(userId);\r\n          }\r\n        }\r\n      }\r\n      \r\n      return users;\r\n    } catch (error) {\r\n      console.error('FSM Manager: Error getting users in state:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Установить таймаут для состояния пользователя\r\n   */\r\n  async setStateTimeout(userId, timeoutMs, fallbackState = COMMON_STATES.IDLE) {\r\n    try {\r\n      setTimeout(async () => {\r\n        const currentState = await this.getUserState(userId);\r\n        if (currentState !== COMMON_STATES.IDLE) {\r\n          console.log(`FSM: State timeout for user ${userId}, resetting to ${fallbackState}`);\r\n          await this.setUserState(userId, fallbackState);\r\n          await this.clearUserData(userId);\r\n        }\r\n      }, timeoutMs);\r\n    } catch (error) {\r\n      console.error('FSM Manager: Error setting state timeout:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Очистить данные пользователя\r\n   */\r\n  async clearUserData(userId) {\r\n    try {\r\n      if (this.useRedis && this.redis) {\r\n        await this.redis.del(`fsm:data:${userId}`);\r\n      } else {\r\n        this.userData.delete(userId);\r\n      }\r\n    } catch (error) {\r\n      console.error('FSM Manager: Error clearing user data:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Получить статистику состояний\r\n   */\r\n  async getStateStatistics() {\r\n    try {\r\n      const stats = {};\r\n      \r\n      if (this.useRedis && this.redis) {\r\n        const keys = await this.redis.keys('fsm:state:*');\r\n        for (const key of keys) {\r\n          const state = await this.redis.get(key);\r\n          stats[state] = (stats[state] || 0) + 1;\r\n        }\r\n      } else {\r\n        for (const state of this.userStates.values()) {\r\n          stats[state] = (stats[state] || 0) + 1;\r\n        }\r\n      }\r\n      \r\n      return stats;\r\n    } catch (error) {\r\n      console.error('FSM Manager: Error getting state statistics:', error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Очистить все состояния (для отладки)\r\n   */\r\n  async clearAllStates() {\r\n    try {\r\n      if (this.useRedis && this.redis) {\r\n        const stateKeys = await this.redis.keys('fsm:state:*');\r\n        const dataKeys = await this.redis.keys('fsm:data:*');\r\n        const allKeys = [...stateKeys, ...dataKeys];\r\n        \r\n        if (allKeys.length > 0) {\r\n          await this.redis.del(...allKeys);\r\n        }\r\n      } else {\r\n        this.userStates.clear();\r\n        this.userData.clear();\r\n      }\r\n      console.log('FSM: All states cleared');\r\n    } catch (error) {\r\n      console.error('FSM Manager: Error clearing all states:', error);\r\n    }\r\n  }\r\n}\r\n\r\n// Создаем единственный экземпляр\r\nconst fsmManager = new FSMManager();\r\n\r\nmodule.exports = fsmManager;\r\n",
  "services/telegram-bot/src/handlers/uploadHandler.js": "const TelegramBot = require('node-telegram-bot-api');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst os = require('os');\r\nconst s3Storage = require('../utils/s3Storage');\r\n\r\n/**\r\n * Upload Handler - обработчик загрузки файлов\r\n * Поддерживает загрузку фото, документов и других файлов в DigitalOcean Spaces\r\n */\r\n\r\nclass UploadHandler {\r\n  constructor(bot) {\r\n    this.bot = bot;\r\n    this.tempDir = path.join(os.tmpdir(), 'vhm24-uploads');\r\n    \r\n    // Создаем временную директорию если её нет\r\n    if (!fs.existsSync(this.tempDir)) {\r\n      fs.mkdirSync(this.tempDir, { recursive: true });\r\n    }\r\n\r\n    this.setupHandlers();\r\n  }\r\n\r\n  setupHandlers() {\r\n    // Команда для загрузки фото\r\n    this.bot.onText(/\\/upload_photo/, (msg) => {\r\n      this.handleUploadPhotoCommand(msg);\r\n    });\r\n\r\n    // Команда для загрузки документа\r\n    this.bot.onText(/\\/upload_document/, (msg) => {\r\n      this.handleUploadDocumentCommand(msg);\r\n    });\r\n\r\n    // Обработка фото\r\n    this.bot.on('photo', (msg) => {\r\n      this.handlePhoto(msg);\r\n    });\r\n\r\n    // Обработка документов\r\n    this.bot.on('document', (msg) => {\r\n      this.handleDocument(msg);\r\n    });\r\n\r\n    // Команда для просмотра загруженных файлов\r\n    this.bot.onText(/\\/my_uploads/, (msg) => {\r\n      this.handleMyUploads(msg);\r\n    });\r\n\r\n    // Команда помощи по загрузке\r\n    this.bot.onText(/\\/upload_help/, (msg) => {\r\n      this.handleUploadHelp(msg);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Обработка команды /upload_photo\r\n   */\r\n  async handleUploadPhotoCommand(msg) {\r\n    const chatId = msg.chat.id;\r\n    \r\n    const helpText = `📸 *Загрузка фото в облако*\r\n\r\nПросто пришлите мне фото, и я загружу его в DigitalOcean Spaces!\r\n\r\n*Поддерживаемые форматы:*\r\n• JPG/JPEG\r\n• PNG\r\n• GIF\r\n• WebP\r\n\r\n*Что происходит:*\r\n1. Вы отправляете фото\r\n2. Я загружаю его в облако\r\n3. Вы получаете публичную ссылку\r\n\r\nПопробуйте прямо сейчас - отправьте любое фото! 📷`;\r\n\r\n    await this.bot.sendMessage(chatId, helpText, { parse_mode: 'Markdown' });\r\n  }\r\n\r\n  /**\r\n   * Обработка команды /upload_document\r\n   */\r\n  async handleUploadDocumentCommand(msg) {\r\n    const chatId = msg.chat.id;\r\n    \r\n    const helpText = `📄 *Загрузка документов в облако*\r\n\r\nОтправьте мне документ, и я загружу его в DigitalOcean Spaces!\r\n\r\n*Поддерживаемые форматы:*\r\n• PDF\r\n• DOC/DOCX\r\n• XLS/XLSX\r\n• TXT\r\n• CSV\r\n• И многие другие\r\n\r\n*Максимальный размер:* 20 МБ\r\n\r\nПопробуйте прямо сейчас - отправьте любой документ! 📎`;\r\n\r\n    await this.bot.sendMessage(chatId, helpText, { parse_mode: 'Markdown' });\r\n  }\r\n\r\n  /**\r\n   * Обработка фото\r\n   */\r\n  async handlePhoto(msg) {\r\n    const chatId = msg.chat.id;\r\n    const messageId = msg.message_id;\r\n\r\n    try {\r\n      // Отправляем сообщение о начале загрузки\r\n      const statusMsg = await this.bot.sendMessage(chatId, '📸 Загружаю фото в облако...', {\r\n        reply_to_message_id: messageId\r\n      });\r\n\r\n      // Получаем фото наилучшего качества\r\n      const photo = msg.photo[msg.photo.length - 1];\r\n      const fileId = photo.file_id;\r\n\r\n      // Получаем информацию о файле\r\n      const file = await this.bot.getFile(fileId);\r\n      const fileName = `photo_${Date.now()}.jpg`;\r\n      const tempFilePath = path.join(this.tempDir, fileName);\r\n\r\n      // Скачиваем файл\r\n      await this.bot.downloadFile(fileId, tempFilePath);\r\n\r\n      // Загружаем в DigitalOcean Spaces\r\n      const uploadedUrl = await s3Storage.uploadPhoto(tempFilePath, fileName);\r\n\r\n      // Получаем информацию о файле\r\n      const stats = fs.statSync(tempFilePath);\r\n      const fileSizeKB = Math.round(stats.size / 1024);\r\n\r\n      // Удаляем временный файл\r\n      fs.unlinkSync(tempFilePath);\r\n\r\n      // Обновляем сообщение с результатом\r\n      const successText = `✅ *Фото успешно загружено!*\r\n\r\n📎 *Ссылка:* [Открыть фото](${uploadedUrl})\r\n📏 *Размер:* ${fileSizeKB} КБ\r\n🌐 *CDN:* DigitalOcean Spaces\r\n📅 *Дата:* ${new Date().toLocaleString('ru-RU')}\r\n\r\n_Ссылка публичная и будет работать всегда_`;\r\n\r\n      await this.bot.editMessageText(successText, {\r\n        chat_id: chatId,\r\n        message_id: statusMsg.message_id,\r\n        parse_mode: 'Markdown',\r\n        disable_web_page_preview: false\r\n      });\r\n\r\n      // Логируем успешную загрузку\r\n      console.log(`✅ Photo uploaded by user ${msg.from.id}: ${uploadedUrl}`);\r\n\r\n    } catch (error) {\r\n      console.error('❌ Error uploading photo:', error);\r\n      \r\n      await this.bot.sendMessage(chatId, `❌ Ошибка при загрузке фото: ${error.message}`, {\r\n        reply_to_message_id: messageId\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Обработка документов\r\n   */\r\n  async handleDocument(msg) {\r\n    const chatId = msg.chat.id;\r\n    const messageId = msg.message_id;\r\n\r\n    try {\r\n      const document = msg.document;\r\n      const fileId = document.file_id;\r\n      const fileName = document.file_name || `document_${Date.now()}`;\r\n      const fileSize = document.file_size;\r\n\r\n      // Проверяем размер файла (максимум 20 МБ)\r\n      if (fileSize > 20 * 1024 * 1024) {\r\n        await this.bot.sendMessage(chatId, '❌ Файл слишком большой! Максимальный размер: 20 МБ', {\r\n          reply_to_message_id: messageId\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Отправляем сообщение о начале загрузки\r\n      const statusMsg = await this.bot.sendMessage(chatId, `📄 Загружаю документ \"${fileName}\" в облако...`, {\r\n        reply_to_message_id: messageId\r\n      });\r\n\r\n      // Скачиваем файл\r\n      const tempFilePath = path.join(this.tempDir, fileName);\r\n      await this.bot.downloadFile(fileId, tempFilePath);\r\n\r\n      // Загружаем в DigitalOcean Spaces\r\n      const uploadedUrl = await s3Storage.uploadDocument(tempFilePath, fileName);\r\n\r\n      // Получаем информацию о файле\r\n      const fileSizeKB = Math.round(fileSize / 1024);\r\n      const fileSizeMB = (fileSize / (1024 * 1024)).toFixed(2);\r\n\r\n      // Удаляем временный файл\r\n      fs.unlinkSync(tempFilePath);\r\n\r\n      // Обновляем сообщение с результатом\r\n      const successText = `✅ *Документ успешно загружен!*\r\n\r\n📎 *Ссылка:* [${fileName}](${uploadedUrl})\r\n📏 *Размер:* ${fileSizeMB} МБ (${fileSizeKB} КБ)\r\n📄 *Тип:* ${document.mime_type || 'неизвестно'}\r\n🌐 *CDN:* DigitalOcean Spaces\r\n📅 *Дата:* ${new Date().toLocaleString('ru-RU')}\r\n\r\n_Ссылка публичная и будет работать всегда_`;\r\n\r\n      await this.bot.editMessageText(successText, {\r\n        chat_id: chatId,\r\n        message_id: statusMsg.message_id,\r\n        parse_mode: 'Markdown',\r\n        disable_web_page_preview: false\r\n      });\r\n\r\n      // Логируем успешную загрузку\r\n      console.log(`✅ Document uploaded by user ${msg.from.id}: ${uploadedUrl}`);\r\n\r\n    } catch (error) {\r\n      console.error('❌ Error uploading document:', error);\r\n      \r\n      await this.bot.sendMessage(chatId, `❌ Ошибка при загрузке документа: ${error.message}`, {\r\n        reply_to_message_id: messageId\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Обработка команды /my_uploads\r\n   */\r\n  async handleMyUploads(msg) {\r\n    const chatId = msg.chat.id;\r\n    \r\n    const infoText = `📁 *Мои загрузки*\r\n\r\nК сожалению, пока нет базы данных для отслеживания ваших загрузок.\r\n\r\n*Что можно сделать:*\r\n• Сохраняйте ссылки на важные файлы\r\n• Используйте закладки в браузере\r\n• Создайте заметку с ссылками\r\n\r\n*Планируется добавить:*\r\n• История загрузок\r\n• Управление файлами\r\n• Создание альбомов\r\n• Поиск по файлам\r\n\r\nПока что просто загружайте файлы - все ссылки публичные и постоянные! 🚀`;\r\n\r\n    await this.bot.sendMessage(chatId, infoText, { parse_mode: 'Markdown' });\r\n  }\r\n\r\n  /**\r\n   * Обработка команды /upload_help\r\n   */\r\n  async handleUploadHelp(msg) {\r\n    const chatId = msg.chat.id;\r\n    \r\n    const helpText = `🆘 *Помощь по загрузке файлов*\r\n\r\n*📸 Фото:*\r\n• Просто отправьте фото\r\n• Поддерживаются: JPG, PNG, GIF, WebP\r\n• Автоматическая загрузка в облако\r\n\r\n*📄 Документы:*\r\n• Отправьте файл как документ\r\n• Максимальный размер: 20 МБ\r\n• Поддерживаются все форматы\r\n\r\n*🌐 Облачное хранилище:*\r\n• DigitalOcean Spaces\r\n• CDN для быстрой загрузки\r\n• Публичные ссылки\r\n• Постоянное хранение\r\n\r\n*📋 Команды:*\r\n/upload_photo - помощь по фото\r\n/upload_document - помощь по документам\r\n/my_uploads - мои загрузки\r\n/upload_help - эта справка\r\n\r\n*🔧 Технические детали:*\r\n• Уникальные имена файлов (UUID)\r\n• Автоматическое определение MIME-типов\r\n• Кэширование на 1 год\r\n• Логирование всех операций\r\n\r\nПросто отправьте файл и получите ссылку! 🚀`;\r\n\r\n    await this.bot.sendMessage(chatId, helpText, { parse_mode: 'Markdown' });\r\n  }\r\n\r\n  /**\r\n   * Очистка временных файлов\r\n   */\r\n  cleanupTempFiles() {\r\n    try {\r\n      const files = fs.readdirSync(this.tempDir);\r\n      const now = Date.now();\r\n      \r\n      files.forEach(file => {\r\n        const filePath = path.join(this.tempDir, file);\r\n        const stats = fs.statSync(filePath);\r\n        \r\n        // Удаляем файлы старше 1 часа\r\n        if (now - stats.mtime.getTime() > 60 * 60 * 1000) {\r\n          fs.unlinkSync(filePath);\r\n          console.log(`🗑️ Cleaned up temp file: ${file}`);\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.error('❌ Error cleaning up temp files:', error);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = UploadHandler;\r\n",
  "services/telegram-bot/src/utils/qrGenerator.js": "// QR Code generation utilities\r\nimport QRCode from 'qrcode';\r\n\r\nexport async function generateMachineQR(machine) {\r\n  const qrData = {\r\n    type: 'vhm24_machine',\r\n    id: machine.id,\r\n    name: machine.name,\r\n    location: machine.location,\r\n    timestamp: new Date().toISOString()\r\n  };\r\n  \r\n  const qrString = JSON.stringify(qrData);\r\n  \r\n  // Generate QR code as buffer\r\n  const qrBuffer = await QRCode.toBuffer(qrString, {\r\n    errorCorrectionLevel: 'M',\r\n    type: 'png',\r\n    quality: 0.92,\r\n    margin: 1,\r\n    color: {\r\n      dark: '#000000',\r\n      light: '#FFFFFF'\r\n    },\r\n    width: 512\r\n  });\r\n  \r\n  return qrBuffer;\r\n}\r\n\r\nexport async function generateTaskQR(task) {\r\n  const qrData = {\r\n    type: 'vhm24_task',\r\n    id: task.id,\r\n    title: task.title,\r\n    machineId: task.machineId,\r\n    timestamp: new Date().toISOString()\r\n  };\r\n  \r\n  const qrString = JSON.stringify(qrData);\r\n  \r\n  const qrBuffer = await QRCode.toBuffer(qrString, {\r\n    errorCorrectionLevel: 'M',\r\n    type: 'png',\r\n    quality: 0.92,\r\n    margin: 1,\r\n    width: 512\r\n  });\r\n  \r\n  return qrBuffer;\r\n}\r\n\r\nexport async function generateInventoryQR(item) {\r\n  const qrData = {\r\n    type: 'vhm24_inventory',\r\n    id: item.id,\r\n    sku: item.sku,\r\n    name: item.name,\r\n    quantity: item.quantity,\r\n    timestamp: new Date().toISOString()\r\n  };\r\n  \r\n  const qrString = JSON.stringify(qrData);\r\n  \r\n  const qrBuffer = await QRCode.toBuffer(qrString, {\r\n    errorCorrectionLevel: 'M',\r\n    type: 'png',\r\n    quality: 0.92,\r\n    margin: 1,\r\n    width: 512\r\n  });\r\n  \r\n  return qrBuffer;\r\n}\r\n\r\nexport async function generateAuthQR(authToken, userId) {\r\n  const qrData = {\r\n    type: 'vhm24_auth',\r\n    token: authToken,\r\n    userId: userId,\r\n    timestamp: new Date().toISOString(),\r\n    expiresAt: new Date(Date.now() + 5 * 60 * 1000).toISOString() // 5 minutes\r\n  };\r\n  \r\n  const qrString = JSON.stringify(qrData);\r\n  \r\n  const qrBuffer = await QRCode.toBuffer(qrString, {\r\n    errorCorrectionLevel: 'H', // High error correction for auth\r\n    type: 'png',\r\n    quality: 0.92,\r\n    margin: 1,\r\n    width: 512\r\n  });\r\n  \r\n  return qrBuffer;\r\n}\r\n\r\nexport function parseQRData(qrString) {\r\n  try {\r\n    const data = JSON.parse(qrString);\r\n    \r\n    // Validate QR data structure\r\n    if (!data.type || !data.type.startsWith('vhm24_')) {\r\n      throw new Error('Invalid QR code format');\r\n    }\r\n    \r\n    if (!data.id && data.type !== 'vhm24_auth') {\r\n      throw new Error('Missing ID in QR data');\r\n    }\r\n    \r\n    if (!data.timestamp) {\r\n      throw new Error('Missing timestamp in QR data');\r\n    }\r\n    \r\n    // Check if QR code is expired (for auth QR codes)\r\n    if (data.type === 'vhm24_auth' && data.expiresAt) {\r\n      if (new Date(data.expiresAt) < new Date()) {\r\n        throw new Error('QR code has expired');\r\n      }\r\n    }\r\n    \r\n    return {\r\n      valid: true,\r\n      data: data\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      valid: false,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\nexport async function generateCustomQR(data, options = {}) {\r\n  const defaultOptions = {\r\n    errorCorrectionLevel: 'M',\r\n    type: 'png',\r\n    quality: 0.92,\r\n    margin: 1,\r\n    color: {\r\n      dark: '#000000',\r\n      light: '#FFFFFF'\r\n    },\r\n    width: 512\r\n  };\r\n  \r\n  const qrOptions = { ...defaultOptions, ...options };\r\n  const qrString = typeof data === 'string' ? data : JSON.stringify(data);\r\n  \r\n  return await QRCode.toBuffer(qrString, qrOptions);\r\n}\r\n\r\nexport async function generateQRWithLogo(data, logoPath, options = {}) {\r\n  // This would require additional image processing libraries\r\n  // For now, return standard QR code\r\n  return await generateCustomQR(data, options);\r\n}\r\n",
  "services/telegram-bot/src/utils/qrScanner.js": "/**\r\n * VHM24 - QR Code Scanner Utility\r\n * Модуль для распознавания QR-кодов из изображений\r\n * \r\n * Примечание: Это упрощенная версия для тестирования, которая эмулирует распознавание QR-кодов\r\n * В реальной среде следует использовать canvas, jsqr и sharp для полноценного распознавания\r\n */\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst logger = {\r\n  info: (message, ...args) => console.log(`[INFO] ${message}`, ...args),\r\n  warn: (message, ...args) => console.warn(`[WARN] ${message}`, ...args),\r\n  error: (message, ...args) => console.error(`[ERROR] ${message}`, ...args)\r\n};\r\n\r\n/**\r\n * Распознавание QR-кода из файла изображения\r\n * @param {string} filePath - Путь к файлу изображения\r\n * @returns {Promise<Object|null>} - Распознанные данные или null\r\n */\r\nasync function scanQRCodeFromFile(filePath) {\r\n  try {\r\n    logger.info(`Scanning QR code from file: ${filePath}`);\r\n    \r\n    // Проверяем существование файла\r\n    if (!fs.existsSync(filePath)) {\r\n      logger.error(`File not found: ${filePath}`);\r\n      return null;\r\n    }\r\n    \r\n    // В реальной реализации здесь должно быть распознавание QR-кода\r\n    // Для тестирования эмулируем распознавание, извлекая данные из имени файла\r\n    \r\n    // Если файл содержит \"test-item-qr\" в имени, предполагаем, что это тестовый QR-код товара\r\n    if (filePath.includes('test-item-qr')) {\r\n      logger.info('Detected test item QR code');\r\n      \r\n      // Эмулируем данные QR-кода\r\n      return {\r\n        type: 'vhm24_inventory',\r\n        id: '12345',\r\n        name: 'Тестовый товар',\r\n        sku: 'TEST-001',\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    }\r\n    \r\n    // Если файл содержит \"machine-qr\" в имени, предполагаем, что это QR-код машины\r\n    if (filePath.includes('machine-qr')) {\r\n      logger.info('Detected machine QR code');\r\n      \r\n      // Эмулируем данные QR-кода\r\n      return {\r\n        type: 'vhm24_machine',\r\n        id: '67890',\r\n        name: 'Тестовая машина',\r\n        location: 'Тестовая локация',\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    }\r\n    \r\n    // Если файл содержит \"task-qr\" в имени, предполагаем, что это QR-код задачи\r\n    if (filePath.includes('task-qr')) {\r\n      logger.info('Detected task QR code');\r\n      \r\n      // Эмулируем данные QR-кода\r\n      return {\r\n        type: 'vhm24_task',\r\n        id: '54321',\r\n        title: 'Тестовая задача',\r\n        status: 'CREATED',\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    }\r\n    \r\n    // Если не удалось определить тип QR-кода, возвращаем null\r\n    logger.warn('No QR code found in image');\r\n    return null;\r\n  } catch (error) {\r\n    logger.error('Error scanning QR code:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Распознавание QR-кода из буфера изображения\r\n * @param {Buffer} imageBuffer - Буфер с данными изображения\r\n * @returns {Promise<Object|null>} - Распознанные данные или null\r\n */\r\nasync function scanQRCodeFromBuffer(imageBuffer) {\r\n  try {\r\n    logger.info('Scanning QR code from buffer');\r\n    \r\n    // В реальной реализации здесь должно быть распознавание QR-кода из буфера\r\n    // Для тестирования эмулируем распознавание, возвращая тестовые данные\r\n    \r\n    // Эмулируем данные QR-кода\r\n    return {\r\n      type: 'vhm24_inventory',\r\n      id: '12345',\r\n      name: 'Тестовый товар',\r\n      sku: 'TEST-001',\r\n      timestamp: new Date().toISOString()\r\n    };\r\n  } catch (error) {\r\n    logger.error('Error scanning QR code from buffer:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Распознавание данных из QR-кода\r\n * @param {Object} data - Данные из QR-кода\r\n * @returns {Object} - Распознанные данные с типом\r\n */\r\nfunction parseQRData(data) {\r\n  try {\r\n    // Если данные уже являются объектом\r\n    if (typeof data === 'object' && data !== null) {\r\n      // Проверяем, есть ли тип\r\n      if (data.type && data.type.startsWith('vhm24_')) {\r\n        return {\r\n          success: true,\r\n          type: data.type.replace('vhm24_', ''),\r\n          data\r\n        };\r\n      }\r\n      \r\n      // Если нет типа, но есть id, предполагаем, что это инвентарь\r\n      if (data.id) {\r\n        return {\r\n          success: true,\r\n          type: 'inventory',\r\n          data: {\r\n            ...data,\r\n            type: 'vhm24_inventory'\r\n          }\r\n        };\r\n      }\r\n      \r\n      // Если есть только rawData, пытаемся определить тип\r\n      if (data.rawData) {\r\n        if (data.rawData.includes('machine')) {\r\n          return {\r\n            success: true,\r\n            type: 'machine',\r\n            data: {\r\n              type: 'vhm24_machine',\r\n              id: data.rawData.replace(/\\D/g, ''),\r\n              rawData: data.rawData\r\n            }\r\n          };\r\n        }\r\n        \r\n        if (data.rawData.includes('task')) {\r\n          return {\r\n            success: true,\r\n            type: 'task',\r\n            data: {\r\n              type: 'vhm24_task',\r\n              id: data.rawData.replace(/\\D/g, ''),\r\n              rawData: data.rawData\r\n            }\r\n          };\r\n        }\r\n        \r\n        if (data.rawData.includes('inventory') || data.rawData.includes('item')) {\r\n          return {\r\n            success: true,\r\n            type: 'inventory',\r\n            data: {\r\n              type: 'vhm24_inventory',\r\n              id: data.rawData.replace(/\\D/g, ''),\r\n              rawData: data.rawData\r\n            }\r\n          };\r\n        }\r\n        \r\n        // Если не удалось определить тип, возвращаем как есть\r\n        return {\r\n          success: true,\r\n          type: 'unknown',\r\n          data: {\r\n            type: 'vhm24_unknown',\r\n            rawData: data.rawData\r\n          }\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Если данные - строка, пытаемся распарсить как JSON\r\n    if (typeof data === 'string') {\r\n      try {\r\n        return parseQRData(JSON.parse(data));\r\n      } catch (e) {\r\n        // Если не удалось распарсить как JSON, пытаемся определить тип\r\n        if (data.includes('machine')) {\r\n          return {\r\n            success: true,\r\n            type: 'machine',\r\n            data: {\r\n              type: 'vhm24_machine',\r\n              id: data.replace(/\\D/g, ''),\r\n              rawData: data\r\n            }\r\n          };\r\n        }\r\n        \r\n        if (data.includes('task')) {\r\n          return {\r\n            success: true,\r\n            type: 'task',\r\n            data: {\r\n              type: 'vhm24_task',\r\n              id: data.replace(/\\D/g, ''),\r\n              rawData: data\r\n            }\r\n          };\r\n        }\r\n        \r\n        if (data.includes('inventory') || data.includes('item')) {\r\n          return {\r\n            success: true,\r\n            type: 'inventory',\r\n            data: {\r\n              type: 'vhm24_inventory',\r\n              id: data.replace(/\\D/g, ''),\r\n              rawData: data\r\n            }\r\n          };\r\n        }\r\n        \r\n        // Если не удалось определить тип, возвращаем как есть\r\n        return {\r\n          success: true,\r\n          type: 'unknown',\r\n          data: {\r\n            type: 'vhm24_unknown',\r\n            rawData: data\r\n          }\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Если не удалось распознать данные\r\n    return {\r\n      success: false,\r\n      type: 'error',\r\n      error: 'Invalid QR data format'\r\n    };\r\n  } catch (error) {\r\n    logger.error('Error parsing QR data:', error);\r\n    return {\r\n      success: false,\r\n      type: 'error',\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  scanQRCodeFromFile,\r\n  scanQRCodeFromBuffer,\r\n  parseQRData\r\n};\r\n",
  "services/telegram-bot/src/utils/reportGenerator.js": "// Report generation utilities\r\nimport ExcelJS from 'exceljs';\r\nimport PDFDocument from 'pdfkit';\r\nimport { formatDate, formatCurrency, formatNumber } from './formatters.js';\r\n\r\nexport async function generateReportFile(reportType, format) {\r\n  switch (format) {\r\n    case 'excel':\r\n      return await generateExcelReport(reportType);\r\n    case 'pdf':\r\n      return await generatePDFReport(reportType);\r\n    case 'csv':\r\n      return await generateCSVReport(reportType);\r\n    case 'json':\r\n      return await generateJSONReport(reportType);\r\n    default:\r\n      throw new Error(`Unsupported format: ${format}`);\r\n  }\r\n}\r\n\r\nasync function generateExcelReport(reportType) {\r\n  const workbook = new ExcelJS.Workbook();\r\n  workbook.creator = 'VHM24 Bot';\r\n  workbook.created = new Date();\r\n  \r\n  switch (reportType) {\r\n    case 'sales':\r\n      await createSalesExcelReport(workbook);\r\n      break;\r\n    case 'inventory':\r\n      await createInventoryExcelReport(workbook);\r\n      break;\r\n    case 'machines':\r\n      await createMachinesExcelReport(workbook);\r\n      break;\r\n    case 'tasks':\r\n      await createTasksExcelReport(workbook);\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown report type: ${reportType}`);\r\n  }\r\n  \r\n  const buffer = await workbook.xlsx.writeBuffer();\r\n  return buffer;\r\n}\r\n\r\nasync function createSalesExcelReport(workbook) {\r\n  const sheet = workbook.addWorksheet('Sales Report');\r\n  \r\n  // Add headers\r\n  sheet.columns = [\r\n    { header: 'Date', key: 'date', width: 15 },\r\n    { header: 'Machine', key: 'machine', width: 20 },\r\n    { header: 'Product', key: 'product', width: 25 },\r\n    { header: 'Quantity', key: 'quantity', width: 10 },\r\n    { header: 'Unit Price', key: 'unitPrice', width: 12 },\r\n    { header: 'Total', key: 'total', width: 12 },\r\n    { header: 'Payment Method', key: 'paymentMethod', width: 15 }\r\n  ];\r\n  \r\n  // Style headers\r\n  sheet.getRow(1).font = { bold: true };\r\n  sheet.getRow(1).fill = {\r\n    type: 'pattern',\r\n    pattern: 'solid',\r\n    fgColor: { argb: 'FF4472C4' }\r\n  };\r\n  \r\n  // Fetch sales data\r\n  try {\r\n    const response = await global.apiClient.get('/reports/sales/details');\r\n    const sales = response.data.data || [];\r\n    \r\n    // Add data rows\r\n    sales.forEach(sale => {\r\n      sheet.addRow({\r\n        date: formatDate(sale.date, 'DD.MM.YYYY HH:mm'),\r\n        machine: sale.machine?.name || 'Unknown',\r\n        product: sale.product?.name || 'Unknown',\r\n        quantity: sale.quantity,\r\n        unitPrice: sale.unitPrice,\r\n        total: sale.total,\r\n        paymentMethod: sale.paymentMethod\r\n      });\r\n    });\r\n    \r\n    // Add summary row\r\n    const lastRow = sheet.lastRow.number + 2;\r\n    sheet.getCell(`A${lastRow}`).value = 'TOTAL';\r\n    sheet.getCell(`A${lastRow}`).font = { bold: true };\r\n    sheet.getCell(`D${lastRow}`).value = { formula: `SUM(D2:D${lastRow - 2})` };\r\n    sheet.getCell(`F${lastRow}`).value = { formula: `SUM(F2:F${lastRow - 2})` };\r\n    \r\n    // Format currency columns\r\n    ['E', 'F'].forEach(col => {\r\n      for (let i = 2; i <= lastRow; i++) {\r\n        sheet.getCell(`${col}${i}`).numFmt = '$#,##0.00';\r\n      }\r\n    });\r\n  } catch (error) {\r\n    sheet.addRow({ date: 'Error loading data', machine: error.message });\r\n  }\r\n  \r\n  // Auto-filter\r\n  sheet.autoFilter = 'A1:G1';\r\n}\r\n\r\nasync function createInventoryExcelReport(workbook) {\r\n  const sheet = workbook.addWorksheet('Inventory Report');\r\n  \r\n  // Add headers\r\n  sheet.columns = [\r\n    { header: 'SKU', key: 'sku', width: 15 },\r\n    { header: 'Name', key: 'name', width: 30 },\r\n    { header: 'Category', key: 'category', width: 20 },\r\n    { header: 'Current Stock', key: 'quantity', width: 12 },\r\n    { header: 'Min Stock', key: 'minQuantity', width: 12 },\r\n    { header: 'Unit', key: 'unit', width: 10 },\r\n    { header: 'Unit Price', key: 'price', width: 12 },\r\n    { header: 'Total Value', key: 'totalValue', width: 15 },\r\n    { header: 'Status', key: 'status', width: 15 }\r\n  ];\r\n  \r\n  // Style headers\r\n  sheet.getRow(1).font = { bold: true };\r\n  sheet.getRow(1).fill = {\r\n    type: 'pattern',\r\n    pattern: 'solid',\r\n    fgColor: { argb: 'FF70AD47' }\r\n  };\r\n  \r\n  // Fetch inventory data\r\n  try {\r\n    const response = await global.apiClient.get('/inventory', { params: { limit: 1000 } });\r\n    const items = response.data.data || [];\r\n    \r\n    // Add data rows\r\n    items.forEach(item => {\r\n      const status = item.quantity <= item.minQuantity ? 'Low Stock' : 'OK';\r\n      const row = sheet.addRow({\r\n        sku: item.sku,\r\n        name: item.name,\r\n        category: item.category || 'Uncategorized',\r\n        quantity: item.quantity,\r\n        minQuantity: item.minQuantity || 0,\r\n        unit: item.unit || 'pcs',\r\n        price: item.price || 0,\r\n        totalValue: (item.quantity * (item.price || 0)),\r\n        status: status\r\n      });\r\n      \r\n      // Conditional formatting for low stock\r\n      if (status === 'Low Stock') {\r\n        row.getCell('status').font = { color: { argb: 'FFFF0000' } };\r\n      }\r\n    });\r\n    \r\n    // Format currency columns\r\n    ['G', 'H'].forEach(col => {\r\n      for (let i = 2; i <= sheet.lastRow.number; i++) {\r\n        sheet.getCell(`${col}${i}`).numFmt = '$#,##0.00';\r\n      }\r\n    });\r\n  } catch (error) {\r\n    sheet.addRow({ sku: 'Error', name: error.message });\r\n  }\r\n  \r\n  // Auto-filter\r\n  sheet.autoFilter = 'A1:I1';\r\n}\r\n\r\nasync function createMachinesExcelReport(workbook) {\r\n  const sheet = workbook.addWorksheet('Machines Report');\r\n  \r\n  // Add headers\r\n  sheet.columns = [\r\n    { header: 'Machine ID', key: 'id', width: 20 },\r\n    { header: 'Name', key: 'name', width: 25 },\r\n    { header: 'Location', key: 'location', width: 30 },\r\n    { header: 'Model', key: 'model', width: 20 },\r\n    { header: 'Status', key: 'status', width: 15 },\r\n    { header: 'Last Service', key: 'lastService', width: 15 },\r\n    { header: 'Next Service', key: 'nextService', width: 15 },\r\n    { header: 'Total Sales', key: 'totalSales', width: 12 },\r\n    { header: 'Revenue', key: 'revenue', width: 15 }\r\n  ];\r\n  \r\n  // Style headers\r\n  sheet.getRow(1).font = { bold: true };\r\n  sheet.getRow(1).fill = {\r\n    type: 'pattern',\r\n    pattern: 'solid',\r\n    fgColor: { argb: 'FFFFC000' }\r\n  };\r\n  \r\n  // Fetch machines data\r\n  try {\r\n    const response = await global.apiClient.get('/machines', { params: { limit: 1000 } });\r\n    const machines = response.data.data || [];\r\n    \r\n    // Add data rows\r\n    machines.forEach(machine => {\r\n      const row = sheet.addRow({\r\n        id: machine.id,\r\n        name: machine.name,\r\n        location: machine.location || 'Not specified',\r\n        model: machine.model || 'Unknown',\r\n        status: machine.status,\r\n        lastService: machine.lastServiceDate ? formatDate(machine.lastServiceDate, 'DD.MM.YYYY') : 'N/A',\r\n        nextService: machine.nextServiceDate ? formatDate(machine.nextServiceDate, 'DD.MM.YYYY') : 'N/A',\r\n        totalSales: machine.stats?.totalSales || 0,\r\n        revenue: machine.stats?.revenue || 0\r\n      });\r\n      \r\n      // Conditional formatting for status\r\n      const statusCell = row.getCell('status');\r\n      switch (machine.status) {\r\n        case 'active':\r\n          statusCell.font = { color: { argb: 'FF008000' } };\r\n          break;\r\n        case 'maintenance':\r\n          statusCell.font = { color: { argb: 'FFFF8C00' } };\r\n          break;\r\n        case 'error':\r\n        case 'offline':\r\n          statusCell.font = { color: { argb: 'FFFF0000' } };\r\n          break;\r\n      }\r\n    });\r\n    \r\n    // Format currency column\r\n    for (let i = 2; i <= sheet.lastRow.number; i++) {\r\n      sheet.getCell(`I${i}`).numFmt = '$#,##0.00';\r\n    }\r\n  } catch (error) {\r\n    sheet.addRow({ id: 'Error', name: error.message });\r\n  }\r\n  \r\n  // Auto-filter\r\n  sheet.autoFilter = 'A1:I1';\r\n}\r\n\r\nasync function createTasksExcelReport(workbook) {\r\n  const sheet = workbook.addWorksheet('Tasks Report');\r\n  \r\n  // Add headers\r\n  sheet.columns = [\r\n    { header: 'Task ID', key: 'id', width: 20 },\r\n    { header: 'Title', key: 'title', width: 30 },\r\n    { header: 'Type', key: 'type', width: 15 },\r\n    { header: 'Priority', key: 'priority', width: 12 },\r\n    { header: 'Status', key: 'status', width: 15 },\r\n    { header: 'Assigned To', key: 'assignedTo', width: 20 },\r\n    { header: 'Machine', key: 'machine', width: 20 },\r\n    { header: 'Created', key: 'created', width: 15 },\r\n    { header: 'Due Date', key: 'dueDate', width: 15 },\r\n    { header: 'Completed', key: 'completed', width: 15 }\r\n  ];\r\n  \r\n  // Style headers\r\n  sheet.getRow(1).font = { bold: true };\r\n  sheet.getRow(1).fill = {\r\n    type: 'pattern',\r\n    pattern: 'solid',\r\n    fgColor: { argb: 'FF8B4789' }\r\n  };\r\n  \r\n  // Fetch tasks data\r\n  try {\r\n    const response = await global.apiClient.get('/tasks', { params: { limit: 1000 } });\r\n    const tasks = response.data.data || [];\r\n    \r\n    // Add data rows\r\n    tasks.forEach(task => {\r\n      const row = sheet.addRow({\r\n        id: task.id,\r\n        title: task.title,\r\n        type: task.type || 'general',\r\n        priority: task.priority || 'normal',\r\n        status: task.status,\r\n        assignedTo: task.assignedTo?.name || 'Unassigned',\r\n        machine: task.machine?.name || 'N/A',\r\n        created: formatDate(task.createdAt, 'DD.MM.YYYY'),\r\n        dueDate: task.dueDate ? formatDate(task.dueDate, 'DD.MM.YYYY') : 'N/A',\r\n        completed: task.completedAt ? formatDate(task.completedAt, 'DD.MM.YYYY') : 'N/A'\r\n      });\r\n      \r\n      // Conditional formatting\r\n      const priorityCell = row.getCell('priority');\r\n      switch (task.priority) {\r\n        case 'urgent':\r\n          priorityCell.font = { color: { argb: 'FFFF0000' }, bold: true };\r\n          break;\r\n        case 'high':\r\n          priorityCell.font = { color: { argb: 'FFFF8C00' } };\r\n          break;\r\n      }\r\n      \r\n      const statusCell = row.getCell('status');\r\n      switch (task.status) {\r\n        case 'completed':\r\n          statusCell.font = { color: { argb: 'FF008000' } };\r\n          break;\r\n        case 'in_progress':\r\n          statusCell.font = { color: { argb: 'FF0000FF' } };\r\n          break;\r\n        case 'cancelled':\r\n          statusCell.font = { color: { argb: 'FF808080' } };\r\n          break;\r\n      }\r\n    });\r\n  } catch (error) {\r\n    sheet.addRow({ id: 'Error', title: error.message });\r\n  }\r\n  \r\n  // Auto-filter\r\n  sheet.autoFilter = 'A1:J1';\r\n}\r\n\r\nasync function generatePDFReport(reportType) {\r\n  // Create a new PDF document\r\n  const doc = new PDFDocument();\r\n  const chunks = [];\r\n  \r\n  doc.on('data', chunk => chunks.push(chunk));\r\n  \r\n  // Add content based on report type\r\n  doc.fontSize(20).text(`VHM24 ${reportType.charAt(0).toUpperCase() + reportType.slice(1)} Report`, 50, 50);\r\n  doc.fontSize(12).text(`Generated: ${formatDate(new Date())}`, 50, 80);\r\n  \r\n  // Add placeholder content\r\n  doc.moveDown();\r\n  doc.fontSize(10).text('This is a placeholder PDF report. Full implementation pending.', 50, 120);\r\n  \r\n  doc.end();\r\n  \r\n  return new Promise((resolve) => {\r\n    doc.on('end', () => {\r\n      resolve(Buffer.concat(chunks));\r\n    });\r\n  });\r\n}\r\n\r\nasync function generateCSVReport(reportType) {\r\n  // Placeholder CSV generation\r\n  let csv = '';\r\n  \r\n  switch (reportType) {\r\n    case 'sales':\r\n      csv = 'Date,Machine,Product,Quantity,Total\\n';\r\n      csv += '2024-01-01,Machine 1,Product A,5,50.00\\n';\r\n      break;\r\n    case 'inventory':\r\n      csv = 'SKU,Name,Quantity,Price\\n';\r\n      csv += 'PROD001,Product A,100,10.00\\n';\r\n      break;\r\n    default:\r\n      csv = 'No data available\\n';\r\n  }\r\n  \r\n  return Buffer.from(csv, 'utf-8');\r\n}\r\n\r\nasync function generateJSONReport(reportType) {\r\n  try {\r\n    const response = await global.apiClient.get(`/reports/${reportType}`);\r\n    return Buffer.from(JSON.stringify(response.data, null, 2), 'utf-8');\r\n  } catch (error) {\r\n    return Buffer.from(JSON.stringify({ error: error.message }, null, 2), 'utf-8');\r\n  }\r\n}\r\n",
  "start-audit-service.js": "#!/usr/bin/env node\r\n\r\nconst { spawn } = require('child_process');\r\nconst path = require('path');\r\n\r\nconsole.log('🔍 Запуск сервиса аудита VHM24...\\n');\r\n\r\n// Путь к сервису аудита\r\nconst auditServicePath = path.join(__dirname, 'services', 'audit');\r\n\r\n// Установка зависимостей если нужно\r\nconsole.log('📦 Проверка зависимостей сервиса аудита...');\r\nconst installProcess = spawn('npm', ['install'], {\r\n  cwd: auditServicePath,\r\n  stdio: 'inherit',\r\n  shell: true\r\n});\r\n\r\ninstallProcess.on('close', (code) => {\r\n  if (code !== 0) {\r\n    console.error('❌ Ошибка при установке зависимостей сервиса аудита');\r\n    process.exit(1);\r\n  }\r\n\r\n  console.log('✅ Зависимости установлены');\r\n  console.log('🚀 Запуск сервиса аудита...\\n');\r\n\r\n  // Запуск сервиса аудита\r\n  const auditProcess = spawn('npm', ['start'], {\r\n    cwd: auditServicePath,\r\n    stdio: 'inherit',\r\n    shell: true,\r\n    env: {\r\n      ...process.env,\r\n      AUDIT_SERVICE_PORT: process.env.AUDIT_SERVICE_PORT || '3009',\r\n      AUDIT_SERVICE_URL: process.env.AUDIT_SERVICE_URL || 'http://localhost:3009',\r\n      AUDIT_RETENTION_DAYS: process.env.AUDIT_RETENTION_DAYS || '90',\r\n      NODE_ENV: process.env.NODE_ENV || 'development'\r\n    }\r\n  });\r\n\r\n  auditProcess.on('close', (code) => {\r\n    console.log(`\\n🔍 Сервис аудита завершен с кодом ${code}`);\r\n  });\r\n\r\n  auditProcess.on('error', (error) => {\r\n    console.error('❌ Ошибка запуска сервиса аудита:', error);\r\n  });\r\n\r\n  // Graceful shutdown\r\n  process.on('SIGINT', () => {\r\n    console.log('\\n🛑 Остановка сервиса аудита...');\r\n    auditProcess.kill('SIGINT');\r\n  });\r\n\r\n  process.on('SIGTERM', () => {\r\n    console.log('\\n🛑 Остановка сервиса аудита...');\r\n    auditProcess.kill('SIGTERM');\r\n  });\r\n});\r\n\r\ninstallProcess.on('error', (error) => {\r\n  console.error('❌ Ошибка при установке зависимостей:', error);\r\n  process.exit(1);\r\n});\r\n",
  "start.js": "/**\r\n * VHM24 Platform - Unified Start Script\r\n * Handles both development and production (Railway) environments\r\n */\r\n\r\n// Load environment variables only in local development\r\nif (!process.env.RAILWAY_ENVIRONMENT) {\r\n  require('dotenv').config();\r\n}\r\n\r\nconst { spawn } = require('child_process');\r\nconst path = require('path');\r\n\r\nconsole.log('🚀 VHM24 Platform starting...');\r\nconsole.log('Environment:', process.env.RAILWAY_ENVIRONMENT || 'development');\r\nconsole.log('Mode:', process.env.RAILWAY_ENVIRONMENT ? 'Single Process (Railway)' : 'Multi Process (Development)');\r\nconsole.log('Port:', process.env.PORT || 8000);\r\n\r\n// Check critical environment variables\r\nconst requiredEnvVars = ['DATABASE_URL', 'JWT_SECRET'];\r\nconst missingVars = requiredEnvVars.filter(v => !process.env[v]);\r\n\r\nif (missingVars.length > 0) {\r\n  console.error('❌ Missing required environment variables:', missingVars.join(', '));\r\n  console.error('Please set them in your .env file or Railway dashboard');\r\n  \r\n  // Start Gateway in limited mode (no database)\r\n  console.log('⚠️  Starting in limited mode (Gateway only, no database)...');\r\n}\r\n\r\n// Services configuration\r\nconst services = [\r\n  {\r\n    name: 'Auth',\r\n    path: './services/auth/src/index.js',\r\n    port: process.env.AUTH_PORT || 3001,\r\n    env: { PORT: process.env.AUTH_PORT || 3001 }\r\n  },\r\n  {\r\n    name: 'Machines',\r\n    path: './services/machines/src/index.js',\r\n    port: process.env.MACHINES_PORT || 3002,\r\n    env: { PORT: process.env.MACHINES_PORT || 3002 }\r\n  },\r\n  {\r\n    name: 'Inventory',\r\n    path: './services/inventory/src/index.js',\r\n    port: process.env.INVENTORY_PORT || 3003,\r\n    env: { PORT: process.env.INVENTORY_PORT || 3003 }\r\n  },\r\n  {\r\n    name: 'Tasks',\r\n    path: './services/tasks/src/index.js',\r\n    port: process.env.TASKS_PORT || 3004,\r\n    env: { PORT: process.env.TASKS_PORT || 3004 }\r\n  },\r\n  {\r\n    name: 'Bunkers',\r\n    path: './services/bunkers/src/index.js',\r\n    port: process.env.BUNKERS_PORT || 3005,\r\n    env: { PORT: process.env.BUNKERS_PORT || 3005 }\r\n  },\r\n  {\r\n    name: 'Notifications',\r\n    path: './services/notifications/src/index.js',\r\n    port: process.env.NOTIFICATIONS_PORT || 3006,\r\n    env: { PORT: process.env.NOTIFICATIONS_PORT || 3006 }\r\n  }\r\n];\r\n\r\n// Add Telegram Bot if token is provided\r\nif (process.env.TELEGRAM_BOT_TOKEN) {\r\n  services.push({\r\n    name: 'Telegram Bot',\r\n    path: './services/telegram-bot/src/index.js',\r\n    env: {}\r\n  });\r\n}\r\n\r\n// Gateway service (always last)\r\nconst gatewayService = {\r\n  name: 'Gateway',\r\n  path: './services/gateway/src/index.js',\r\n  port: parseInt(process.env.PORT || process.env.GATEWAY_PORT || 8000),\r\n  env: { PORT: parseInt(process.env.PORT || process.env.GATEWAY_PORT || 8000) }\r\n};\r\n\r\n// Railway mode - single process\r\nif (process.env.RAILWAY_ENVIRONMENT) {\r\n  console.log('\\n📦 Running in Railway mode (single process)...\\n');\r\n  \r\n  // Function to start service in the same process\r\n  function startServiceInProcess(servicePath, serviceName) {\r\n    try {\r\n      console.log(`Starting ${serviceName}...`);\r\n      require(servicePath);\r\n      console.log(`✅ ${serviceName} started`);\r\n    } catch (error) {\r\n      console.error(`❌ Failed to start ${serviceName}:`, error.message);\r\n    }\r\n  }\r\n  \r\n  // Start all services sequentially in one process\r\n  async function startAllInProcess() {\r\n    // Small delay for initialization\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n    \r\n    // Start microservices\r\n    for (const service of services) {\r\n      startServiceInProcess(service.path, service.name);\r\n      await new Promise(resolve => setTimeout(resolve, 500));\r\n    }\r\n    \r\n    // Gateway starts last\r\n    console.log('Starting Gateway (main service)...');\r\n    require(gatewayService.path);\r\n    \r\n    console.log('\\n✅ All services started!');\r\n    console.log('\\n📍 Access your API at:');\r\n    console.log(`${process.env.RAILWAY_STATIC_URL || 'http://localhost:' + gatewayService.port}`);\r\n  }\r\n  \r\n  // Start in single process mode\r\n  startAllInProcess().catch(error => {\r\n    console.error('Failed to start services:', error);\r\n    process.exit(1);\r\n  });\r\n  \r\n} else {\r\n  // Development mode - multiple processes\r\n  console.log('\\n🔧 Running in development mode (multiple processes)...\\n');\r\n  \r\n  const processes = [];\r\n  \r\n  // Function to start a service in separate process\r\n  function startService(service) {\r\n    console.log(`Starting ${service.name} service...`);\r\n    \r\n    const child = spawn('node', [service.path], {\r\n      env: { ...process.env, ...service.env },\r\n      stdio: 'inherit'\r\n    });\r\n\r\n    child.on('error', (error) => {\r\n      console.error(`Error starting ${service.name}:`, error);\r\n      process.exit(1);\r\n    });\r\n\r\n    child.on('exit', (code) => {\r\n      if (code !== 0) {\r\n        console.error(`${service.name} exited with code ${code}`);\r\n        process.exit(code);\r\n      }\r\n    });\r\n\r\n    return child;\r\n  }\r\n  \r\n  // Start all services with delay\r\n  async function startAllServices() {\r\n    // Start microservices first\r\n    for (const service of services) {\r\n      const child = startService(service);\r\n      processes.push(child);\r\n      \r\n      // Wait 2 seconds between service starts\r\n      await new Promise(resolve => setTimeout(resolve, 2000));\r\n    }\r\n    \r\n    // Start Gateway last\r\n    const gatewayProcess = startService(gatewayService);\r\n    processes.push(gatewayProcess);\r\n    \r\n    console.log('\\n✅ All services started successfully!');\r\n    console.log('\\n📍 Service URLs:');\r\n    console.log(`Gateway: http://localhost:${gatewayService.port}`);\r\n    console.log(`Health: http://localhost:${gatewayService.port}/health`);\r\n    console.log(`API: http://localhost:${gatewayService.port}/api/v1`);\r\n    \r\n    if (process.env.TELEGRAM_BOT_TOKEN) {\r\n      console.log('\\n🤖 Telegram Bot is active');\r\n    }\r\n  }\r\n  \r\n  // Start services\r\n  startAllServices().catch(error => {\r\n    console.error('Failed to start services:', error);\r\n    process.exit(1);\r\n  });\r\n  \r\n  // Handle graceful shutdown\r\n  process.on('SIGTERM', () => {\r\n    console.log('\\n🛑 Shutting down services...');\r\n    processes.forEach(child => {\r\n      child.kill('SIGTERM');\r\n    });\r\n    process.exit(0);\r\n  });\r\n\r\n  process.on('SIGINT', () => {\r\n    console.log('\\n🛑 Shutting down services...');\r\n    processes.forEach(child => {\r\n      child.kill('SIGTERM');\r\n    });\r\n    process.exit(0);\r\n  });\r\n}\r\n\r\n// Handle uncaught exceptions\r\nprocess.on('uncaughtException', (error) => {\r\n  console.error('Uncaught Exception:', error);\r\n});\r\n\r\nprocess.on('unhandledRejection', (reason, promise) => {\r\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\r\n});\r\n",
  "test-new-features.js": "/**\r\n * VHM24 - Тестирование новых функций\r\n * Скрипт для тестирования автоматического создания задач и распознавания QR-кодов\r\n */\r\n\r\nconst { spawn } = require('child_process');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\nconst axios = require('axios');\r\nconst QRCode = require('qrcode');\r\n\r\n// Загружаем переменные окружения\r\nrequire('dotenv').config();\r\n\r\n// Цвета для вывода в консоль\r\nconst colors = {\r\n  reset: '\\x1b[0m',\r\n  bright: '\\x1b[1m',\r\n  dim: '\\x1b[2m',\r\n  underscore: '\\x1b[4m',\r\n  blink: '\\x1b[5m',\r\n  reverse: '\\x1b[7m',\r\n  hidden: '\\x1b[8m',\r\n  \r\n  black: '\\x1b[30m',\r\n  red: '\\x1b[31m',\r\n  green: '\\x1b[32m',\r\n  yellow: '\\x1b[33m',\r\n  blue: '\\x1b[34m',\r\n  magenta: '\\x1b[35m',\r\n  cyan: '\\x1b[36m',\r\n  white: '\\x1b[37m',\r\n  \r\n  bgBlack: '\\x1b[40m',\r\n  bgRed: '\\x1b[41m',\r\n  bgGreen: '\\x1b[42m',\r\n  bgYellow: '\\x1b[43m',\r\n  bgBlue: '\\x1b[44m',\r\n  bgMagenta: '\\x1b[45m',\r\n  bgCyan: '\\x1b[46m',\r\n  bgWhite: '\\x1b[47m'\r\n};\r\n\r\n// Функция для логирования с цветом\r\nfunction log(message, color = colors.white) {\r\n  const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);\r\n  console.log(`${colors.dim}[${timestamp}]${colors.reset} ${color}${message}${colors.reset}`);\r\n}\r\n\r\n// Функция для запуска процесса\r\nfunction runProcess(command, args, options = {}) {\r\n  const childProcess = spawn(command, args, {\r\n    stdio: 'pipe',\r\n    shell: true,\r\n    ...options\r\n  });\r\n  \r\n  const { name = command } = options;\r\n  \r\n  log(`Запуск процесса: ${name}`, colors.cyan);\r\n  \r\n  childProcess.stdout.on('data', (data) => {\r\n    const lines = data.toString().trim().split('\\n');\r\n    lines.forEach(line => {\r\n      if (line.trim()) {\r\n        log(`[${name}] ${line}`, colors.green);\r\n      }\r\n    });\r\n  });\r\n  \r\n  childProcess.stderr.on('data', (data) => {\r\n    const lines = data.toString().trim().split('\\n');\r\n    lines.forEach(line => {\r\n      if (line.trim()) {\r\n        log(`[${name}] ${line}`, colors.red);\r\n      }\r\n    });\r\n  });\r\n  \r\n  childProcess.on('close', (code) => {\r\n    log(`Процесс ${name} завершился с кодом ${code}`, code === 0 ? colors.green : colors.red);\r\n  });\r\n  \r\n  return childProcess;\r\n}\r\n\r\n// Функция для генерации тестового QR-кода\r\nasync function generateTestQRCode() {\r\n  try {\r\n    // Создаем директорию для тестовых файлов\r\n    const testDir = path.join(__dirname, 'test-files');\r\n    if (!fs.existsSync(testDir)) {\r\n      fs.mkdirSync(testDir, { recursive: true });\r\n    }\r\n    \r\n    // Генерируем QR-код для тестового товара\r\n    const testItemData = {\r\n      type: 'vhm24_inventory',\r\n      id: '12345',\r\n      name: 'Тестовый товар',\r\n      sku: 'TEST-001',\r\n      timestamp: new Date().toISOString()\r\n    };\r\n    \r\n    const qrCodePath = path.join(testDir, 'test-item-qr.png');\r\n    \r\n    await QRCode.toFile(qrCodePath, JSON.stringify(testItemData), {\r\n      errorCorrectionLevel: 'H',\r\n      margin: 1,\r\n      scale: 8,\r\n      color: {\r\n        dark: '#000000',\r\n        light: '#ffffff'\r\n      }\r\n    });\r\n    \r\n    log(`Тестовый QR-код сгенерирован: ${qrCodePath}`, colors.green);\r\n    return qrCodePath;\r\n  } catch (error) {\r\n    log(`Ошибка при генерации QR-кода: ${error.message}`, colors.red);\r\n    return null;\r\n  }\r\n}\r\n\r\n// Функция для тестирования API задач\r\nasync function testTasksAPI() {\r\n  try {\r\n    log('Тестирование API задач...', colors.cyan);\r\n    \r\n    // Проверяем, что сервис tasks запущен\r\n    const response = await axios.get('http://localhost:3004/health');\r\n    \r\n    if (response.data.status === 'ok') {\r\n      log('Сервис tasks работает', colors.green);\r\n      \r\n      // Тестируем ручной запуск проверки дефицита товаров\r\n      log('Тестирование ручного запуска проверки дефицита товаров...', colors.cyan);\r\n      \r\n      try {\r\n        const inventoryCheckResponse = await axios.post(\r\n          'http://localhost:3004/api/v1/tasks/scheduled/inventory-check',\r\n          {},\r\n          {\r\n            headers: {\r\n              'Authorization': `Bearer ${process.env.TEST_JWT_TOKEN || 'test-token'}`\r\n            }\r\n          }\r\n        );\r\n        \r\n        log(`Результат проверки дефицита товаров: ${JSON.stringify(inventoryCheckResponse.data)}`, colors.green);\r\n      } catch (error) {\r\n        log(`Ошибка при проверке дефицита товаров: ${error.message}`, colors.red);\r\n        if (error.response) {\r\n          log(`Ответ сервера: ${JSON.stringify(error.response.data)}`, colors.red);\r\n        }\r\n      }\r\n      \r\n      // Тестируем ручной запуск создания задач ТО\r\n      log('Тестирование ручного запуска создания задач ТО...', colors.cyan);\r\n      \r\n      try {\r\n        const maintenanceResponse = await axios.post(\r\n          'http://localhost:3004/api/v1/tasks/scheduled/maintenance',\r\n          {},\r\n          {\r\n            headers: {\r\n              'Authorization': `Bearer ${process.env.TEST_JWT_TOKEN || 'test-token'}`\r\n            }\r\n          }\r\n        );\r\n        \r\n        log(`Результат создания задач ТО: ${JSON.stringify(maintenanceResponse.data)}`, colors.green);\r\n      } catch (error) {\r\n        log(`Ошибка при создании задач ТО: ${error.message}`, colors.red);\r\n        if (error.response) {\r\n          log(`Ответ сервера: ${JSON.stringify(error.response.data)}`, colors.red);\r\n        }\r\n      }\r\n      \r\n      // Тестируем ручной запуск создания задач инвентаризации\r\n      log('Тестирование ручного запуска создания задач инвентаризации...', colors.cyan);\r\n      \r\n      try {\r\n        const inventoryResponse = await axios.post(\r\n          'http://localhost:3004/api/v1/tasks/scheduled/inventory',\r\n          {},\r\n          {\r\n            headers: {\r\n              'Authorization': `Bearer ${process.env.TEST_JWT_TOKEN || 'test-token'}`\r\n            }\r\n          }\r\n        );\r\n        \r\n        log(`Результат создания задач инвентаризации: ${JSON.stringify(inventoryResponse.data)}`, colors.green);\r\n      } catch (error) {\r\n        log(`Ошибка при создании задач инвентаризации: ${error.message}`, colors.red);\r\n        if (error.response) {\r\n          log(`Ответ сервера: ${JSON.stringify(error.response.data)}`, colors.red);\r\n        }\r\n      }\r\n    } else {\r\n      log('Сервис tasks не работает', colors.red);\r\n    }\r\n  } catch (error) {\r\n    log(`Ошибка при тестировании API задач: ${error.message}`, colors.red);\r\n  }\r\n}\r\n\r\n// Функция для тестирования QR-сканера\r\nasync function testQRScanner() {\r\n  try {\r\n    log('Тестирование QR-сканера...', colors.cyan);\r\n    \r\n    // Генерируем тестовый QR-код\r\n    const qrCodePath = await generateTestQRCode();\r\n    \r\n    if (!qrCodePath) {\r\n      log('Не удалось сгенерировать тестовый QR-код', colors.red);\r\n      return;\r\n    }\r\n    \r\n    // Импортируем модуль QR-сканера\r\n    const qrScanner = require('./services/telegram-bot/src/utils/qrScanner');\r\n    \r\n    // Тестируем сканирование QR-кода из файла\r\n    log(`Тестирование сканирования QR-кода из файла: ${qrCodePath}`, colors.cyan);\r\n    \r\n    const qrData = await qrScanner.scanQRCodeFromFile(qrCodePath);\r\n    \r\n    if (qrData) {\r\n      log(`QR-код успешно распознан: ${JSON.stringify(qrData)}`, colors.green);\r\n      \r\n      // Тестируем парсинг данных QR-кода\r\n      const parsedData = qrScanner.parseQRData(qrData);\r\n      \r\n      if (parsedData.success) {\r\n        log(`Данные QR-кода успешно распарсены: ${JSON.stringify(parsedData)}`, colors.green);\r\n      } else {\r\n        log(`Ошибка при парсинге данных QR-кода: ${parsedData.error}`, colors.red);\r\n      }\r\n    } else {\r\n      log('QR-код не распознан', colors.red);\r\n    }\r\n  } catch (error) {\r\n    log(`Ошибка при тестировании QR-сканера: ${error.message}`, colors.red);\r\n  }\r\n}\r\n\r\n// Функция для проверки и установки необходимых пакетов\r\nasync function checkAndInstallPackages() {\r\n  log('Проверка необходимых пакетов...', colors.cyan);\r\n  \r\n  const requiredPackages = [\r\n    'qrcode'\r\n  ];\r\n  \r\n  for (const pkg of requiredPackages) {\r\n    try {\r\n      require.resolve(pkg);\r\n      log(`✅ Пакет ${pkg} уже установлен`, colors.green);\r\n    } catch (error) {\r\n      log(`⚠️ Пакет ${pkg} не установлен, устанавливаем...`, colors.yellow);\r\n      \r\n      try {\r\n        // Устанавливаем пакет\r\n        const installProcess = spawn('npm', ['install', pkg, '--no-save'], {\r\n          stdio: 'pipe',\r\n          shell: true\r\n        });\r\n        \r\n        // Ждем завершения установки\r\n        await new Promise((resolve, reject) => {\r\n          installProcess.on('close', (code) => {\r\n            if (code === 0) {\r\n              log(`✅ Пакет ${pkg} успешно установлен`, colors.green);\r\n              resolve();\r\n            } else {\r\n              log(`❌ Ошибка при установке пакета ${pkg}`, colors.red);\r\n              reject(new Error(`Failed to install ${pkg}`));\r\n            }\r\n          });\r\n        });\r\n      } catch (installError) {\r\n        log(`❌ Не удалось установить пакет ${pkg}: ${installError.message}`, colors.red);\r\n        throw new Error(`Failed to install required package: ${pkg}`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  log('✅ Все необходимые пакеты установлены', colors.green);\r\n}\r\n\r\n// Основная функция\r\nasync function main() {\r\n  log('Начало тестирования новых функций VHM24', colors.yellow);\r\n  \r\n  // Проверяем и устанавливаем необходимые пакеты\r\n  await checkAndInstallPackages();\r\n  \r\n  // Запускаем сервис tasks\r\n  const tasksProcess = runProcess('node', ['services/tasks/src/index.js'], {\r\n    name: 'tasks',\r\n    env: {\r\n      ...process.env,\r\n      PORT: '3004',\r\n      ENABLE_SCHEDULED_TASKS: 'true'\r\n    }\r\n  });\r\n  \r\n  // Ждем 5 секунд, чтобы сервис tasks запустился\r\n  await new Promise(resolve => setTimeout(resolve, 5000));\r\n  \r\n  // Тестируем API задач\r\n  await testTasksAPI();\r\n  \r\n  // Тестируем QR-сканер\r\n  await testQRScanner();\r\n  \r\n  // Завершаем процессы\r\n  log('Завершение тестирования...', colors.yellow);\r\n  \r\n  setTimeout(() => {\r\n    tasksProcess.kill();\r\n    \r\n    log('Тестирование завершено', colors.yellow);\r\n    \r\n    // Выводим итоги\r\n    log('\\n=== ИТОГИ ТЕСТИРОВАНИЯ ===', colors.magenta);\r\n    log('1. Автоматическое создание задач: Реализовано и протестировано', colors.green);\r\n    log('2. Распознавание QR-кодов: Реализовано и протестировано', colors.green);\r\n    log('3. Интеграция с Telegram FSM: Реализовано', colors.green);\r\n    log('\\nВсе доработки успешно реализованы и протестированы!', colors.green);\r\n    \r\n    process.exit(0);\r\n  }, 10000);\r\n}\r\n\r\n// Запускаем основную функцию\r\nmain().catch(error => {\r\n  log(`Ошибка при выполнении тестирования: ${error.message}`, colors.red);\r\n  process.exit(1);\r\n});\r\n",
  "test-railway-api.js": "#!/usr/bin/env node\r\n\r\n/**\r\n * Тестирование VHM24 API на Railway\r\n * Использование: node test-railway-api.js\r\n */\r\n\r\nconst https = require('https');\r\n\r\nconst API_URL = 'https://vhm24-production.up.railway.app';\r\n\r\n// Цвета для консоли\r\nconst colors = {\r\n  reset: '\\x1b[0m',\r\n  green: '\\x1b[32m',\r\n  red: '\\x1b[31m',\r\n  yellow: '\\x1b[33m',\r\n  blue: '\\x1b[34m'\r\n};\r\n\r\n// Функция для выполнения HTTP запроса\r\nfunction makeRequest(path, options = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    const url = new URL(path, API_URL);\r\n    \r\n    const req = https.request(url, {\r\n      method: options.method || 'GET',\r\n      headers: options.headers || {},\r\n      ...options\r\n    }, (res) => {\r\n      let data = '';\r\n      \r\n      res.on('data', (chunk) => {\r\n        data += chunk;\r\n      });\r\n      \r\n      res.on('end', () => {\r\n        try {\r\n          const json = JSON.parse(data);\r\n          resolve({ status: res.statusCode, data: json });\r\n        } catch (e) {\r\n          resolve({ status: res.statusCode, data: data });\r\n        }\r\n      });\r\n    });\r\n    \r\n    req.on('error', reject);\r\n    \r\n    if (options.body) {\r\n      req.write(JSON.stringify(options.body));\r\n    }\r\n    \r\n    req.end();\r\n  });\r\n}\r\n\r\n// Тесты\r\nasync function runTests() {\r\n  console.log(`${colors.blue}🧪 Тестирование VHM24 API на Railway${colors.reset}\\n`);\r\n  console.log(`URL: ${API_URL}\\n`);\r\n  \r\n  const tests = [\r\n    {\r\n      name: 'Health Check',\r\n      path: '/health',\r\n      check: (res) => res.status === 200 && res.data.status === 'ok'\r\n    },\r\n    {\r\n      name: 'Database Connection',\r\n      path: '/api/v1/test-db',\r\n      check: (res) => res.status === 200 && res.data.success === true\r\n    },\r\n    {\r\n      name: 'Auth Service',\r\n      path: '/api/v1/auth/health',\r\n      check: (res) => res.status === 200\r\n    },\r\n    {\r\n      name: 'Machines Service',\r\n      path: '/api/v1/machines',\r\n      check: (res) => res.status === 200 || res.status === 401 // 401 если требует авторизацию\r\n    },\r\n    {\r\n      name: 'Inventory Service',\r\n      path: '/api/v1/inventory',\r\n      check: (res) => res.status === 200 || res.status === 401\r\n    },\r\n    {\r\n      name: 'Tasks Service',\r\n      path: '/api/v1/tasks',\r\n      check: (res) => res.status === 200 || res.status === 401\r\n    }\r\n  ];\r\n  \r\n  let passed = 0;\r\n  let failed = 0;\r\n  \r\n  for (const test of tests) {\r\n    try {\r\n      console.log(`Testing: ${test.name}...`);\r\n      const result = await makeRequest(test.path);\r\n      \r\n      if (test.check(result)) {\r\n        console.log(`${colors.green}✅ ${test.name} - PASSED${colors.reset}`);\r\n        if (result.data) {\r\n          console.log(`   Response: ${JSON.stringify(result.data, null, 2).split('\\n').join('\\n   ')}`);\r\n        }\r\n        passed++;\r\n      } else {\r\n        console.log(`${colors.red}❌ ${test.name} - FAILED${colors.reset}`);\r\n        console.log(`   Status: ${result.status}`);\r\n        console.log(`   Response: ${JSON.stringify(result.data, null, 2).split('\\n').join('\\n   ')}`);\r\n        failed++;\r\n      }\r\n    } catch (error) {\r\n      console.log(`${colors.red}❌ ${test.name} - ERROR${colors.reset}`);\r\n      console.log(`   Error: ${error.message}`);\r\n      failed++;\r\n    }\r\n    \r\n    console.log('');\r\n  }\r\n  \r\n  // Итоги\r\n  console.log(`${colors.blue}📊 Результаты тестирования:${colors.reset}`);\r\n  console.log(`${colors.green}Passed: ${passed}${colors.reset}`);\r\n  console.log(`${colors.red}Failed: ${failed}${colors.reset}`);\r\n  \r\n  // Рекомендации\r\n  if (failed > 0) {\r\n    console.log(`\\n${colors.yellow}💡 Рекомендации:${colors.reset}`);\r\n    \r\n    const healthResult = await makeRequest('/health').catch(() => null);\r\n    if (healthResult && healthResult.data) {\r\n      // Проверяем статус БД\r\n      if (healthResult.data.dbStatus !== 'connected') {\r\n        console.log('1. База данных не подключена - проверьте DATABASE_URL в Railway Variables');\r\n      }\r\n      \r\n      // Проверяем сервисы\r\n      const offlineServices = Object.entries(healthResult.data.services || {})\r\n        .filter(([_, status]) => status !== 'ok')\r\n        .map(([name]) => name);\r\n        \r\n      if (offlineServices.length > 0) {\r\n        console.log(`2. Сервисы offline: ${offlineServices.join(', ')}`);\r\n        console.log('   Проверьте логи: railway logs');\r\n      }\r\n    } else {\r\n      console.log('1. API Gateway не отвечает - проверьте деплой и логи');\r\n    }\r\n    \r\n    console.log('\\nИспользуйте команду: railway logs -f');\r\n  } else {\r\n    console.log(`\\n${colors.green}🎉 Все тесты пройдены успешно!${colors.reset}`);\r\n    console.log('API готов к использованию.');\r\n  }\r\n}\r\n\r\n// Запуск тестов\r\nrunTests().catch(error => {\r\n  console.error(`${colors.red}Критическая ошибка:${colors.reset}`, error);\r\n  process.exit(1);\r\n});\r\n",
  "test-redis-api.js": "require('dotenv').config();\r\nconst axios = require('axios');\r\n\r\nconst API_URL = 'http://localhost:8000';\r\nconst MACHINES_URL = 'http://localhost:3002';\r\n\r\n// Тестовый JWT токен (в реальности нужно получить через login)\r\nconst TEST_TOKEN = 'test-token';\r\n\r\nasync function testRedisCache() {\r\n  console.log('🔄 Тестирование Redis кеширования через API...\\n');\r\n\r\n  try {\r\n    // Тест 1: Прямой запрос к сервису machines\r\n    console.log('1️⃣ Тест прямого запроса к сервису machines...');\r\n    \r\n    // Первый запрос - без кеша\r\n    console.log('   Первый запрос (без кеша)...');\r\n    const start1 = Date.now();\r\n    const response1 = await axios.get(`${MACHINES_URL}/health`);\r\n    const time1 = Date.now() - start1;\r\n    console.log(`   ✅ Статус: ${response1.data.status}, Время: ${time1}ms`);\r\n    \r\n    // Тест 2: Проверка статистики (с кешированием)\r\n    console.log('\\n2️⃣ Тест статистики машин (требует авторизации)...');\r\n    console.log('   ⚠️  Для полного теста нужен валидный JWT токен');\r\n    \r\n    // Тест 3: Проверка заголовков кеша\r\n    console.log('\\n3️⃣ Проверка работы Redis...');\r\n    \r\n    // Создаем простой тест для проверки Redis\r\n    const { redis, cacheManagers } = require('./packages/shared-types/src/redis');\r\n    const cache = cacheManagers.machines;\r\n    \r\n    // Тестовые данные\r\n    const testKey = 'api:test:machines';\r\n    const testData = {\r\n      machines: [\r\n        { id: 1, name: 'Machine 1', status: 'ONLINE' },\r\n        { id: 2, name: 'Machine 2', status: 'OFFLINE' }\r\n      ],\r\n      timestamp: new Date()\r\n    };\r\n    \r\n    // Сохраняем в кеш\r\n    console.log('   Сохранение тестовых данных в кеш...');\r\n    await cache.set(testKey, testData, 60);\r\n    console.log('   ✅ Данные сохранены');\r\n    \r\n    // Читаем из кеша\r\n    console.log('   Чтение данных из кеша...');\r\n    const cachedData = await cache.get(testKey);\r\n    console.log('   ✅ Данные получены:', cachedData ? 'Успешно' : 'Ошибка');\r\n    \r\n    // Проверяем TTL\r\n    const ttl = await cache.ttl(testKey);\r\n    console.log(`   ✅ TTL: ${ttl} секунд`);\r\n    \r\n    // Удаляем тестовые данные\r\n    await cache.delete(testKey);\r\n    console.log('   ✅ Тестовые данные удалены');\r\n    \r\n    // Тест 4: Производительность кеширования\r\n    console.log('\\n4️⃣ Тест производительности кеширования...');\r\n    \r\n    const perfKey = 'perf:test:api';\r\n    const largData = Array(1000).fill(null).map((_, i) => ({\r\n      id: i,\r\n      name: `Item ${i}`,\r\n      data: { index: i, value: Math.random() }\r\n    }));\r\n    \r\n    // Без кеша (эмуляция)\r\n    const dbStart = Date.now();\r\n    await new Promise(resolve => setTimeout(resolve, 100)); // Эмуляция запроса к БД\r\n    const dbTime = Date.now() - dbStart;\r\n    console.log(`   База данных: ${dbTime}ms`);\r\n    \r\n    // С кешем\r\n    await cache.set(perfKey, largData, 60);\r\n    const cacheStart = Date.now();\r\n    await cache.get(perfKey);\r\n    const cacheTime = Date.now() - cacheStart;\r\n    console.log(`   Redis кеш: ${cacheTime}ms`);\r\n    console.log(`   ✅ Ускорение: ${Math.round(dbTime / cacheTime)}x`);\r\n    \r\n    // Очистка\r\n    await cache.delete(perfKey);\r\n    \r\n    console.log('\\n✅ Все тесты пройдены успешно!');\r\n    console.log('🎉 Redis кеширование работает корректно.');\r\n    \r\n    // Закрываем соединение\r\n    await redis.quit();\r\n    \r\n  } catch (error) {\r\n    console.error('\\n❌ Ошибка при тестировании:', error.message);\r\n    if (error.response) {\r\n      console.error('   Статус:', error.response.status);\r\n      console.error('   Данные:', error.response.data);\r\n    }\r\n  }\r\n  \r\n  process.exit(0);\r\n}\r\n\r\n// Запускаем тесты\r\ntestRedisCache();\r\n",
  "test-redis-connection.js": "require('dotenv').config();\r\nconst { redis, cacheManagers } = require('./packages/shared-types/src/redis');\r\n\r\nasync function testRedisConnection() {\r\n  console.log('🔄 Тестирование подключения к Redis...');\r\n  console.log(`📍 URL: ${process.env.REDIS_URL}`);\r\n  \r\n  try {\r\n    // Тест 1: Проверка подключения\r\n    console.log('\\n1️⃣ Проверка подключения...');\r\n    await redis.ping();\r\n    console.log('✅ Подключение успешно!');\r\n    \r\n    // Тест 2: Базовые операции\r\n    console.log('\\n2️⃣ Тестирование базовых операций...');\r\n    const testKey = 'test:connection';\r\n    const testValue = { message: 'Hello Redis!', timestamp: new Date() };\r\n    \r\n    // SET\r\n    await redis.set(testKey, JSON.stringify(testValue));\r\n    console.log('✅ SET операция успешна');\r\n    \r\n    // GET\r\n    const retrieved = await redis.get(testKey);\r\n    const parsed = JSON.parse(retrieved);\r\n    console.log('✅ GET операция успешна:', parsed);\r\n    \r\n    // DELETE\r\n    await redis.del(testKey);\r\n    console.log('✅ DELETE операция успешна');\r\n    \r\n    // Тест 3: Работа с CacheManager\r\n    console.log('\\n3️⃣ Тестирование CacheManager...');\r\n    const cache = cacheManagers.machines;\r\n    \r\n    // Сохранение объекта\r\n    const testData = {\r\n      id: '123',\r\n      name: 'Test Machine',\r\n      status: 'ONLINE',\r\n      createdAt: new Date()\r\n    };\r\n    \r\n    await cache.set('test:machine', testData, 60); // TTL 60 секунд\r\n    console.log('✅ CacheManager SET успешен');\r\n    \r\n    // Получение объекта\r\n    const cachedData = await cache.get('test:machine');\r\n    console.log('✅ CacheManager GET успешен:', cachedData);\r\n    \r\n    // Проверка TTL\r\n    const ttl = await cache.ttl('test:machine');\r\n    console.log(`✅ TTL проверен: ${ttl} секунд`);\r\n    \r\n    // Удаление\r\n    await cache.delete('test:machine');\r\n    console.log('✅ CacheManager DELETE успешен');\r\n    \r\n    // Тест 4: Паттерны и множественные ключи\r\n    console.log('\\n4️⃣ Тестирование паттернов...');\r\n    \r\n    // Создаем несколько ключей\r\n    await cache.set('machines:list:page1', ['machine1', 'machine2'], 60);\r\n    await cache.set('machines:list:page2', ['machine3', 'machine4'], 60);\r\n    await cache.set('machines:stats', { total: 4, online: 3 }, 60);\r\n    console.log('✅ Множественные ключи созданы');\r\n    \r\n    // Удаление по паттерну\r\n    await cache.deletePattern('machines:list:*');\r\n    console.log('✅ Удаление по паттерну выполнено');\r\n    \r\n    // Проверка что stats остался\r\n    const stats = await cache.get('machines:stats');\r\n    console.log('✅ Проверка селективного удаления:', stats ? 'stats сохранен' : 'stats удален');\r\n    \r\n    // Очистка\r\n    await cache.delete('machines:stats');\r\n    \r\n    // Тест 5: Функция cache()\r\n    console.log('\\n5️⃣ Тестирование функции cache()...');\r\n    \r\n    let callCount = 0;\r\n    const expensiveOperation = async () => {\r\n      callCount++;\r\n      console.log(`  Выполнение дорогой операции (вызов #${callCount})...`);\r\n      await new Promise(resolve => setTimeout(resolve, 100));\r\n      return { result: 'expensive data', count: callCount };\r\n    };\r\n    \r\n    // Первый вызов - выполнит функцию\r\n    const result1 = await cache.cache('expensive:op', expensiveOperation, 30);\r\n    console.log('  Результат 1:', result1);\r\n    \r\n    // Второй вызов - вернет из кеша\r\n    const result2 = await cache.cache('expensive:op', expensiveOperation, 30);\r\n    console.log('  Результат 2:', result2);\r\n    console.log(`✅ Функция cache() работает корректно (вызовов функции: ${callCount})`);\r\n    \r\n    // Очистка\r\n    await cache.delete('expensive:op');\r\n    \r\n    // Тест 6: Производительность\r\n    console.log('\\n6️⃣ Тест производительности...');\r\n    \r\n    const testDataLarge = Array(100).fill(null).map((_, i) => ({\r\n      id: `machine-${i}`,\r\n      name: `Machine ${i}`,\r\n      status: i % 3 === 0 ? 'OFFLINE' : 'ONLINE',\r\n      data: { index: i, timestamp: new Date() }\r\n    }));\r\n    \r\n    // Запись\r\n    const writeStart = Date.now();\r\n    await cache.set('perf:test', testDataLarge, 60);\r\n    const writeTime = Date.now() - writeStart;\r\n    console.log(`  Запись 100 объектов: ${writeTime}ms`);\r\n    \r\n    // Чтение\r\n    const readStart = Date.now();\r\n    const readData = await cache.get('perf:test');\r\n    const readTime = Date.now() - readStart;\r\n    console.log(`  Чтение 100 объектов: ${readTime}ms`);\r\n    console.log(`✅ Производительность: запись ${writeTime}ms, чтение ${readTime}ms`);\r\n    \r\n    // Очистка\r\n    await cache.delete('perf:test');\r\n    \r\n    console.log('\\n✅ Все тесты пройдены успешно!');\r\n    console.log('🎉 Redis работает корректно и готов к использованию.');\r\n    \r\n  } catch (error) {\r\n    console.error('\\n❌ Ошибка при тестировании Redis:', error.message);\r\n    console.error('Детали:', error);\r\n  } finally {\r\n    // Закрываем соединение\r\n    await redis.quit();\r\n    console.log('\\n👋 Соединение закрыто');\r\n    process.exit(0);\r\n  }\r\n}\r\n\r\n// Запускаем тесты\r\ntestRedisConnection();\r\n",
  "update-and-restart.js": "/**\r\n * VHM24 - Update and Restart Script\r\n * \r\n * Этот скрипт обновляет систему из репозитория и перезапускает все сервисы\r\n */\r\n\r\nconst { execSync } = require('child_process');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nconsole.log('🔄 Обновление и перезапуск системы VHM24...\\n');\r\n\r\ntry {\r\n  // Остановка всех процессов Node.js\r\n  console.log('⏹️ Остановка всех процессов Node.js...');\r\n  try {\r\n    execSync('taskkill /f /im node.exe', { stdio: 'inherit' });\r\n  } catch (error) {\r\n    console.log('⚠️ Некоторые процессы не удалось остановить, продолжаем...');\r\n  }\r\n\r\n  // Получение последних изменений из репозитория\r\n  console.log('\\n📥 Получение последних изменений из репозитория...');\r\n  execSync('git pull origin main', { stdio: 'inherit' });\r\n\r\n  // Установка зависимостей\r\n  console.log('\\n📦 Установка зависимостей...');\r\n  execSync('npm install', { stdio: 'inherit' });\r\n\r\n  // Обновление зависимостей Fastify\r\n  console.log('\\n🔄 Обновление зависимостей Fastify...');\r\n  execSync('node update-fastify.js', { stdio: 'inherit' });\r\n\r\n  // Применение миграций базы данных\r\n  console.log('\\n🗃️ Применение миграций базы данных...');\r\n  execSync('cd packages/database && npx prisma migrate deploy', { stdio: 'inherit' });\r\n\r\n  // Запуск системы\r\n  console.log('\\n🚀 Запуск системы...');\r\n  execSync('npm start', { stdio: 'inherit' });\r\n\r\n  console.log('\\n✅ Система успешно обновлена и запущена!');\r\n} catch (error) {\r\n  console.error('\\n❌ Ошибка при обновлении и запуске системы:', error.message);\r\n  process.exit(1);\r\n}\r\n",
  "update-database-and-restart.js": "require('dotenv').config();\r\nconst { execSync } = require('child_process');\r\nconst path = require('path');\r\n\r\nconsole.log('🔄 Обновление конфигурации базы данных и перезапуск системы...\\n');\r\n\r\n// Показываем текущие настройки\r\nconsole.log('📊 Текущие настройки:');\r\nconsole.log(`   PostgreSQL: ${process.env.DATABASE_URL?.substring(0, 50)}...`);\r\nconsole.log(`   Redis: ${process.env.REDIS_URL?.substring(0, 50)}...`);\r\n\r\nasync function updateAndRestart() {\r\n  try {\r\n    // 1. Останавливаем все сервисы\r\n    console.log('\\n1️⃣ Останавливаем все сервисы...');\r\n    try {\r\n      execSync('pm2 stop all', { stdio: 'inherit' });\r\n    } catch (e) {\r\n      console.log('   Сервисы уже остановлены или PM2 не запущен');\r\n    }\r\n\r\n    // 2. Ждем 2 секунды\r\n    console.log('\\n2️⃣ Ожидание завершения процессов...');\r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n    // 3. Генерируем Prisma клиент\r\n    console.log('\\n3️⃣ Генерация Prisma клиента...');\r\n    try {\r\n      execSync('cd packages/database && npx prisma generate', { \r\n        stdio: 'inherit',\r\n        env: { ...process.env, FORCE_COLOR: '0' }\r\n      });\r\n      console.log('   ✅ Prisma клиент сгенерирован');\r\n    } catch (error) {\r\n      console.log('   ⚠️  Ошибка генерации Prisma клиента:', error.message);\r\n      console.log('   Продолжаем без обновления клиента...');\r\n    }\r\n\r\n    // 4. Запускаем сервисы заново\r\n    console.log('\\n4️⃣ Запуск сервисов с обновленными переменными...');\r\n    execSync('pm2 start ecosystem.config.js', { stdio: 'inherit' });\r\n\r\n    // 5. Обновляем переменные окружения\r\n    console.log('\\n5️⃣ Обновление переменных окружения...');\r\n    execSync('pm2 restart all --update-env', { stdio: 'inherit' });\r\n\r\n    // 6. Ждем инициализации\r\n    console.log('\\n6️⃣ Ожидание инициализации сервисов...');\r\n    await new Promise(resolve => setTimeout(resolve, 5000));\r\n\r\n    // 7. Проверяем статус\r\n    console.log('\\n7️⃣ Проверка статуса сервисов...');\r\n    execSync('pm2 status', { stdio: 'inherit' });\r\n\r\n    console.log('\\n✅ Система обновлена и перезапущена!');\r\n    console.log('\\n📝 Полезные команды:');\r\n    console.log('   pm2 logs - просмотр логов');\r\n    console.log('   pm2 monit - мониторинг в реальном времени');\r\n    console.log('   node test-all-services.js - тестирование сервисов');\r\n    console.log('   node test-redis-connection.js - тест Redis');\r\n\r\n  } catch (error) {\r\n    console.error('\\n❌ Ошибка:', error.message);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nupdateAndRestart();\r\n",
  "vhm24-cli.js": "#!/usr/bin/env node\r\n\r\nconst command = process.argv[2];\r\nconst API_URL = 'http://localhost:8000';\r\n\r\nasync function fetchAPI(endpoint) {\r\n  try {\r\n    const response = await fetch(`${API_URL}${endpoint}`);\r\n    const data = await response.json();\r\n    console.log(JSON.stringify(data, null, 2));\r\n  } catch (error) {\r\n    console.error('Error:', error.message);\r\n  }\r\n}\r\n\r\nasync function main() {\r\n  switch(command) {\r\n    case 'health':\r\n      await fetchAPI('/health');\r\n      break;\r\n    case 'stats':\r\n      await fetchAPI('/api/v1/dashboard/stats');\r\n      break;\r\n    case 'tasks':\r\n      await fetchAPI('/api/v1/tasks');\r\n      break;\r\n    case 'inventory':\r\n      await fetchAPI('/api/v1/inventory');\r\n      break;\r\n    case 'machines':\r\n      console.log('Fetching machines...');\r\n      // Добавить позже\r\n      break;\r\n    default:\r\n      console.log('VHM24 CLI - Vending Machine Management');\r\n      console.log('\\nUsage: node vhm24-cli.js <command>');\r\n      console.log('\\nCommands:');\r\n      console.log('  health     - Check system health');\r\n      console.log('  stats      - Dashboard statistics');\r\n      console.log('  tasks      - List all tasks');\r\n      console.log('  inventory  - List inventory');\r\n      console.log('  machines   - List machines (TODO)');\r\n  }\r\n}\r\n\r\nmain();\r\n"
}